<!DOCTYPE html>
<html lang="zh-CN en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="oBDuH0uFwsCklfLVrv3YP51al4TQiIuRQLW6p8VIz88" />
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jal285.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="java&#x2F;数据结构">
<meta property="og:url" content="jal285.github.io/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="pOne&#39;s blog">
<meta property="og:description" content="数据结构">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640-1621760078724.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/af3502319d2a56536b54a02f973a7534112150.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/adf35d4ba9207ade1ddd80d0f2ab11b598210.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/45dbcbcdfd1a99f1d01b3ae7b013cf7978526.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/d2004602c4b11c5207eae1ddcc013b2e43177.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/977048855e80f64b4bd72ed77a216dd643825.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state2.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state4.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp1.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp3.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp5.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp7.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/z.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/allstate.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp.gif">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211432689.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211522558.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211618808.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604220132697.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604220458664.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604154952573.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604160605517.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640-1622794011272">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604162103356.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192102467.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192125904.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192134305.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192157449.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/put.jpg">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525093139151.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525133839423.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134455666.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134523208.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134612750.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210602220300826.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603084923351.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603090902363.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091238580.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091323476.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091404705.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603092618795.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609084558020.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609084638141.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609105042701.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210608230032288.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609232210506.png">
<meta property="og:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609232650265.png">
<meta property="article:published_time" content="2021-06-11T09:51:35.917Z">
<meta property="article:modified_time" content="2021-06-11T09:51:35.917Z">
<meta property="article:author" content="pOne">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="jal285.github.io/java/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640-1621760078724.png">

<link rel="canonical" href="jal285.github.io/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>java/数据结构 | pOne's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pOne's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">pOne's website</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">43</span></a>

  </li>
        <li class="menu-item menu-item-favourite">

    <a href="/favourite/" rel="section"><i class="fa fa-fw fa-fa-star"></i>favourite</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN en">
    <link itemprop="mainEntityOfPage" href="jal285.github.io/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.jpg">
      <meta itemprop="name" content="pOne">
      <meta itemprop="description" content="to lean your likes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pOne's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java/数据结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-11 17:51:35" itemprop="dateCreated datePublished" datetime="2021-06-11T17:51:35+08:00">2021-06-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><a id="more"></a>



<p>[TOC]</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="剑指Offer-No-09"><a href="#剑指Offer-No-09" class="headerlink" title="剑指Offer No.09"></a>剑指Offer No.09</h3><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>多数算法以树结构为框架 </p>
<h3 id="二叉树遍历框架"><a href="#二叉树遍历框架" class="headerlink" title="二叉树遍历框架"></a>二叉树遍历框架</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">BST(TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="keyword">val</span><span class="operator"> == </span>target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="keyword">val</span> &lt; target) </span><br><span class="line">        <span class="constructor">BST(<span class="params">root</span>.<span class="params">right</span>, <span class="params">target</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="keyword">val</span> &gt; target)</span><br><span class="line">        <span class="constructor">BST(<span class="params">root</span>.<span class="params">left</span>, <span class="params">target</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>leet.652 寻找重复子树</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640-1621760078724.png" alt="Image"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TreeNode&gt; findDuplicateSubtrees(<span class="name">TreeNode</span> root)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>分析 : </p>
<p>想知道以自己为根的子树是不是重复的, 是否应该加入结果列表中, 需要知道一下信息</p>
<ol>
<li>以我为根的这颗二叉树(子树)样子</li>
<li>以其他节点为根的子树都长什么样子 </li>
</ol>
<p>计算一颗二叉树有多少个节点</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>(TreeNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先算出右子树有多少节点</span></span><br><span class="line">	<span class="keyword">int</span> left = <span class="keyword">count</span>(root.left);</span><br><span class="line">	<span class="keyword">int</span> right = <span class="keyword">count</span>(root.right);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h4 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h4><p>二叉查找树  ,左节点比父节点值小,  右节点比父节点值大, 高度决定了查找效率</p>
<p>在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/af3502319d2a56536b54a02f973a7534112150.png" alt="img"></p>
<h5 id="BST查找操作"><a href="#BST查找操作" class="headerlink" title="BST查找操作"></a>BST查找操作</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T <span class="built_in"> key</span> = a search<span class="built_in"> key</span></span><br><span class="line">Node<span class="built_in"> root</span> = point <span class="keyword">to</span> the<span class="built_in"> root</span> <span class="keyword">of</span> a BST</span><br><span class="line"></span><br><span class="line">while<span class="built_in">(true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span><span class="built_in">(root</span>==null)&#123;</span><br><span class="line">    	break;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span><span class="built_in">(root</span>.<span class="keyword">value</span>.equals<span class="built_in">(key</span>))&#123;</span><br><span class="line">    	<span class="keyword">return</span><span class="built_in"> root</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span><span class="built_in">(key</span>.compareTo<span class="built_in">(root</span>.<span class="keyword">value</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">	root</span> =<span class="built_in"> root</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">	root</span> =<span class="built_in"> root</span>.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure>

<p>注意: 父结点要和左子树所有所属节点进行比较 , 且所有左子树所属节点小于父节点值</p>
<p>进行查找时和父节点比较后可以同时排除两个 key&gt;root , key在root.right 找, key&lt;root , 在 roo.left找</p>
<p>直到当前节点指针为空或者查找到对应的节点，程序查找结束。</p>
<h5 id="BST-插入"><a href="#BST-插入" class="headerlink" title="BST 插入"></a>BST 插入</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span> <span class="title">node</span> = create a new <span class="keyword">node</span> <span class="title">with</span> specify value</span><br><span class="line"><span class="keyword">Node</span> <span class="title">root</span> = point the root <span class="keyword">node</span> <span class="title">of</span> a BST</span><br><span class="line"><span class="keyword">Node</span> <span class="title">parent</span> = null;</span><br><span class="line"></span><br><span class="line">//find the parent <span class="keyword">node</span> <span class="title">to</span> append the new <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   if(<span class="attr">root=</span>=null)break;</span><br><span class="line">   parent = root;</span><br><span class="line">   if(<span class="keyword">node</span>.<span class="title">value</span>.compareTo(root.value)<span class="tag">&lt;=0)&#123;</span></span><br><span class="line"><span class="tag">      root = root.left;  </span></span><br><span class="line"><span class="tag">   &#125;else&#123;</span></span><br><span class="line"><span class="tag">      root = root.right;</span></span><br><span class="line"><span class="tag">   &#125; </span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag">if(parent!=null)&#123;</span></span><br><span class="line"><span class="tag">   if(node.value.compareTo(parent.value)&lt;=0)&#123;//append to left</span></span><br><span class="line"><span class="tag">      parent.left = node;</span></span><br><span class="line"><span class="tag">   &#125;else&#123;//append to right</span></span><br><span class="line"><span class="tag">	  parent.right = node;</span></span><br><span class="line"><span class="tag">   &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>

<p>插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。</p>
<h5 id="BST删除"><a href="#BST删除" class="headerlink" title="BST删除"></a>BST删除</h5><ol>
<li>查找到要删除的节点。</li>
<li>如果待删除的节点是叶子节点，则直接删除。</li>
<li>如果待删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。</li>
</ol>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/adf35d4ba9207ade1ddd80d0f2ab11b598210.png" alt="img"></p>
<p>删除叶子节点后需要保证BST树的完整, 所以需要查看节点子节点是否为空 ,不为空要使用子节点替代被删除节点 </p>
<h5 id="BST存在的问题"><a href="#BST存在的问题" class="headerlink" title="BST存在的问题"></a>BST存在的问题</h5><p><strong>BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。</strong></p>
<h4 id="RBTree"><a href="#RBTree" class="headerlink" title="RBTree"></a>RBTree</h4><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p>
<p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。</p>
<p>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure>

<p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p>
<p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p>
<p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><a href="https://tech.meituan.com/2016/12/02/redblack-tree.html" target="_blank" rel="noopener">参考</a></p>
<p>红黑树是平衡二叉查找树的一种 </p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol>
<li>任何一个节点都有颜色 ,黑色或者红色</li>
<li>根节点是黑色的</li>
<li>父子节点之间不能出现两个连续的红节点</li>
<li>任何一个节点向下遍历到其子孙的叶子节点, 所经过的黑节点个数必须相等</li>
<li>空节点被认为是黑色的</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">&lt;T</span>&gt;&#123;</span><br><span class="line">	public T value;</span><br><span class="line">	public boolean isRead;</span><br><span class="line">	public <span class="keyword">Node</span><span class="title">&lt;T</span>&gt; left;</span><br><span class="line">	public <span class="keyword">Node</span><span class="title">&lt;T</span>&gt; right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>RBTree 在理论上还是一颗BST树, 但是它在对BST 的插入和删除操作会维持树的平衡, 即保证树的高度在[logN, logN +1 ] (理论上, 极端的情况下可以出现RBTree的高度可以达到2*logN ,但实际上很难遇到 ) . 这样RBTree 的查找时间复杂度始终保持在 O(logN) 从而接近于理想的BST, RBTree 的删除和插入的时间复杂度也是O(logN). RBTree 的查找操作就是BST的查找操作 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/45dbcbcdfd1a99f1d01b3ae7b013cf7978526.png" alt="img"></p>
<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>RBTree 的查找操作和 BST 的查找操作是一样的  </p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入与BST插入方式一致. 只不过是插入过后, 可能会导致树的不平衡操作 ,只不过插入后会导致树的不平衡 , 需要对数进行旋转操作和颜色修复,使得它符合RBTree的定义 ,新插入的节点是红色的. 颜色修复操作如果遇到父节点的颜色为黑则修复操作结束 , 也就是说 ,只有子父节点为红色节点的时候需要颜色修复操作</p>
<p>颜色修复操作分一下三种情况 </p>
<ol>
<li>叔叔节点也为红色</li>
<li>叔叔节点为空, 且祖父节点, 父节点和新节点处于一条xie线上</li>
<li>叔叔节点为空, 且祖父节点, 父节点和新节点不处于一条斜线上</li>
</ol>
<p>插入操作-Case 1</p>
<p>case 1 的操作是将父节点和叔叔节点与祖父节点的颜色互换, 这样就符合了RBTree 的定义 . 即维持了高度的平衡, 修复后颜色也符合RBTree 定义的第三条和第四条 </p>
<p>操作完成后A节点变成了新的节点. 如果 A节点的父节点不是黑色的话, 则继续做修复操作 </p>
<p>插入操作-Casse 2 </p>
<p>case2 的操作是将B节点进行右旋操作, 并且和父节点A互换颜色 . 通过该修复操作RBTree 的高度和颜色都符和红黑树的定义 . 如果 B和 C节点都是右节点的话, 只要将操作变成左旋就可以了<img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/d2004602c4b11c5207eae1ddcc013b2e43177.png" alt="img"></p>
<p>插入操作-Case 3</p>
<p>case 3 的操作是将C节点进行左旋, 这样就从Case 3转换成case 2 了,然后针对case 2 进行操作处理就行了. case 2 操作做了一个右旋操作和颜色互换来达到目的. 如果树的结构是下面的镜像结构, 则只需要将对应的左旋变成右旋, 右旋变成左旋即可 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/977048855e80f64b4bd72ed77a216dd643825.png" alt="img"></p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>No.705</p>
<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>
<p>实现 MyHashSet 类：</p>
<ol>
<li>void add(key) 向哈希集合中插入值 key 。</li>
<li>bool contains(key) 返回哈希集合中是否存在这个值 key 。</li>
<li>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ol>
<p>哈希集合实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] nodes = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000009</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        nodes[key] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        nodes[key] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodes[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引申一下哈希函数</p>
<p>哈希函数是指把一个大范围映射到一个小范围, 把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。</p>
<p>\1. Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会很多。<br>\2. 由于Hash逼近单向函数；所以，你可以用它来对数据进行加密。<br>\3. 不同的应用对Hash函数有着不同的要求；比如，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。</p>
<p>Hash函数应用的主要对象是数组（比如，字符串），而其目标一般是一个int类型。以下我们都按照这种方式来说明。</p>
<p>一般的说，Hash函数可以划分为如下几类：<br>\1. 加法Hash</p>
<p>\2. 位运算Hash</p>
<p>\3. 乘法Hash</p>
<p>\4. 除法Hash</p>
<p>\5. 查表Hash</p>
<p>\6. 混合Hash</p>
<p>7.数组Hash</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p> 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
<p>   贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>  <strong>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>
<p>思路</p>
<p>1.建立数学模型来描述问题。</p>
<p>  2.把求解的问题分成若干个子问题。</p>
<p>  3.对每一子问题求解，得到子问题的局部最优解。</p>
<p>  4.把子问题的解局部最优解合成原来解问题的一个解。</p>
<p>贪心算法适用情况很少 </p>
<p>从问题的某一初始解出发；</p>
<p>  while （能朝给定总目标前进一步）</p>
<p>  { </p>
<p>​     利用可行的决策，求出可行解的一个解元素；</p>
<p>  }</p>
<p>  由所有解元素组合成问题的一个可行解；</p>
<h3 id="OfferNo14-剪绳子问题"><a href="#OfferNo14-剪绳子问题" class="headerlink" title="OfferNo14   剪绳子问题"></a>OfferNo14   剪绳子问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">adjectime</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  length-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// n&gt;=5 时. 多剪长度为 3 的绳子 , 剩下的绳子长度为4时, 把僧子剪成两段长度为2的绳子</span></span><br><span class="line">        <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span> ;</span><br><span class="line">        <span class="keyword">if</span> (length%<span class="number">3</span> == <span class="number">1</span> )&#123;</span><br><span class="line">            --timesOf3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> timeof2 = (length - timesOf3 * <span class="number">3</span> ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>,timesOf3)*Math.pow(<span class="number">2</span>,timeof2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="KMP字符匹配算法"><a href="#KMP字符匹配算法" class="headerlink" title="KMP字符匹配算法"></a>KMP字符匹配算法</h3><p>Knuth-Morris-Pratt 算法,  是一个著名的字符串匹配算法 ,效率很高</p>
<p>KMP <strong>永不回退 <code>txt</code> 的指针 <code>i</code>，不走回头路（不会重复扫描 <code>txt</code>），</strong> 借助 dp 数组中存储的信息 把 pat 移到正确的位置和 txt 匹配 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">KMP</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> [][]dp;</span><br><span class="line">	<span class="keyword">private</span> String pat;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.pat = pat;</span><br><span class="line">		<span class="comment">//通过pat 构建dp数组</span></span><br><span class="line">		<span class="comment">//需要O(M)时间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span>&#123;</span><br><span class="line">		<span class="comment">//借助dp数组去匹配 txt </span></span><br><span class="line">		<span class="comment">//需要 O(N)时间 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当我们需要用同一 pat 去匹配不同 txt 时, 就不需要浪费时间 构造 dp数组了 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KMP kmp = <span class="keyword">new</span> KMP(<span class="string">"aaab"</span>);</span><br><span class="line"><span class="keyword">int</span> pos1 = kmp.search(<span class="string">"aaacaaaab"</span>);</span><br><span class="line"><span class="keyword">int</span> pos2 = kmp.search(<span class="string">"aaaaaaaab"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="状态机概述"><a href="#状态机概述" class="headerlink" title="状态机概述"></a>状态机概述</h4><p>为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 <code>pat</code> 的匹配就是状态的转移。比如当 pat = “ABABC”：</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state.jpg" alt="img"></p>
<p>如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（<code>pat.length</code>）是终止状态。开始匹配时 <code>pat</code> 处于起始状态，一旦转移到终止状态，就说明在 <code>txt</code> 中找到了 <code>pat</code>。比如说当前处于状态 2，就说明字符 “AB” 被匹配：</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state2.jpg" alt="img"></p>
<p>另外，处于不同状态时，<code>pat</code> 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/state4.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state4.jpg" alt="img"></a></p>
<p>具体什么意思呢，我们来一个个举例看看。用变量 <code>j</code> 表示指向当前状态的指针，当前 <code>pat</code> 匹配到了状态 4：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp1.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp1.jpg" alt="img"></a></p>
<p>如果遇到了字符 “A”，根据箭头指示，转移到状态 3 是最聪明的：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp3.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp3.jpg" alt="img"></a></p>
<p>如果遇到了字符 “B”，根据箭头指示，只能转移到状态 0（一夜回到解放前）：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp5.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp5.jpg" alt="img"></a></p>
<p>如果遇到了字符 “C”，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp7.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp7.jpg" alt="img"></a></p>
<p>当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 <code>pat</code> 中根本都没有字符 Z：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/z.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/z.jpg" alt="img"></a></p>
<p>这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 <code>pat</code> 中出现的字符的状态转移：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/allstate.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/allstate.jpg" alt="img"></a></p>
<p>KMP 算法最关键的步骤就是构造这个状态转移图。<strong>要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。</p>
<p>下面看一下 KMP 算法根据这幅状态转移图匹配字符串 <code>txt</code> 的过程：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/kmp.gif" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp.gif" alt="img"></a></p>
<p><strong>请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑</strong>！</p>
<p>为了描述状态转移图, 定义一个二维dp数组, 含义如下:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[j][c] = next </span><br><span class="line"><span class="number">0</span> &lt;= j &lt; M 代表当前状态 </span><br><span class="line"><span class="number">0</span> &lt;= c &lt; <span class="number">256</span> 代表遇到的字符(ASCII码)</span><br><span class="line"><span class="number">0</span> &lt;= next &lt;= M , 代表下一个状态 </span><br><span class="line"></span><br><span class="line">dp[<span class="number">4</span>][<span class="string">'A'</span>] = <span class="number">3</span> 表示 :</span><br><span class="line">当前是状态 <span class="number">4</span> , 如果遇到字符 A  pat 应该转移到状态<span class="number">3</span> </span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="string">'B'</span>] = <span class="number">2</span> 表示 :</span><br><span class="line">当前状态是<span class="number">1</span> , 如果遇到字符 B, pat 应该转移到状态 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>根据dp数组定义和状态转移过程  可以写出KMP算法的search 函数代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> M = pat.length();</span><br><span class="line">	<span class="keyword">int</span> N = txt.length();</span><br><span class="line">	<span class="comment">//pat的初始态 为 0 </span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="comment">// 当前是状态 j, 遇到字符 txt[i] , </span></span><br><span class="line">		<span class="comment">// pat 应该转移到那个状态 </span></span><br><span class="line">		j=dp[j][txt.charAt(i)];</span><br><span class="line">		<span class="comment">//如果达到终止态, 返回匹配开头的索引</span></span><br><span class="line">		<span class="keyword">if</span>(j==M)<span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//没达到终止态, 匹配失败 </span></span><br><span class="line"> 	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构建状态转移图"><a href="#构建状态转移图" class="headerlink" title="构建状态转移图"></a>构建状态转移图</h4><p>确定状态的行为, 必须明确两个变量, 一是当前的匹配状态, 另一个是遇到的字符, 而且我们已经根据这个逻辑确定了dp数组的含义, 那么构造dp 数组的框架为:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">for</span> <span class="number">0</span><span class="string">&lt;=j&lt;M:</span> <span class="comment">#状态 </span></span><br><span class="line">	<span class="string">for</span> <span class="number">0</span> <span class="string">&lt;=</span> <span class="string">c</span> <span class="string">&lt;</span> <span class="attr">256:</span> <span class="comment">#字符</span></span><br><span class="line">		<span class="string">dp[j][c]</span> <span class="string">=</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>求next 状态 , 遇到字符c和pat[j]匹配的话, 状态应该向前推进一个, 也就是说 next = j + 1 ,不妨称这种情况为状态推进:</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211432689.png" alt="image-20210604211432689"></p>
<p>如果遇到字符c 和 pat[j] 不匹配的话, 状态就要回退(或者原地不动), 可称这种情况为状态重启: </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211522558.png" alt="image-20210604211522558"></p>
<p>如何得知在哪个状态重启呢? 再定义一个名字: 影子状态 , 用变量X 表示 . <strong>所谓影子状态，就是和当前状态具有相同的前缀</strong>。比如下面这种情况：<img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211618808.png" alt="image-20210604211618808"></p>
<p>当前状态 j=4, 影子状态为 X=2, 都有相同的前缀 “AB”.因为状态<code>X</code>和状态<code>j</code>存在相同的前缀，所以当状态<code>j</code>准备进行状态重启的时候（遇到的字符<code>c</code>和<code>pat[j]</code>不匹配），可以通过<code>X</code>的状态转移图来获得<strong>最近的重启位置</strong>。</p>
<p>比如上面的情况 ,状态 j遇到一个字符”A”, 因该转移到哪里? 首先状态4只有遇到”C” 才能推进状态, 遇到”A” 那就智能进行状态重启, 状态j会把这个字符委托给状态X处理, 也就是dp[ j ] [ ‘A’ ] = dp[ X ] [ ‘A’ ] : </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604220132697.png" alt="image-20210604220132697"></p>
<p>这样做的原因: 既然 j 这边确定字符 “A” 无法推进状态, 只能回退, 而且KMP 算法就是要尽可能少的回退, 以免多余的计算, 那么 j 就可以去问问和自己具有相同前缀的 X ,如果X 遇见”A” 可以进行状态推进, 那就转移过去, 因为这样回退的最少: </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640" alt="图片"></p>
<p>​    当然, 如果遇到的字符是”B” , 状态X也不能进行状态 推进, 只能回退, j 只要跟着X 指引的方向回退就行了</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604220458664.png" alt="image-20210604220458664"></p>
<p>动态规划算法就是利用过去的结果解决现在的问题 </p>
<p>细化一下刚才的框架代码: </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">int</span> <span class="string">X</span> <span class="comment">#影子状态 </span></span><br><span class="line"><span class="string">for</span> <span class="number">0</span><span class="string">&lt;=j</span> <span class="string">&lt;</span> <span class="attr">M:</span></span><br><span class="line">	<span class="string">for</span> <span class="number">0</span> <span class="string">&lt;=</span> <span class="string">c</span> <span class="string">&lt;256:</span> </span><br><span class="line">		<span class="string">if</span> <span class="string">c==pat[j]:</span></span><br><span class="line">             <span class="comment">#状态推进 </span></span><br><span class="line">             <span class="string">dp[j][c]</span> <span class="string">=</span> <span class="string">j</span> <span class="string">+</span> <span class="number">1</span></span><br><span class="line">		<span class="attr">else:</span> </span><br><span class="line">			<span class="comment">#状态重启</span></span><br><span class="line">			<span class="comment">#委托 X 计算重启位置</span></span><br><span class="line">			<span class="string">dp[j][c]=dp[X][c]</span></span><br></pre></td></tr></table></figure>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>最后一个问题: 影子状态 X是如何获得的呢 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> clas KMP&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">	<span class="keyword">private</span> String pat; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.pat = pat;</span><br><span class="line">		<span class="keyword">int</span> M = pat.length();</span><br><span class="line">		<span class="comment">//dp[状态][字符] = 下个状态 </span></span><br><span class="line">		dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">256</span>];</span><br><span class="line">		<span class="comment">//base case </span></span><br><span class="line">		dp[<span class="number">0</span>][pat.charAt[<span class="number">0</span>]] = <span class="number">1</span>; </span><br><span class="line">		<span class="comment">//影子状态X初始为 0 </span></span><br><span class="line">		<span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//当前状态j 从 1 开始 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span> ; c++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(pat.charAt(j)==c)</span><br><span class="line">					dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					dp[j][c] = dp[X][c];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//更新影子状态 </span></span><br><span class="line">			X = dp[X][pat.charAt[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base case </span></span><br><span class="line">dp[<span class="number">0</span>][pat.charAt[<span class="number">0</span>]] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这行代码是 base case , 只有遇到 pat[0] 这个字符才能使状态从0 转移到 1 , 遇到其它字符的话还是停留在状态 0 ( Java 默认初始化数组为 0 )</p>
<p>影子状态 X 是 先初始化为 0 , 然后随着j 的前进而不断跟新的 .  </p>
<p>如何更新状态X :</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> X = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> j = <span class="number">1</span>; j &lt; M ; j++)&#123;</span><br><span class="line">	<span class="comment">//更新影子状态 </span></span><br><span class="line">	<span class="comment">//当前是状态 X, 遇到字符pat[j], </span></span><br><span class="line">	<span class="comment">//pat 应该转移到哪个状态? </span></span><br><span class="line">	X = dp[X][pat.charAt(j)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N ; i++)&#123;</span><br><span class="line">	<span class="comment">//当前是状态 j, 遇到字符 txt[i],</span></span><br><span class="line">	<span class="comment">//pat 应该转移到哪个状态? </span></span><br><span class="line">	j = dp[j][txt.charAt(i)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 for 循环中的变量初始值  </p>
<p>后者在txt中匹配 pat, 前者在 pat 中匹配 pat[1:]. 状态 X 总是落后状态j 一个状态 , 与 j 具有最长的相同前缀 , 所以我们把X比喻为影子状态 </p>
<p>另外, 构建dp 数组是根据base case dp[0] [..] 向后推演. </p>
<p>下面来看一下状态转移图的完整构造过程, </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640" alt="图片"></p>
<p>KMP完整代码 : </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">KMP</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span>[][]dp;</span><br><span class="line">	<span class="keyword">private</span> String pat;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> KMP(String pat)&#123;</span><br><span class="line">		<span class="keyword">this</span>.pat = pat;</span><br><span class="line">		<span class="built_in">int</span> M = pat.length();</span><br><span class="line">		<span class="comment">//dp[状态][字符] = 下个撞他 </span></span><br><span class="line">		dp = new <span class="built_in">int</span>[M][<span class="number">256</span>];</span><br><span class="line">		<span class="comment">//base case </span></span><br><span class="line">		dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//影子状态 </span></span><br><span class="line">		<span class="built_in">int</span> X = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 构建状态转移图 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>;j&lt;M;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> c = <span class="number">0</span>;j &lt; <span class="number">256</span>; c++)&#123;</span><br><span class="line">				dp[j][c] = dp[X][c];</span><br><span class="line">			dp[j][pat.charAt(j)] = j+<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//影子状态 </span></span><br><span class="line">			X =  dp[X][pat.charAt(j)]; 	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> search(String txt)&#123;</span><br><span class="line">		<span class="built_in">int</span> M = pat.length();</span><br><span class="line">		<span class="built_in">int</span> N = txt.length();</span><br><span class="line">		<span class="comment">//pat的初始状态为 0  </span></span><br><span class="line">		<span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ;i&lt;N; i++)&#123;</span><br><span class="line">			<span class="comment">//计算pat 的下一个状态 </span></span><br><span class="line">			j = dp[j][txt.charAt(i)];</span><br><span class="line">			<span class="comment">//达到终止态, 返回结果</span></span><br><span class="line">			<span class="keyword">if</span>(j==M) reutrn i - M + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//没达到终止态 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>传统的KMP 算法是使用一个一维数组 next 记录前缀信息, 而本文是使用一个二维数组 dp 以状态转移的角度解决字符匹配问题, 单身空间复杂度仍然是 O(256M) = O(M) </p>
<p>在pat 匹配 txt的过程中, 只要明确了[当前处在哪个状态] 和 [ 遇到的字符是什么 ] 这两个问题, 就可以确定应该转移到哪个状态(推进或回退) </p>
<p>对于一个模式串 pat, 其总共就有M 个状态, 对于 ASCII 字符, 总共不会超过256 种. 所以我们就构造一个数组 dp[M] [256] 来包含所有情况, 并且明确 dp 数组的含义 : </p>
<p> dp[ j ]  [c] = next 表示, 当前是状态 j, 遇到了字符 c, 应该转移到状态 next . </p>
<p>明确了其含义, 就可以很容易写出 search 函数的代码 </p>
<p>对于如何构建这个dp 数组, 需要一个辅助状态 X , 它永远比当前状态 j 落后一个状态 ,拥有和 j 最长的相同前缀 ,给它起了个名字交 [影子状态 ] </p>
<p>在构建当前状态<code>j</code>的转移方向时，只有字符<code>pat[j]</code>才能使状态推进（<code>dp[j][pat[j]] = j+1</code>）；而对于其他字符只能进行状态回退，应该去请教影子状态<code>X</code>应该回退到哪里（<code>dp[j][other] = dp[X][other]</code>，其中<code>other</code>是除了<code>pat[j]</code>之外所有字符）。</p>
<p>对于影子状态<code>X</code>，我们把它初始化为 0，并且随着<code>j</code>的前进进行更新，更新的方式和 search 过程更新<code>j</code>的过程非常相似（<code>X = dp[X][pat[j]]</code>）。</p>
<p>KMP 算法也就是动态规划的思路，我们的公众号文章目录有动态规划系列，而且都是按照一套框架来的，无非就是描述问题逻辑，明确<code>dp</code>数组含义，定义 base case 这点破事。</p>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604154952573.png" alt="image-20210604154952573"></p>
<p>子串一定是连续的,子序列不一定是连续的</p>
<h4 id="动态归纳解法"><a href="#动态归纳解法" class="headerlink" title="动态归纳解法"></a>动态归纳解法</h4><p>动态规划的核心设计思想是数学归纳法 </p>
<p>假设一个结论在 k&lt;n时成立,再证明k=n时成立, 当证明成立时,则说明这个结论对于k等于任何数都成立 </p>
<p>设计动态规划算法, 我们需要一个dp数组, 可以假设dp[0…i-1] 都已经被算出来了, 然后怎么通过这些结果算出dp[i]</p>
<p>dp[i] 表示以 nums[i] 这个数结尾的最长递增<strong>子序列</strong>的长度。</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604160605517.png" alt="image-20210604160605517"></p>
<p>算法演进过程:</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640-1622794011272" alt="图片"></p>
<p>根据此定义,我们的最终结果(子序列的最大长度) 应该是dp 数组的最大值 </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;dp.<span class="built_in">length</span>();<span class="built_in">i</span>++)&#123;</span><br><span class="line">	res = Math.<span class="built_in">max</span>(res,dp[<span class="built_in">i</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>设计算法逻辑来正确计算dp[i]</p>
<p>推出dp[5]</p>
<p>递增子序列, 找出前面比nums[5] 值小的子序列,将nums[5]接到最后, 就可以形成一个新的递增子序列, 新的子序列长度加1 ,</p>
<p>可能会生成很多新的子序列, 但我们只要最长的子序列的长度作为dp[5]的值 </p>
<p>如</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;<span class="built_in">i</span>;<span class="built_in">j</span>++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[<span class="built_in">j</span>]&lt;nums[<span class="built_in">i</span>])&#123;</span><br><span class="line">		dp[<span class="built_in">i</span>] = Math.<span class="built_in">max</span>(dp[<span class="built_in">i</span>],dp[<span class="built_in">j</span>]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>计算任意dp[i]</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604162103356.png" alt="image-20210604162103356"></p>
<p>一个细节问题,  base case , dp 数组应该初始化为 1 , 因为子序列最少也要包含自己, 所以长度最小为1,</p>
<p>完整代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLTS</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[]dp=<span class="keyword">new</span> <span class="keyword">int</span>[num.length()];</span><br><span class="line">	<span class="comment">//dp 数组全都初始化为 1 </span></span><br><span class="line">	Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length();i++ )&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">				dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length();i++)&#123;</span><br><span class="line">		res-Math.max(res,dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N^2)  ,动态规划设计流程  </p>
<ul>
<li>明确dp数组所存数据的含义(5*) ,不得当或不够清晰, 会阻碍之后的步骤 </li>
<li>根据dp数组的定义, 运用数学归纳法的思想, 假设dp[0…i-1] 都已知, 想办法求出dp[i], 这步完成 ,整个题目基本就解决了 </li>
<li>无法完成上一步时,可能是dp数组的定义不够恰当,需要重新定义dp数组的含义 ; 或者可能是dp数组促成农户的信息还不够, 不足以推出下一步的答案 , 需要把dp数组扩大成二维数组甚至三维数组</li>
</ul>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>时间复杂度会将为O(NlogN) ,作为 了解 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192102467.png" alt="image-20210604192102467"></p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192125904.png" alt="image-20210604192125904"></p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192134305.png" alt="image-20210604192134305"></p>
<p>二分查找, 对本题来说二分查找难想, 有动态规划就足够, 但二分查找还是要学 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192157449.png" alt="image-20210604192157449">  </p>
<h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>对动态规划进行降维打击</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485824&idx=1&sn=09caa56172729cf8cf1b53089e8dee55&chksm=9bd7f788aca07e9e4149f384ec5e279adadec75a2828a76066c56b4789209fb1cd54f9e63f9d&scene=21#wechat_redirect" target="_blank" rel="noopener">参考</a></p>
<p>状态压缩就是投影</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>动态规划</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>缓存淘汰策略 .快来手写LRU算法 </p>
<p>No146 .  </p>
<p>首先要接受一个cpacity 参数 作为缓存的最大容量 , 然后实现两个API ,一个是    put(key, val) 方法存入键值对, 另一个是get(key) 方法获取key 对应的val , 如果key 不存在则返回 -1. </p>
<p>注意哦, <strong>get</strong>和 <strong>put</strong>  方法是O(1) 的时间复杂度, 我们举个具体例子来看看LRU 算法怎么工作 .</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓存容量为 2 */</span> </span><br><span class="line">LRUCache cache = new LRUCache(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 可以把cache 理解成一个队列 </span></span><br><span class="line"><span class="comment">// 假设左边是对头, 右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在对头, 右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在对头, 久未使用的排在队尾 .</span></span><br><span class="line"><span class="comment">// 圆括号表示键值对( key, val)</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">// cache = [(1,1)]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// cache = [(2,2), (1,1)]</span></span><br><span class="line"></span><br><span class="line">chche.<span class="keyword">get</span>(<span class="number">1</span>)  		<span class="comment">//返回 1</span></span><br><span class="line"><span class="comment">// cache = [(1,1),(2,2)]</span></span><br><span class="line"><span class="comment">// 解释: 因为最近访问了键 1, 所以提前队头 </span></span><br><span class="line"><span class="comment">// 返回键 1 对应的值 1 </span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// cache = [(3,3),(1,1)]</span></span><br><span class="line"><span class="comment">// 解释:缓存容量已满, 需要删除内容空出位置 </span></span><br><span class="line"><span class="comment">// 优先删除久未使用的数据, 也就是队尾的数据 </span></span><br><span class="line"><span class="comment">// 然后把新的数据插入队头</span></span><br><span class="line"></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">2</span>) ;     	<span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">// cache = [(3,3),(1,1)]</span></span><br><span class="line"><span class="comment">// 解释 : cache 中不存在键为 2的数据 </span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// cache = [(1,4).(3,3)]</span></span><br><span class="line"><span class="comment">// 解释: 键 1已存在, 把原始值覆盖为4 </span></span><br><span class="line"><span class="comment">// 不要忘了也要将键值队提到 队头</span></span><br></pre></td></tr></table></figure>

<h4 id="LRU-设计"><a href="#LRU-设计" class="headerlink" title="LRU 设计"></a>LRU 设计</h4><ol>
<li><p>分析上面操作过程, 要让put和get 方法 时间复杂度为O(1), 我们可以总结出 cache 这个数据结构必要条件 </p>
</li>
<li><p>在cache中快速找某个key是否已存在并得到对应的value</p>
</li>
<li><p>每次访问 cache 中的某个key , 需要将这个元素变为最近使用的, 也就是cache 要支持在任意位置快速插入和删除元素 </p>
</li>
</ol>
<p>结合上面要求 , 形成一种新的数据结构: 哈希链表 : LinkedHashMap</p>
<p>LRU 缓存算法的核心数据结构就是哈希链表, 双向链表和哈希表的结合体 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.jpg" alt="HashLinkedList"></p>
<p>我们构建 缓存 需要删除操作 ,删除一个节点不光要得到该节点本身的指针, 也需要操作其前驱节点的指针,而双向链表才能支持查找前驱, 保证操作的时间复杂度O(1)</p>
<p><strong>注意我们实现的双链表只能从尾部插入, 也就是说靠近尾部的数据是最近使用的 , 靠头部的数据是最久未使用的</strong></p>
<p>有了双向链表的实现, 我们只需要在LRU算法中把它和哈希表结合起来即可 </p>
<p>同时维护一个双链表cache和一个哈希表map , 很容易漏掉一些操作, 比如删除某个key 时 , 在cache 中删除了对应的Node, 但忘记了在map中删除 key </p>
<p><strong>在两种数据结构上提供一层抽象API</strong> </p>
<p>尽量让LUR 的主方法 get 和 put 避免直接操作 map和 cache 的细节 </p>
<p>当我们对元素进行操作时的时候, 我们需要用到key来保证 cache 和 map的一致性 </p>
<p>当缓存容量已满, 我们不仅仅要删除最后一个Node 节点, 还要把map 中映射到该节点的key同时删除, 而这个key 只能由 Node 得到 , 如果 Node 结构中只存储 val , 那么我们就无法得知key 时什么 , 无法删除 map 中的键 , 造成错误</p>
<p>使用函数 对 操作进行简单封装 ,调用这些函数就可以避免直接操作 cache 链表 和 map 哈希表   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span>  Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k ;</span><br><span class="line">        <span class="keyword">this</span>.val = v ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* */</span></span><br><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头尾虚节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="comment">//链表元素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化双向链表数据</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    在链表尾部添加节点x, 时间O(1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 被添加节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">addLast</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将被插入位置的节点记录为x的记录</span></span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        <span class="comment">//将tail 节点变成x的next 节点</span></span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev.next = x;</span><br><span class="line">        tail.prev = x;</span><br><span class="line">        size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除链表种 的x节点(x一定存在)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * 由于是双链表且给的是目标Node节点, 时间 O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//x的前一个节点</span></span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        <span class="comment">//x的后一个节点</span></span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 溢出链表中第一个节点, 并返回该节点, 时间O(1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除的第一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        remove(first);</span><br><span class="line">        <span class="keyword">return</span>  first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>,来实现 LRU 算法的get 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该数据提升为最近使用的</span></span><br><span class="line">    makeRecently(key);</span><br><span class="line">    <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>put 方法比较复杂 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/put.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">           <span class="comment">//删除旧的数据</span></span><br><span class="line">           deleteKey(key);</span><br><span class="line">           <span class="comment">//新插入的数据为最近使用的数据</span></span><br><span class="line">           addRecently(key,val);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(cap == cache.size())&#123;</span><br><span class="line">           <span class="comment">//删除最久未使用的元素</span></span><br><span class="line">           removeLeastRecently();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//添加为最近使用的元素</span></span><br><span class="line">       addRecently(key,val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<p>完整 LRU</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.ECKey;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key -&gt; Nodde(key,val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1</span></span><br><span class="line">    <span class="comment">// ,v1) &lt;-&gt; Node(k2,v2) ...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache ;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;( );</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将某个key提升为最近使用的   */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        Node x=map.get(key);</span><br><span class="line">        <span class="comment">//先从链表中删除这个节点</span></span><br><span class="line">        cache.remove(x);</span><br><span class="line">        <span class="comment">//重新插到队尾</span></span><br><span class="line">        cache.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加最近使用的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key,val);</span><br><span class="line">        <span class="comment">//链表尾就是最近使用的元素</span></span><br><span class="line">        cache.addLast(x);</span><br><span class="line">        <span class="comment">// 在map中添加key 的映射</span></span><br><span class="line">        map.put(key,x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  删除某一个key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        Node x = map.get(key);</span><br><span class="line">        <span class="comment">//从链表中删除</span></span><br><span class="line">        cache.remove(x);</span><br><span class="line">        <span class="comment">//从map中删除</span></span><br><span class="line">        map.remove(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除最久未使用的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表头部的第一个元素就是最久未使用的</span></span><br><span class="line">        Node deleteNode = cache.removeFirst();</span><br><span class="line">        <span class="comment">//同时别忘了从高map中 删除它的key</span></span><br><span class="line">        <span class="keyword">int</span> deletedKey = deleteNode.key;</span><br><span class="line">        map.remove(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将该数据提升为最近使用的</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span>  map.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//删除旧的数据</span></span><br><span class="line">            deleteKey(key);</span><br><span class="line">            <span class="comment">//新插入的数据为最近使用的数据</span></span><br><span class="line">            addRecently(key,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cap == cache.size())&#123;</span><br><span class="line">            <span class="comment">//删除最久未使用的元素</span></span><br><span class="line">            removeLeastRecently();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加为最近使用的元素</span></span><br><span class="line">        addRecently(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用内置LinkedHashMap实现"><a href="#使用内置LinkedHashMap实现" class="headerlink" title="使用内置LinkedHashMap实现"></a>使用内置LinkedHashMap实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> * 使用java内置类型LinkedHashMap实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer,Integer&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> captity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = captity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将key 变为最近使用</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//修改key 值</span></span><br><span class="line">            cache.put(key,val);</span><br><span class="line">            <span class="comment">//将key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="keyword">this</span>.cap)&#123;</span><br><span class="line">            <span class="comment">//链表头部为最久未使用的key</span></span><br><span class="line">            <span class="keyword">int</span> oldestKey = cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新的key 添加到 链表尾部</span></span><br><span class="line">        cache.put(key,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = cache.get(key);</span><br><span class="line">        <span class="comment">//删除key ,重新插入队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h3><p>其中点号「.」可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数（包括 0 次）</p>
<p>模式串 “.a*b” 可以匹配文本”zaaab”,也可以匹配”cb” : </p>
<p>模式串”a..b” 可以匹配文本 “amnb” ,</p>
<p>模式串”.*” 可以匹配任何文本</p>
<p>函数签名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">isMatch</span><span class="params">(string s, string p)</span></span>;</span><br></pre></td></tr></table></figure>



<p> 遇到 , 通配符, 无脑匹配 </p>
<p>遇到 * 通配符, 前面的字符可以选择重复一次, 可以重复多次, 也可以一次都不出现,</p>
<p>全部穷举一遍, 只要有一种情况可以完成匹配, 就认为 p可以匹配 s. 设计到两个字符串的穷举, 我们可以想到动态规划的技巧 </p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>s 和 p相互匹配的过程大致是: 两个指针i, j分别再 s 和 p 上移动, 如果最后两个指针都能移动到字符串的末尾, 那么就匹配成功, 反之则匹配失败</p>
<p>先不考虑 * 通配符 , 面对两个待匹配字符 s[i] 和 p[j], 我们唯一能做的就是看他俩是否匹配 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 「.」通配符就是万金油</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配，接着匹配 s[i+1..] 和 p[j+1..]</span></span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当p[j+1]为* 通配符时,分情况讨论</p>
<ol>
<li>如果s[i]==p[j] ,那么有两种情况:</li>
</ol>
<p>1.1 <code>p[j]</code> 有可能会匹配多个字符，比如 <code>s = &quot;aaa&quot;, p = &quot;a*&quot;</code>，那么 <code>p[0]</code> 会通过 <code>*</code> 匹配 3 个字符 <code>&quot;a&quot;</code>。</p>
<p>1.2 <code>p[i]</code> 也有可能匹配 0 个字符，比如 <code>s = &quot;aa&quot;, p = &quot;a*aa&quot;</code>，由于后面的字符可以匹配 <code>s</code>，所以 <code>p[0]</code> 只能匹配 0 次。</p>
<p>2.如果s[i] !=p[j] , 只有一种情况: </p>
<p><code>p[j]</code> 只能匹配 0 次，然后看下一个字符是否能和 <code>s[i]</code> 匹配。比如说 <code>s = &quot;aa&quot;, p = &quot;b*aa&quot;</code>，此时 <code>p[0]</code> 只能匹配 0 次。</p>
<p>综上, 可以把之前的代码针对 * 通配符进行一下改造 :</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    <span class="comment">// 匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，可以匹配 0 次或多次</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，老老实实匹配 1 次</span></span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，只能匹配 0 次0</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，匹配无法进行下去了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的问题是, 遇到 *通配符时, 是匹配0次还是多次 ?多次是几次?</p>
<p>做选择 , 要把所有可能的选择都穷举一遍才能得出结果,动态规划算法的核心就是状态和选择 ,     </p>
<p><strong>「状态」无非就是 <code>i</code> 和 <code>j</code> 两个指针的位置，「选择」就是 <code>p[j]</code> 选择匹配几个字符</strong>。</p>
<h4 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h4><p>根据[状态] . 我们可以定义一个dp函数 :</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">String</span> &amp;s,<span class="keyword">int</span> i, <span class="keyword">String</span>&amp; p,<span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>dp</code> 函数的定义如下：</p>
<p><strong>若 <code>dp(s, i, p, j) = true</code>，则表示 <code>s[i..]</code> 可以匹配 <code>p[j..]</code>；若 <code>dp(s, i, p, j) = false</code>，则表示 <code>s[i..]</code> 无法匹配 <code>p[j..]</code></strong>。</p>
<p>根据这个定义，我们想要的答案就是 <code>i = 0, j = 0</code> 时 <code>dp</code> 函数的结果，所以可以这样使用这个 <code>dp</code> 函数：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isMatch(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="comment">// 指针 i，j 从索引 0 开始移动</span></span><br><span class="line">    <span class="keyword">return</span> dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>可以根据之前代码写出dp 函数的主要逻辑 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">dp</span><span class="params">(string&amp; s, <span class="keyword">int</span> i, string&amp; p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.1 通配符匹配 0 次或多次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">                || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 常规匹配 1 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1 通配符匹配 0 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 无法继续匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 dp函数定义  ,解释上面几种情况</p>
<p>1.1 通配符匹配 0 次或多次 </p>
<p>将 j 加 2 , i 不变, 含义就是直接跳过 p[j] 和之后的通配符, 即通配符匹配0 次: </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525093139151.png" alt="image-20210525093139151"></p>
<p>将 i 加 1 , j 不变 , 含义就是p[j] 匹配了s[i] , 但p[j] 还可以继续匹配 ,即通配符匹配多次的情况 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525133839423.png" alt="image-20210525133839423"></p>
<p>两种情况只要有一种可以完成匹配即可,所以对上面两种情况求或运算 </p>
<p>1.2常规匹配一次</p>
<p>由于这个条件是无 * 的常规匹配, 那么如果 s[i]==p[j],就是i 和 j分别 +1 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134455666.png" alt="image-20210525134455666"></p>
<p>2.通配符匹配0 次 </p>
<p>类似情况1.1, 将j+2, i不变 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134523208.png" alt="image-20210525134523208"></p>
<p>2.2 如果没有 ***** 通配符,也无法匹配 ,那么只能说明匹配失败了 : </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134612750.png" alt="image-20210525134612750"></p>
<p>现在思考dp 函数的 base case </p>
<p>一个base case 是 j == p.length() 时, 按照dp 函数的定义,这意味着模式串 p已经被匹配完了, 那么应该看文本串 s 匹配 到哪里了, 如果 s也恰好被匹配完, 则说明匹配成功 </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">j</span>==p.<span class="built_in">length</span>())&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i</span>==s.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 另一个 base case是 i == s.length()时, 按照dp函数的定义, 这种情况意味着 文本串 s 已经被全部匹配了, 那么接下来需要怎么做? </p>
<p>只要简单地检查一下p是否也匹配玩就行了嘛 ? </p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==s.<span class="built_in">length</span>())&#123;</span><br><span class="line">	<span class="comment">//just do this ? </span></span><br><span class="line">	<span class="keyword">return</span> j == p.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样不正确, 此时并不能根据j是否等于p.length()来判断是否完成匹配 , 只要p[j..] 能够匹配字符串, 就可以完成匹配 ,比如说 </p>
<p>s=’a’, p”‘ab* c*”, 当i走到末尾时,j没有走到p末尾, 但是p 依然可以匹配s </p>
<p>所以</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> m = s.length(), n=p.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==s.length())&#123;</span><br><span class="line">	<span class="comment">//如果能匹配空串, 一定是字符和* 成对出现 </span></span><br><span class="line">	<span class="keyword">if</span>((n-j)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查是否为x*y*z*这种形式</span></span><br><span class="line">	<span class="keyword">for</span> (;j+<span class="number">1</span>&lt;p.length();j+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[j+<span class="number">1</span>]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上 , 写出完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 计算 p[j..] 是否匹配 s[i..] */</span></span><br><span class="line"><span class="function">bool <span class="title">dp</span><span class="params">(string&amp; s, <span class="keyword">int</span> i, string&amp; p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size();</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录状态 (i, j)，消除重叠子问题</span></span><br><span class="line">    string key = to_string(i) + <span class="string">","</span> + to_string(j);</span><br><span class="line">    <span class="keyword">if</span> (memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    </span><br><span class="line">    bool res = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">               || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前结果记入备忘录</span></span><br><span class="line">    memo[key] = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码中用了一个哈希表 <code>memo</code> 消除重叠子问题，因为正则表达算法的递归框架如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> dp(<span class="built_in">string</span>&amp; s, <span class="built_in">int</span> i, <span class="built_in">string</span>&amp; p, <span class="built_in">int</span> j) &#123;</span><br><span class="line">    dp(s, i, p, j + <span class="number">2</span>);     <span class="comment">// 1</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j);     <span class="comment">// 2</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么, 如果让你从dp(s,i,p,j)得到dp(s, i+2, p,j+2) 至少有两条路径 , 1-&gt; 2 -&gt; 2 和 3-&gt; 3 , 那么就说明 (i+2,j+2)这个状态存在重复 </p>
<p>,这就说明存在重叠子问题 </p>
<p>动态规划的时间复杂度为 [状态的总数]* [每次递归花费的时间], 本题中状态的总数当然就是i 和 j的组合, 也是M*N(M为s的长度, N为p的长度); 递归函数dp]中没有循环(base case 中的不考虑, 因为base case的出发次数有限), 所以一次递归花费的时间为常数, ,二者相乘, 总的实时间复杂度为O(MN)</p>
<p>空间复杂度就是备忘录 memo的大小, 即O(MN)</p>
<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210602220300826.png" alt="image-20210602220300826"></p>
<p>​    </p>
<p>滑动算法大致逻辑如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">right</span> &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[<span class="keyword">right</span>]);</span><br><span class="line">    <span class="keyword">right</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[<span class="keyword">left</span>]);</span><br><span class="line">        <span class="keyword">left</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间度为O(n)</p>
<p>框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="keyword">String</span> s ,<span class="keyword">String</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="comment">//c 是将移入窗口的字符 </span></span><br><span class="line">		<span class="keyword">char</span> c=s[right];</span><br><span class="line">		right++;</span><br><span class="line">		<span class="comment">//窗口的一系列更新呢 </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/** debug 输出位置  **/</span> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"window: [%d, %d]\n"</span>,left,right);</span><br><span class="line">		<span class="comment">/***************/</span></span><br><span class="line">		<span class="comment">//增加左划窗口是否要收缩 </span></span><br><span class="line">		<span class="keyword">while</span>(window needs sharink)&#123;</span><br><span class="line">			<span class="comment">//d是将移出窗口的字符 </span></span><br><span class="line">			<span class="keyword">char</span> d = s[left];</span><br><span class="line">			<span class="comment">//左移窗口</span></span><br><span class="line">			left++;</span><br><span class="line">			<span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左移和右移的窗口更新操作是完全对称的 </p>
<p><code>unordered_map</code>是哈希表(字典), count(key) 相当于Java 的<code>containsKey(Key)</code> 可以判断key是否存在 </p>
<p>可以使用方括号访问键对应的值map[key], 需要注意的是, 如果该key 不存在,C++会自动创建这个key, 并把map[key]赋值为0 </p>
<p>map[key]++ 相当于Java 的map.put(key,map.getOrDefault(key,0)+1) </p>
<h4 id="leetcode-no-76"><a href="#leetcode-no-76" class="headerlink" title="leetcode no.76"></a>leetcode no.76</h4><p>最小覆盖字串 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603084923351.png" alt="image-20210603084923351"></p>
<p>函数签名</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">minWindow</span><span class="params">(<span class="keyword">String</span>,<span class="keyword">String</span> t)</span></span></span><br></pre></td></tr></table></figure>

<p>暴力解法大致</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;s.<span class="built_in">size</span>();<span class="built_in">i</span>++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(int <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>; <span class="built_in">j</span>&lt;s.<span class="built_in">size</span>();<span class="built_in">j</span>++J);</span><br><span class="line">		<span class="keyword">if</span> s[<span class="built_in">i</span>:<span class="built_in">j</span>] 包含t的所有字母 :</span><br><span class="line">			更新答案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口算法的思路 : </p>
<ol>
<li>在字符串S中使用双指针中的左右指针技巧, 初始化left = right = 0, 把索引左闭右开区间[left,right) 称为一个[窗口]</li>
<li>我们先不断地增加right 指针扩大窗口 [left,right), 找到窗口中的字符串符合要求(包含了T中的所有字符). </li>
<li>此时, 我们停止增加right, 转而不断增加left 指针缩小窗口 , 直到窗口中的字符串不再符合要求(不包含T中的所有字符串了)同时, 每次增加left, 我们都要更新一轮结果 </li>
<li>重复第2 步和第 3 步, 直到right达到字符串S的尽头 </li>
</ol>
<p>第 2 步相当于在寻找一个[可行解], 然后第3步在优化这个可行解, 最终找到最优解 , 也就是最短的覆盖字串. 左右指针轮流前进, 窗口大小增增减减, 窗口不断向右滑动, 这就是[[滑动窗口]] 这个名字来历</p>
<p>needs 和window 相当于计数器, 分别记录T中字符出现次数和[窗口]中的相应字符的出现次数</p>
<p>初始状态<img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603090902363.png" alt="image-20210603090902363"></p>
<p>增加 right, 直到窗口[left,right) 包含了 T中所有字符</p>
<p> <img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091238580.png" alt="image-20210603091238580"></p>
<p>增加left ,缩小窗口</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091323476.png" alt="image-20210603091323476"></p>
<p>直到窗口中的字符串不再符合要求, left不再移动</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091404705.png" alt="image-20210603091404705"></p>
<p>之后重复上述过程，先移动<code>right</code>，再移动<code>left</code>…… 直到<code>right</code>指针到达字符串<code>S</code>的末端，算法结束。</p>
<p>初始化 window 和 need 两个哈希表 ,记录窗口中的字符和需要凑齐的字符 :</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unrodered_map&lt;<span class="type">char</span>,<span class="type">int</span> &gt;need,<span class="keyword">window</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span>:t)need[c]++;</span><br></pre></td></tr></table></figure>

<p>然后, 使用left 和 right 变量初始化窗口的两端, 区间[left,right) 左闭右开, 初始情况下窗口没有包含任何元素: </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> valid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line">	<span class="comment">//开始滑动 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valid 变量表示窗口中满足 need条件的字符个数， 如果valid 和need.size的大小相同， 则说明窗口已满足条件， 已经完全覆盖了串T。 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603092618795.png" alt="image-20210603092618795"></p>
<p>完整代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need,window;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录最小覆盖字串的起始索引及长度 </span></span><br><span class="line">	<span class="keyword">int</span> start=<span class="number">0</span>, len = INT_MAX;    <span class="comment">//int 占4字节 32位， INT_MAX = 2^31-1</span></span><br><span class="line">	<span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="comment">//c是将要移入窗口的字符</span></span><br><span class="line">		<span class="keyword">char</span> c = s[right];</span><br><span class="line">		<span class="comment">//右移窗口</span></span><br><span class="line">		right++;</span><br><span class="line">		<span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">		<span class="keyword">if</span>(need.count(c))&#123;</span><br><span class="line">			window[c]++;</span><br><span class="line">			<span class="keyword">if</span>(window[c]==need[c])</span><br><span class="line">				valid++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断窗口是否要收缩 </span></span><br><span class="line">		<span class="keyword">while</span>(valid==need.<span class="built_in">size</span>())&#123;</span><br><span class="line">			<span class="comment">//在这里更新最小覆盖子串 </span></span><br><span class="line">			<span class="keyword">if</span>(right-left&lt;len)&#123;</span><br><span class="line">				start = left;</span><br><span class="line">				len = right-left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//d是 将移出窗口的字符 </span></span><br><span class="line">			<span class="keyword">char</span> d = s[left];</span><br><span class="line">			<span class="comment">//左移窗口 </span></span><br><span class="line">			left++ ;</span><br><span class="line">			<span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">			<span class="keyword">if</span>(need.count(d))&#123;</span><br><span class="line">				<span class="keyword">if</span>(window[d]==need[d])</span><br><span class="line">					valid--;</span><br><span class="line">				window[d]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">return</span> len == INT_MAX ? <span class="string">""</span> :s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意的地方 当某个字符在window 的数量满足了need的需要 </p>
<h3 id="股票买卖问题"><a href="#股票买卖问题" class="headerlink" title="股票买卖问题"></a>股票买卖问题</h3><p>参考题目, 共性题目 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609084558020.png" alt="image-20210609084558020"></p>
<p>状态穷举</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609084638141.png" alt="image-20210609084638141"></p>
<p>这个问题的[状态] 有三个, ，第一个是天数，第二个是当天允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有)</p>
<p>可以使用三维数组dp 装下这几种状态的全部组合, for 循环就能完成穷举 </p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609105042701.png" alt="image-20210609105042701"></p>
<p>状态转移方程框架</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210608230032288.png" alt="image-20210608230032288"></p>
<h4 id="k-2-时"><a href="#k-2-时" class="headerlink" title="k=2  时"></a>k=2  时</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的动态转移方程, 没有可化简的地方</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">0</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">0</span>], dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>]+prices[i])</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">i</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>], dp[<span class="string">i-1</span>][<span class="symbol">k-1</span>][<span class="string">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p>因为没有消掉K的影响, 所以必须要用for 循环对 k进行穷举才是正确的</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609232210506.png" alt="image-20210609232210506"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int max_k=2;</span><br><span class="line">int [<span class="string"></span>][<span class="symbol"></span>] dp = new int[<span class="string">n</span>][<span class="symbol">max_k + 1</span>][<span class="string">2</span>];</span><br><span class="line">for(int i=0;i<span class="xml"><span class="tag">&lt;<span class="name">n;i++)&#123;</span></span></span></span><br><span class="line"><span class="xml">	for(int k = max_k; k&gt;</span>=1;k--)&#123;</span><br><span class="line"><span class="code">		if(i-1=-1) &#123; /*处理base case */&#125;</span></span><br><span class="line"><span class="code">		dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span></span><br><span class="line"><span class="code">		dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]- prices[i]);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">//穷举了 n x max_k x 2个状态 ,正确</span><br><span class="line">return dp[<span class="string">n-1</span>][<span class="symbol">max_k</span>][<span class="string">0</span>];</span><br></pre></td></tr></table></figure>

<p>第二种解法：因为这里 k 取值范围比较小，所以也可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也是一样的：</p>
<p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609232650265.png" alt="image-20210609232650265"></p>
<p>有状态转移方程和含义明确的变量名引导，相信你很容易看懂。如我我们想故弄玄虚，可以把上述四个变量换成 a, b, c, d。这样当别人看到你的解法时就会大惊失色，一头雾水，不得不对你肃然起敬。(作者爱装逼, 不是我说的.我没有这样的想法, 顶多换成 wsdl )</p>
<h3 id="括号相关算法"><a href="#括号相关算法" class="headerlink" title="括号相关算法"></a>括号相关算法</h3><h4 id="判断合法括号"><a href="#判断合法括号" class="headerlink" title="判断合法括号"></a>判断合法括号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span>)</span><br><span class="line">            left.push(c);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 字符 c 是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (!left.empty() &amp;&amp; leftOf(c) == left.top())</span><br><span class="line">                left.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 和最近的左括号不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否所有的左括号都被匹配了</span></span><br><span class="line">    <span class="keyword">return</span> left.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'&#125;'</span>) <span class="keyword">return</span> <span class="string">'&#123;'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">')'</span>) <span class="keyword">return</span> <span class="string">'('</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'['</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平衡括号"><a href="#平衡括号" class="headerlink" title="平衡括号"></a>平衡括号</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">No921</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使括号有效的最小添加</span></span><br><span class="line"><span class="comment">     * @param s  需要添加括号的字符串</span></span><br><span class="line"><span class="comment">     * @return 添加次数 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> minAddToMakeValid(String s)&#123;</span><br><span class="line">        <span class="comment">//res 记录插入次数 </span></span><br><span class="line">        <span class="built_in">int</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//need 变量记录右括号需求量</span></span><br><span class="line">        <span class="built_in">int</span> need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;s.size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="comment">//need+1</span></span><br><span class="line">                need ++;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">                need--;</span><br><span class="line">                <span class="keyword">if</span>(need==<span class="number">-1</span>)&#123;</span><br><span class="line">                    need = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//需插入一个左括号</span></span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res+need; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平衡括号串-二"><a href="#平衡括号串-二" class="headerlink" title="平衡括号串(二)"></a>平衡括号串(二)</h4><p>这是力扣第 1541 题「平衡括号字符串的最少插入次数」：</p>
<p>现在假设 1 个左括号需要匹配 2 个右括号才叫做合法的括号组合，那么给你输入一个括号串<code>s</code>，请问你如何计算使得<code>s</code>合法的最小插入次数呢？</p>
<p><strong>核心思路还是和刚才一样，通过一个<code>need</code>变量记录对右括号的需求数，根据<code>need</code>的变化来判断是否需要插入</strong>。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> minInsertions(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            need += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (need % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                need--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            need--;</span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                need = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先，类似第一题，当<code>need == -1</code>时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号</strong>。</p>
<p>比如说当<code>s = &quot;)&quot;</code>，我们肯定需要插入一个左括号让<code>s = &quot;()&quot;</code>，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为 1：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">    need--;</span><br><span class="line">    <span class="comment">// 说明右括号太多了</span></span><br><span class="line">    <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要插入一个左括号</span></span><br><span class="line">        res++;</span><br><span class="line">        <span class="comment">// 同时，对右括号的需求变为 1</span></span><br><span class="line">        need = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号</strong>。因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。</p>
<p>所以遇到左括号时要做如下判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">    need += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (need % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 插入一个右括号</span></span><br><span class="line">        res++;</span><br><span class="line">        <span class="comment">// 对右括号的需求减一</span></span><br><span class="line">        need--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>pOne
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="/jal285.github.io/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="java&#x2F;数据结构">jal285.github.io/java/数据结构/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/java/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" rel="prev" title="java/代码整洁之道">
      <i class="fa fa-chevron-left"></i> java/代码整洁之道
    </a></div>
      <div class="post-nav-item">
    <a href="/java/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" rel="next" title="java/项目开发">
      java/项目开发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">1.1.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">1.2.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指Offer-No-09"><span class="nav-number">1.2.1.</span> <span class="nav-text">剑指Offer No.09</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">1.3.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树遍历框架"><span class="nav-number">1.3.1.</span> <span class="nav-text">二叉树遍历框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">1.3.2.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BST"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">BST</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BST查找操作"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">BST查找操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BST-插入"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">BST 插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BST删除"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">BST删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BST存在的问题"><span class="nav-number">1.3.2.1.4.</span> <span class="nav-text">BST存在的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RBTree"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">RBTree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">1.3.3.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树"><span class="nav-number">1.3.4.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找操作"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">查找操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入操作"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">插入操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希"><span class="nav-number">1.4.</span> <span class="nav-text">哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪心算法"><span class="nav-number">1.5.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OfferNo14-剪绳子问题"><span class="nav-number">1.5.1.</span> <span class="nav-text">OfferNo14   剪绳子问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">1.6.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP字符匹配算法"><span class="nav-number">1.6.1.</span> <span class="nav-text">KMP字符匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#状态机概述"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">状态机概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构建状态转移图"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">构建状态转移图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长递增子序列"><span class="nav-number">1.6.2.</span> <span class="nav-text">最长递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态归纳解法"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">动态归纳解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">二分查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态压缩"><span class="nav-number">1.6.3.</span> <span class="nav-text">状态压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">1.6.4.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">1.7.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU"><span class="nav-number">1.7.1.</span> <span class="nav-text">LRU</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU-设计"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">LRU 设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">put</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用内置LinkedHashMap实现"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">使用内置LinkedHashMap实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达"><span class="nav-number">1.7.2.</span> <span class="nav-text">正则表达</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路分析"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态规划解法"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">动态规划解法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口算法"><span class="nav-number">1.7.3.</span> <span class="nav-text">滑动窗口算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#leetcode-no-76"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">leetcode no.76</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#股票买卖问题"><span class="nav-number">1.7.4.</span> <span class="nav-text">股票买卖问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#k-2-时"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">k&#x3D;2  时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#括号相关算法"><span class="nav-number">1.7.5.</span> <span class="nav-text">括号相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断合法括号"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">判断合法括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平衡括号"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">平衡括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平衡括号串-二"><span class="nav-number">1.7.5.3.</span> <span class="nav-text">平衡括号串(二)</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="pOne"
      src="/images/cat.jpg">
  <p class="site-author-name" itemprop="name">pOne</p>
  <div class="site-description" itemprop="description">to lean your likes</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jal285" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jal285" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2233451206@qq.com" title="E-Mail → mailto:2233451206@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pOne</span>
  <span>&nbsp;<a href="http://www.miitbeian.gov.cn/" target="_blank" rel="noopener">粤ICP备20006130号</a></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="true"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

<! -- clicklove -->
<script type="text/javascript" src="/js/src/clicklove.js"> </script>
</body>
</html>
